/*
 * $Id: sv_dummy.c,v 1.1 2008/07/08 16:47:11 philipn Exp $
 *
 * Implements a dummy DVS API to allow testing without a DVS card 
 *
 * Copyright (C) 2007 BBC Research, Stuart Cunningham <stuart_hc@users.sourceforge.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/*
    All calls to this dummy implementation will succeed. It will return frame
    data every 40 ms. The video data is colour bars.
    TODO: update to use or match ingex/common/tools/dvs_hardware/dvsoem_dummy.c
*/
 
#if 0
typedef struct {
  int magic;
  int size;
  int version;
  int vgui;
  int prontovideo;
  int debug;
  int pad[10];

} sv_handle;
#endif

#include <string.h>         // For memcpy
#include <stdlib.h>         // For malloc
#include <unistd.h>         // For usleep

#include "dvs_clib.h"
#include "dvs_fifo.h"

static unsigned char *source_dmabuf = NULL;
static int source_frame_size = 0;
static int source_width = 0;
static int source_height = 0;
static sv_fifo_buffer fifo_buffer;

static unsigned char sample_vitc[] = {
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x2a,0x80,0x68,0x80,0xa6,0x80,0xc1,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x2a,0x80,0x68,0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x2a,
0x80,0x68,0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0x94,
0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x2a,0x80,0x68,0x80,0xa6,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x2a,
0x80,0x68,0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0x94,
0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x2a,0x80,0x68,
0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0x94,0x80,0x3c,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x2a,0x80,0x68,0x80,0xa6,0x80,0xbf,0x80,0xc0,0x80,0xc1,
0x80,0xc0,0x80,0xc0,0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x2a,0x80,0x68,0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x2a,0x80,0x68,0x80,0xa6,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0x94,0x80,0x3c,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x3c,0x80,0x94,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x2a,0x80,0x68,0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x2a,
0x80,0x68,0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xa6,0x80,0x68,
0x80,0x2a,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x2a,0x80,0x68,0x80,0xa6,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x2a,0x80,0x68,0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x2a,0x80,0x68,
0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0x94,0x80,0x3c,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x2a,0x80,0x68,0x80,0xa6,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0xc1,0x80,0x94,0x80,0x3c,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x3c,0x80,0x94,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xa6,0x80,0x68,
0x80,0x2a,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x3c,0x80,0x94,
0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xc0,0x80,0xa7,0x80,0x68,0x80,0x2a,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,
0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10
};

// Represent the colour and position of a colour bar
typedef struct {
    double          position;
    unsigned char   colour[4];
} bar_colour_t;

// Generate a video buffer containing uncompressed UYVY video representing
// the familiar colour bars test signal (or YUY2 video if specified).
static void create_colour_bars(unsigned char *video_buffer, int width, int height)
{
    int             i,j,b;
    bar_colour_t    UYVY_table[] = {
                {52/720.0,  {0x80,0xEB,0x80,0xEB}}, // white
                {140/720.0, {0x10,0xD2,0x92,0xD2}}, // yellow
                {228/720.0, {0xA5,0xA9,0x10,0xA9}}, // cyan
                {316/720.0, {0x35,0x90,0x22,0x90}}, // green
                {404/720.0, {0xCA,0x6A,0xDD,0x6A}}, // magenta
                {492/720.0, {0x5A,0x51,0xF0,0x51}}, // red
                {580/720.0, {0xf0,0x29,0x6d,0x29}}, // blue
                {668/720.0, {0x80,0x10,0x80,0x10}}, // black
                {720/720.0, {0x80,0xEB,0x80,0xEB}}  // white
            };

    for (j = 0; j < height; j++)
    {
        for (i = 0; i < width; i+=2)
        {
            for (b = 0; b < 9; b++)
            {
                if ((i / ((double)width)) < UYVY_table[b].position)
                {
                    // UYVY packing
                    video_buffer[j*width*2 + i*2 + 0] = UYVY_table[b].colour[0];
                    video_buffer[j*width*2 + i*2 + 1] = UYVY_table[b].colour[1];
                    video_buffer[j*width*2 + i*2 + 2] = UYVY_table[b].colour[2];
                    video_buffer[j*width*2 + i*2 + 3] = UYVY_table[b].colour[3];
                    break;
                }
            }
        }
    }
}

// SV implementations
int sv_fifo_init(sv_handle * sv, sv_fifo ** ppfifo, int bInput, int bShared, int bDMA, int flagbase, int nframes)
{
    return SV_OK;
}
int sv_fifo_free(sv_handle * sv, sv_fifo * pfifo)
{
    return SV_OK;
}
int sv_fifo_start(sv_handle * sv, sv_fifo * pfifo)
{
    return SV_OK;
}
int sv_fifo_getbuffer(sv_handle * sv, sv_fifo * pfifo, sv_fifo_buffer ** pbuffer, sv_fifo_bufferinfo * bufferinfo, int flags)
{
    *pbuffer = &fifo_buffer;

    // simulate typical behaviour of recording fifo by sleeping
    usleep(39 * 1000);

    return SV_OK;
}
int sv_fifo_putbuffer(sv_handle * sv, sv_fifo * pfifo, sv_fifo_buffer * pbuffer, sv_fifo_bufferinfo * bufferinfo)
{
    // For record, copy video + audio to dma.addr
    memcpy(pbuffer->dma.addr, source_dmabuf, source_frame_size);

    // Update timecodes
    // TODO

    return SV_OK;
}
int sv_fifo_stop(sv_handle * sv, sv_fifo * pfifo, int flags)
{
    return SV_OK;
}
int sv_query(sv_handle * sv, int cmd, int par, int *val)
{
    *val = SV_OK;
    return SV_OK;
}
int sv_currenttime(sv_handle * sv, int brecord, int *ptick, uint32 *pclockhigh, uint32 *pclocklow)
{
    return SV_OK;
}

int sv_fifo_status(sv_handle * sv, sv_fifo * pfifo, sv_fifo_info * pinfo)
{
    // Pretend everything is working correctly
    pinfo->dropped = 0;

    return SV_OK;
}

int sv_videomode(sv_handle * sv, int videomode)
{
    return SV_OK;
}

int sv_openex(sv_handle ** psv, char * setup, int openprogram, int opentype, int timeout, int spare)
{
    // Initialise with D3 sample frame for recording
    int width = 720;
    int height = 576 + 16;                              // 16 lines of VBI
    int video_size = width * height * 2;

    // DVS dma transfer buffer is:
    // <video (UYVY)><audio ch 1+2 with fill to 0x4000><audio ch 3+4 with fill>
    source_frame_size = video_size + 0x4000 + 0x4000;
    source_dmabuf = malloc(source_frame_size);
    unsigned char *video = source_dmabuf;
    unsigned char *audio12 = video + video_size;
    unsigned char *audio34 = audio12 + 0x4000;

    // copy sample VITC into VBI
    int i;
    for (i = 0; i < 16; i++) {
        memcpy(video + i * sizeof(sample_vitc), sample_vitc, sizeof(sample_vitc));
    }

    // setup colorbars
    create_colour_bars(video + width * 16 * 2, width, 576);

    // TODO: create audio tone or click
    for (i = 0; i < 0x4000; i += 8) {
        audio12[i+0] = 0x00;    audio34[i+0] = 0x80;
        audio12[i+1] = 0x01;    audio34[i+1] = 0x81;
        audio12[i+2] = 0x02;    audio34[i+2] = 0x82;
        audio12[i+3] = 0x03;    audio34[i+3] = 0x83;
        audio12[i+4] = 0x04;    audio34[i+4] = 0x84;
        audio12[i+5] = 0x05;    audio34[i+5] = 0x85;
        audio12[i+6] = 0x06;    audio34[i+6] = 0x86;
        audio12[i+7] = 0x07;    audio34[i+7] = 0x87;
    }

    // Setup fifo_buffer which contains offsets to audio buffers
    fifo_buffer.audio[0].addr[0] = (char*)video_size;
    fifo_buffer.audio[0].addr[1] = (char*)(video_size + 0x4000);

    source_width = width;
    source_height = height;
    
    return SV_OK;
}

int sv_close(sv_handle * sv)
{
    free(source_dmabuf);
    return SV_OK;
}


char * sv_geterrortext(int code)
{
    static char *errorstr = "Error string not implemented";
    return errorstr;
}


int sv_status(sv_handle * sv, sv_info * info)
{
    info->xsize = source_width;
    info->ysize = source_height;
    return SV_OK;
}

int sv_stop(sv_handle * sv)
{
    return SV_OK;
}


