--- libavcodec/dv.c	2009-02-20 13:00:44.000000000 +1100
+++ ../ffmpeg-0.5-DVCPROHD/libavcodec/dv.c	2009-03-16 12:11:28.083444869 +1100
@@ -48,19 +48,26 @@
 //#include <assert.h>
 
 typedef struct DVVideoContext {
-    const DVprofile *sys;
-    AVFrame          picture;
-    AVCodecContext  *avctx;
-    uint8_t         *buf;
+    const DVprofile* sys;
+    AVFrame picture;
+    AVCodecContext *avctx;
+    uint8_t *buf;
 
-    uint8_t  dv_zigzag[2][64];
+    uint8_t dv_zigzag[2][64];
+    uint8_t dv_idct_shift[2][2][22][64];
 
     void (*get_pixels)(DCTELEM *block, const uint8_t *pixels, int line_size);
     void (*fdct[2])(DCTELEM *block);
     void (*idct_put[2])(uint8_t *dest, int line_size, DCTELEM *block);
-    me_cmp_func ildct_cmp;
 } DVVideoContext;
 
+/* MultiThreading - dv_anchor applies to entire DV codec, not just the avcontext */
+/* one element is needed for each video segment in a DV frame */
+/* at most there are 4 DIF channels * 12 DIF sequences * 27 video segments (1080i50) */
+#define DV_ANCHOR_SIZE (4*12*27)
+
+static void* dv_anchor[DV_ANCHOR_SIZE];
+
 #define TEX_VLC_BITS 9
 
 #if CONFIG_SMALL
@@ -68,224 +75,66 @@
 #define DV_VLC_MAP_LEV_SIZE 23
 #else
 #define DV_VLC_MAP_RUN_SIZE  64
-#define DV_VLC_MAP_LEV_SIZE 512 //FIXME sign was removed so this should be /2 but needs check
+#define DV_VLC_MAP_LEV_SIZE 256
 #endif
 
 /* XXX: also include quantization */
 static RL_VLC_ELEM dv_rl_vlc[1184];
 /* VLC encoding lookup table */
-static struct dv_vlc_pair {
-   uint32_t vlc;
-   uint8_t  size;
-} dv_vlc_map[DV_VLC_MAP_RUN_SIZE][DV_VLC_MAP_LEV_SIZE];
-
-static inline int dv_work_pool_size(const DVprofile *d)
-{
-    int size = d->n_difchan*d->difseg_size*27;
-    if (DV_PROFILE_IS_1080i50(d))
-        size -= 3*27;
-    if (DV_PROFILE_IS_720p50(d))
-        size -= 4*27;
-    return size;
-}
-
-static inline void dv_calc_mb_coordinates(const DVprofile *d, int chan, int seq, int slot,
-                                          uint16_t *tbl)
-{
-    static const uint8_t off[] = { 2, 6, 8, 0, 4 };
-    static const uint8_t shuf1[] = { 36, 18, 54, 0, 72 };
-    static const uint8_t shuf2[] = { 24, 12, 36, 0, 48 };
-    static const uint8_t shuf3[] = { 18, 9, 27, 0, 36 };
-
-    static const uint8_t l_start[] = {0, 4, 9, 13, 18, 22, 27, 31, 36, 40};
-    static const uint8_t l_start_shuffled[] = { 9, 4, 13, 0, 18 };
-
-    static const uint8_t serpent1[] = {0, 1, 2, 2, 1, 0,
-                                       0, 1, 2, 2, 1, 0,
-                                       0, 1, 2, 2, 1, 0,
-                                       0, 1, 2, 2, 1, 0,
-                                       0, 1, 2};
-    static const uint8_t serpent2[] = {0, 1, 2, 3, 4, 5, 5, 4, 3, 2, 1, 0,
-                                       0, 1, 2, 3, 4, 5, 5, 4, 3, 2, 1, 0,
-                                       0, 1, 2, 3, 4, 5};
-
-    static const uint8_t remap[][2] = {{ 0, 0}, { 0, 0}, { 0, 0}, { 0, 0}, /* dummy */
-                                       { 0, 0}, { 0, 1}, { 0, 2}, { 0, 3}, {10, 0},
-                                       {10, 1}, {10, 2}, {10, 3}, {20, 0}, {20, 1},
-                                       {20, 2}, {20, 3}, {30, 0}, {30, 1}, {30, 2},
-                                       {30, 3}, {40, 0}, {40, 1}, {40, 2}, {40, 3},
-                                       {50, 0}, {50, 1}, {50, 2}, {50, 3}, {60, 0},
-                                       {60, 1}, {60, 2}, {60, 3}, {70, 0}, {70, 1},
-                                       {70, 2}, {70, 3}, { 0,64}, { 0,65}, { 0,66},
-                                       {10,64}, {10,65}, {10,66}, {20,64}, {20,65},
-                                       {20,66}, {30,64}, {30,65}, {30,66}, {40,64},
-                                       {40,65}, {40,66}, {50,64}, {50,65}, {50,66},
-                                       {60,64}, {60,65}, {60,66}, {70,64}, {70,65},
-                                       {70,66}, { 0,67}, {20,67}, {40,67}, {60,67}};
-
-    int i, k, m;
-    int x, y, blk;
-
-    for (m=0; m<5; m++) {
-         switch (d->width) {
-         case 1440:
-              blk = (chan*11+seq)*27+slot;
-
-              if (chan == 0 && seq == 11) {
-                  x = m*27+slot;
-                  if (x<90) {
-                      y = 0;
-                  } else {
-                      x = (x - 90)*2;
-                      y = 67;
-                  }
-              } else {
-                  i = (4*chan + blk + off[m])%11;
-                  k = (blk/11)%27;
+static uint32_t dv_vlc_map_vlc[DV_VLC_MAP_RUN_SIZE][DV_VLC_MAP_LEV_SIZE];
+static uint8_t dv_vlc_map_size[DV_VLC_MAP_RUN_SIZE][DV_VLC_MAP_LEV_SIZE];
 
-                  x = shuf1[m] + (chan&1)*9 + k%9;
-                  y = (i*3+k/9)*2 + (chan>>1) + 1;
-              }
-              tbl[m] = (x<<1)|(y<<9);
-              break;
-         case 1280:
-              blk = (chan*10+seq)*27+slot;
-
-              i = (4*chan + (seq/5) + 2*blk + off[m])%10;
-              k = (blk/5)%27;
-
-              x = shuf1[m]+(chan&1)*9 + k%9;
-              y = (i*3+k/9)*2 + (chan>>1) + 4;
-
-              if (x >= 80) {
-                  x = remap[y][0]+((x-80)<<(y>59));
-                  y = remap[y][1];
-              }
-              tbl[m] = (x<<1)|(y<<9);
-              break;
-       case 960:
-              blk = (chan*10+seq)*27+slot;
-
-              i = (4*chan + (seq/5) + 2*blk + off[m])%10;
-              k = (blk/5)%27 + (i&1)*3;
-
-              x = shuf2[m] + k%6 + 6*(chan&1);
-              y = l_start[i] + k/6 + 45*(chan>>1);
-              tbl[m] = (x<<1)|(y<<9);
-              break;
-        case 720:
-              switch (d->pix_fmt) {
-              case PIX_FMT_YUV422P:
-                   x = shuf3[m] + slot/3;
-                   y = serpent1[slot] +
-                       ((((seq + off[m]) % d->difseg_size)<<1) + chan)*3;
-                   tbl[m] = (x<<1)|(y<<8);
-                   break;
-              case PIX_FMT_YUV420P:
-                   x = shuf3[m] + slot/3;
-                   y = serpent1[slot] +
-                       ((seq + off[m]) % d->difseg_size)*3;
-                   tbl[m] = (x<<1)|(y<<9);
-                   break;
-              case PIX_FMT_YUV411P:
-                   i = (seq + off[m]) % d->difseg_size;
-                   k = slot + ((m==1||m==2)?3:0);
-
-                   x = l_start_shuffled[m] + k/6;
-                   y = serpent2[k] + i*6;
-                   if (x>21)
-                       y = y*2 - i*6;
-                   tbl[m] = (x<<2)|(y<<8);
-                   break;
-              }
-        default:
-              break;
-        }
-    }
-}
 
-static int dv_init_dynamic_tables(const DVprofile *d)
+static void dv_build_unquantize_tables(DVVideoContext *s, uint8_t* perm)
 {
-    int j,i,c,s,p;
-    uint32_t *factor1, *factor2;
-    const int *iweight1, *iweight2;
+    int i, q, j;
 
-    if (!d->work_chunks[dv_work_pool_size(d)-1].buf_offset) {
-        p = i = 0;
-        for (c=0; c<d->n_difchan; c++) {
-            for (s=0; s<d->difseg_size; s++) {
-                p += 6;
-                for (j=0; j<27; j++) {
-                    p += !(j%3);
-                    if (!(DV_PROFILE_IS_1080i50(d) && c != 0 && s == 11) &&
-                        !(DV_PROFILE_IS_720p50(d) && s > 9)) {
-                          dv_calc_mb_coordinates(d, c, s, j, &d->work_chunks[i].mb_coordinates[0]);
-                          d->work_chunks[i++].buf_offset = p;
-                    }
-                    p += 5;
-                }
-            }
+    /* NOTE: max left shift is 6 */
+    for(q = 0; q < 22; q++) {
+        /* 88DCT */
+        for(i = 1; i < 64; i++) {
+            /* 88 table */
+            j = perm[i];
+            s->dv_idct_shift[0][0][q][j] =
+                dv_quant_shifts[q][dv_88_areas[i]] + 1;
+            s->dv_idct_shift[1][0][q][j] = s->dv_idct_shift[0][0][q][j] + 1;
+        }
+
+        /* 248DCT */
+        for(i = 1; i < 64; i++) {
+            /* 248 table */
+            s->dv_idct_shift[0][1][q][i] =
+                dv_quant_shifts[q][dv_248_areas[i]] + 1;
+            s->dv_idct_shift[1][1][q][i] = s->dv_idct_shift[0][1][q][i] + 1;
         }
     }
-
-    if (!d->idct_factor[DV_PROFILE_IS_HD(d)?8191:5631]) {
-        factor1 = &d->idct_factor[0];
-        factor2 = &d->idct_factor[DV_PROFILE_IS_HD(d)?4096:2816];
-        if (d->height == 720) {
-            iweight1 = &dv_iweight_720_y[0];
-            iweight2 = &dv_iweight_720_c[0];
-        } else {
-            iweight1 = &dv_iweight_1080_y[0];
-            iweight2 = &dv_iweight_1080_c[0];
-            }
-        if (DV_PROFILE_IS_HD(d)) {
-            for (c = 0; c < 4; c++) {
-                for (s = 0; s < 16; s++) {
-                    for (i = 0; i < 64; i++) {
-                        *factor1++ = (dv100_qstep[s] << (c + 9)) * iweight1[i];
-                        *factor2++ = (dv100_qstep[s] << (c + 9)) * iweight2[i];
-                    }
-                }
-            }
-        } else {
-            iweight1 = &dv_iweight_88[0];
-            for (j = 0; j < 2; j++, iweight1 = &dv_iweight_248[0]) {
-                for (s = 0; s < 22; s++) {
-                    for (i = c = 0; c < 4; c++) {
-                        for (; i < dv_quant_areas[c]; i++) {
-                            *factor1   = iweight1[i] << (dv_quant_shifts[s][c] + 1);
-                            *factor2++ = (*factor1++) << 1;
-        }
-    }
-            }
-        }
-    }
-}
-
-    return 0;
 }
 
 static av_cold int dvvideo_init(AVCodecContext *avctx)
 {
     DVVideoContext *s = avctx->priv_data;
     DSPContext dsp;
-    static int done = 0;
+    static int done=0;
     int i, j;
 
     if (!done) {
         VLC dv_vlc;
         uint16_t new_dv_vlc_bits[NB_DV_VLC*2];
-        uint8_t  new_dv_vlc_len[NB_DV_VLC*2];
-        uint8_t  new_dv_vlc_run[NB_DV_VLC*2];
-        int16_t  new_dv_vlc_level[NB_DV_VLC*2];
+        uint8_t new_dv_vlc_len[NB_DV_VLC*2];
+        uint8_t new_dv_vlc_run[NB_DV_VLC*2];
+        int16_t new_dv_vlc_level[NB_DV_VLC*2];
 
         done = 1;
 
+        /* dv_anchor lets each thread know its Id */
+        for (i=0; i<DV_ANCHOR_SIZE; i++)
+            dv_anchor[i] = (void*)(size_t)i;
+
         /* it's faster to include sign bit in a generic VLC parsing scheme */
-        for (i = 0, j = 0; i < NB_DV_VLC; i++, j++) {
-            new_dv_vlc_bits[j]  = dv_vlc_bits[i];
-            new_dv_vlc_len[j]   = dv_vlc_len[i];
-            new_dv_vlc_run[j]   = dv_vlc_run[i];
+        for (i=0, j=0; i<NB_DV_VLC; i++, j++) {
+            new_dv_vlc_bits[j] = dv_vlc_bits[i];
+            new_dv_vlc_len[j] = dv_vlc_len[i];
+            new_dv_vlc_run[j] = dv_vlc_run[i];
             new_dv_vlc_level[j] = dv_vlc_level[i];
 
             if (dv_vlc_level[i]) {
@@ -293,9 +142,9 @@
                 new_dv_vlc_len[j]++;
 
                 j++;
-                new_dv_vlc_bits[j]  = (dv_vlc_bits[i] << 1) | 1;
-                new_dv_vlc_len[j]   =  dv_vlc_len[i] + 1;
-                new_dv_vlc_run[j]   =  dv_vlc_run[i];
+                new_dv_vlc_bits[j] = (dv_vlc_bits[i] << 1) | 1;
+                new_dv_vlc_len[j] = dv_vlc_len[i] + 1;
+                new_dv_vlc_run[j] = dv_vlc_run[i];
                 new_dv_vlc_level[j] = -dv_vlc_level[i];
             }
         }
@@ -304,23 +153,22 @@
            to accelerate the parsing of partial codes */
         init_vlc(&dv_vlc, TEX_VLC_BITS, j,
                  new_dv_vlc_len, 1, 1, new_dv_vlc_bits, 2, 2, 0);
-        assert(dv_vlc.table_size == 1184);
 
-        for (i = 0; i < dv_vlc.table_size; i++){
-            int code = dv_vlc.table[i][0];
-            int len  = dv_vlc.table[i][1];
+        for(i = 0; i < dv_vlc.table_size; i++){
+            int code= dv_vlc.table[i][0];
+            int len = dv_vlc.table[i][1];
             int level, run;
 
-            if (len < 0){ //more bits needed
-                run   = 0;
-                level = code;
+            if(len<0){ //more bits needed
+                run= 0;
+                level= code;
             } else {
-                run   = new_dv_vlc_run  [code] + 1;
-                level = new_dv_vlc_level[code];
+                run=   new_dv_vlc_run[code] + 1;
+                level= new_dv_vlc_level[code];
             }
-            dv_rl_vlc[i].len   = len;
+            dv_rl_vlc[i].len = len;
             dv_rl_vlc[i].level = level;
-            dv_rl_vlc[i].run   = run;
+            dv_rl_vlc[i].run = run;
         }
         free_vlc(&dv_vlc);
 
@@ -332,36 +180,38 @@
                continue;
 #endif
 
-           if (dv_vlc_map[dv_vlc_run[i]][dv_vlc_level[i]].size != 0)
+           if (dv_vlc_map_size[dv_vlc_run[i]][dv_vlc_level[i]] != 0)
                continue;
 
-           dv_vlc_map[dv_vlc_run[i]][dv_vlc_level[i]].vlc  =
-               dv_vlc_bits[i] << (!!dv_vlc_level[i]);
-           dv_vlc_map[dv_vlc_run[i]][dv_vlc_level[i]].size =
-               dv_vlc_len[i] + (!!dv_vlc_level[i]);
+           dv_vlc_map_vlc[dv_vlc_run[i]][dv_vlc_level[i]] = dv_vlc_bits[i] <<
+                                                            (!!dv_vlc_level[i]);
+           dv_vlc_map_size[dv_vlc_run[i]][dv_vlc_level[i]] = dv_vlc_len[i] +
+                                                             (!!dv_vlc_level[i]);
         }
         for (i = 0; i < DV_VLC_MAP_RUN_SIZE; i++) {
 #if CONFIG_SMALL
            for (j = 1; j < DV_VLC_MAP_LEV_SIZE; j++) {
-              if (dv_vlc_map[i][j].size == 0) {
-                  dv_vlc_map[i][j].vlc = dv_vlc_map[0][j].vlc |
-                            (dv_vlc_map[i-1][0].vlc << (dv_vlc_map[0][j].size));
-                  dv_vlc_map[i][j].size = dv_vlc_map[i-1][0].size +
-                                          dv_vlc_map[0][j].size;
+              if (dv_vlc_map_size[i][j] == 0) {
+                  dv_vlc_map_vlc[i][j] = dv_vlc_map_vlc[0][j] |
+                            (dv_vlc_map_vlc[i-1][0] << (dv_vlc_map_size[0][j]));
+                  dv_vlc_map_size[i][j] = dv_vlc_map_size[i-1][0] +
+                                          dv_vlc_map_size[0][j];
               }
            }
 #else
-           for (j = 1; j < DV_VLC_MAP_LEV_SIZE/2; j++) {
-              if (dv_vlc_map[i][j].size == 0) {
-                  dv_vlc_map[i][j].vlc = dv_vlc_map[0][j].vlc |
-                            (dv_vlc_map[i-1][0].vlc << (dv_vlc_map[0][j].size));
-                  dv_vlc_map[i][j].size = dv_vlc_map[i-1][0].size +
-                                          dv_vlc_map[0][j].size;
+           for (j = 1; j < DV_VLC_MAP_LEV_SIZE; j++) {
+              if (dv_vlc_map_size[i][j] == 0) {
+                  dv_vlc_map_vlc[i][j] = dv_vlc_map_vlc[0][j] |
+                            (dv_vlc_map_vlc[i-1][0] << (dv_vlc_map_size[0][j]));
+                  dv_vlc_map_size[i][j] = dv_vlc_map_size[i-1][0] +
+                                          dv_vlc_map_size[0][j];
               }
-              dv_vlc_map[i][((uint16_t)(-j))&0x1ff].vlc =
-                                            dv_vlc_map[i][j].vlc | 1;
-              dv_vlc_map[i][((uint16_t)(-j))&0x1ff].size =
-                                            dv_vlc_map[i][j].size;
+	      /*
+              dv_vlc_map_vlc[i][((uint16_t)(-j))&0x1ff] =
+                                            dv_vlc_map_vlc[i][j] | 1;
+              dv_vlc_map_size[i][((uint16_t)(-j))&0x1ff] =
+                                            dv_vlc_map_size[i][j];
+	      */
            }
 #endif
         }
@@ -369,29 +219,30 @@
 
     /* Generic DSP setup */
     dsputil_init(&dsp, avctx);
-    ff_set_cmp(&dsp, dsp.ildct_cmp, avctx->ildct_cmp);
     s->get_pixels = dsp.get_pixels;
-    s->ildct_cmp = dsp.ildct_cmp[5];
 
     /* 88DCT setup */
-    s->fdct[0]     = dsp.fdct;
+    s->fdct[0] = dsp.fdct;
     s->idct_put[0] = dsp.idct_put;
-    for (i = 0; i < 64; i++)
+    for (i=0; i<64; i++)
        s->dv_zigzag[0][i] = dsp.idct_permutation[ff_zigzag_direct[i]];
 
     /* 248DCT setup */
-    s->fdct[1]     = dsp.fdct248;
+    s->fdct[1] = dsp.fdct248;
     s->idct_put[1] = ff_simple_idct248_put;  // FIXME: need to add it to DSP
-    if (avctx->lowres){
-        for (i = 0; i < 64; i++){
-            int j = ff_zigzag248_direct[i];
-            s->dv_zigzag[1][i] = dsp.idct_permutation[(j & 7) + (j & 8) * 4 + (j & 48) / 2];
+    if(avctx->lowres){
+        for (i=0; i<64; i++){
+            int j= ff_zigzag248_direct[i];
+            s->dv_zigzag[1][i] = dsp.idct_permutation[(j&7) + (j&8)*4 + (j&48)/2];
         }
     }else
         memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);
 
+    /* XXX: do it only for constant case */
+    dv_build_unquantize_tables(s, dsp.idct_permutation);
+
     avctx->coded_frame = &s->picture;
-    s->avctx = avctx;
+    s->avctx= avctx;
 
     return 0;
 }
@@ -400,17 +251,17 @@
 // #define printf(...) av_log(NULL, AV_LOG_ERROR, __VA_ARGS__)
 
 typedef struct BlockInfo {
-    const uint32_t *factor_table;
+    const uint8_t *shift_table;
     const uint8_t *scan_table;
+    const int *iweight_table;
     uint8_t pos; /* position in block */
-    void (*idct_put)(uint8_t *dest, int line_size, DCTELEM *block);
+    uint8_t dct_mode;
     uint8_t partial_bit_count;
     uint16_t partial_bit_buffer;
     int shift_offset;
+    int qstep; /* DV100 only */
 } BlockInfo;
 
-/* bit budget for AC only in 5 MBs */
-static const int vs_total_ac_bits = (100 * 4 + 68*2) * 5;
 /* see dv_88_areas and dv_248_areas for details */
 static const int mb_area_start[5] = { 1, 6, 21, 43, 64 };
 
@@ -424,15 +275,16 @@
     return (s->buf_end - s->buf) * 8 - put_bits_count(s);
 }
 
-/* decode ac coefficients */
-static void dv_decode_ac(GetBitContext *gb, BlockInfo *mb, DCTELEM *block)
+/* decode ac coefs */
+static void dv_decode_ac(DVVideoContext *s, GetBitContext *gb, BlockInfo *mb, DCTELEM *block)
 {
     int last_index = gb->size_in_bits;
-    const uint8_t  *scan_table   = mb->scan_table;
-    const uint32_t *factor_table = mb->factor_table;
-    int pos               = mb->pos;
+    const uint8_t *scan_table = mb->scan_table;
+    const uint8_t *shift_table = mb->shift_table;
+    const int *iweight_table = mb->iweight_table;
+    int pos = mb->pos;
     int partial_bit_count = mb->partial_bit_count;
-    int level, run, vlc_len, index;
+    int level, pos1, run, vlc_len, index;
 
     OPEN_READER(re, gb);
     UPDATE_CACHE(re, gb);
@@ -440,25 +292,25 @@
     /* if we must parse a partial vlc, we do it here */
     if (partial_bit_count > 0) {
         re_cache = ((unsigned)re_cache >> partial_bit_count) |
-                   (mb->partial_bit_buffer << (sizeof(re_cache) * 8 - partial_bit_count));
+                   (mb->partial_bit_buffer << (sizeof(re_cache)*8 - partial_bit_count));
         re_index -= partial_bit_count;
         mb->partial_bit_count = 0;
     }
 
     /* get the AC coefficients until last_index is reached */
-    for (;;) {
+    for(;;) {
 #ifdef VLC_DEBUG
         printf("%2d: bits=%04x index=%d\n", pos, SHOW_UBITS(re, gb, 16), re_index);
 #endif
         /* our own optimized GET_RL_VLC */
-        index   = NEG_USR32(re_cache, TEX_VLC_BITS);
+        index = NEG_USR32(re_cache, TEX_VLC_BITS);
         vlc_len = dv_rl_vlc[index].len;
         if (vlc_len < 0) {
             index = NEG_USR32((unsigned)re_cache << TEX_VLC_BITS, -vlc_len) + dv_rl_vlc[index].level;
             vlc_len = TEX_VLC_BITS - vlc_len;
         }
         level = dv_rl_vlc[index].level;
-        run   = dv_rl_vlc[index].run;
+        run = dv_rl_vlc[index].run;
 
         /* gotta check if we're still within gb boundaries */
         if (re_index + vlc_len > last_index) {
@@ -477,8 +329,18 @@
         if (pos >= 64)
             break;
 
-        level = (level * factor_table[pos] + (1 << (dv_iweight_bits - 1))) >> dv_iweight_bits;
-        block[scan_table[pos]] = level;
+        pos1 = scan_table[pos];
+
+	/* unweigh, round, and shift down */
+	if (DV_PROFILE_IS_HD(s->sys)) {
+	    level *= mb->qstep;
+	    level = (level*iweight_table[pos]) >> 5;
+	} else {
+	    level <<= shift_table[pos1];
+	    level = (level*iweight_table[pos] + (1 << (dv_iweight_bits-1))) >> dv_iweight_bits;
+	}
+
+        block[pos1] = level;
 
         UPDATE_CACHE(re, gb);
     }
@@ -498,28 +360,83 @@
     }
 }
 
-static inline void dv_calculate_mb_xy(DVVideoContext *s, DVwork_chunk *work_chunk, int m, int *mb_x, int *mb_y)
+/* interleave scanlines from even- and odd-numbered blocks */
+static void dv100_interleave(DVVideoContext *s, int mb_x, int mb_y, uint8_t *y_ptr, int c_offset)
 {
-     *mb_x = work_chunk->mb_coordinates[m] & 0xff;
-     *mb_y = work_chunk->mb_coordinates[m] >> 8;
-
-     /* We work with 720p frames split in half. The odd half-frame (chan==2,3) is displaced :-( */
-     if (s->sys->height == 720 && !(s->buf[1]&0x0C)) {
-         *mb_y -= (*mb_y>17)?18:-72; /* shifting the Y coordinate down by 72/2 macro blocks */
-     }
+    int i;
+    for (i = 0; i < 4; i++) {
+	uint8_t *p0, *p1; /* pointer to first scanline of the two adjacent blocks */
+	int stride; /* offset between successive scanlines */
+
+	/* duplicated code */
+	if (i < 2) {  /* DCT0/DCT2, DCT1/DCT3 */
+	    if (s->sys->height == 1080 && mb_y == 134) {
+		/* bottom edge: horizontal row of 4 blocks */
+		p0 = y_ptr + ((i+0)<<3);
+		p1 = y_ptr + ((i+2)<<3);
+	    } else {
+		p0 = y_ptr + ((((i+0) & 1) + ((i+0) >> 1) * s->picture.linesize[0])<<3);
+		p1 = y_ptr + ((((i+2) & 1) + ((i+2) >> 1) * s->picture.linesize[0])<<3);
+	    }
+	    stride = s->picture.linesize[0];
+	} else { /* DCT4/DCT5, DCT6/DCT7 */
+	    int j = i<<1;
+	    int chan = 2 - ((j-4)>>1);
+	    if (s->sys->height == 1080 && mb_y == 134) {
+		/* bottom edge: horizontal row of 2 blocks */
+		p0 = s->picture.data[chan] + c_offset + (((j+0)&1)<<3);
+		p1 = s->picture.data[chan] + c_offset + (((j+1)&1)<<3);
+	    } else {
+		p0 = s->picture.data[chan] + c_offset + ((((j+0) & 1) * s->picture.linesize[chan])<<3);
+		p1 = s->picture.data[chan] + c_offset + ((((j+1) & 1) * s->picture.linesize[chan])<<3);
+	    }
+	    stride = s->picture.linesize[chan];
+	}
+
+	/* GCC turns these small fixed-size memcpy()s into efficient mov sequences */
+#define SET(a,b) memcpy(a, b, 8);
+	{
+	    uint8_t temp[7][8];
+
+	    SET(temp[0],     p0+1*stride);
+	    SET(temp[1],     p0+2*stride);
+	    SET(temp[2],     p0+3*stride);
+	    SET(temp[3],     p0+4*stride);
+	    SET(temp[4],     p0+5*stride);
+	    SET(temp[5],     p0+6*stride);
+	    SET(temp[6],     p0+7*stride);
+
+	    SET(p0+1*stride, p1+0*stride);
+	    SET(p0+2*stride, temp[0]);
+	    SET(p0+3*stride, p1+1*stride);
+	    SET(p0+4*stride, temp[1]);
+	    SET(p0+5*stride, p1+2*stride);
+	    SET(p0+6*stride, temp[2]);
+	    SET(p0+7*stride, p1+3*stride);
+
+	    SET(p1+0*stride, temp[3]);
+	    SET(p1+1*stride, p1+4*stride);
+	    SET(p1+2*stride, temp[4]);
+	    SET(p1+3*stride, p1+5*stride);
+	    SET(p1+4*stride, temp[5]);
+	    SET(p1+5*stride, p1+6*stride);
+	    SET(p1+6*stride, temp[6]);
+	}
+#undef SET
+    }
 }
 
 /* mb_x and mb_y are in units of 8 pixels */
-static int dv_decode_video_segment(AVCodecContext *avctx, void *arg)
+static inline void dv_decode_video_segment(DVVideoContext *s,
+                                           const uint8_t *buf_ptr1,
+                                           const int mb_pos_ptr[10])
 {
-    DVVideoContext *s = avctx->priv_data;
-    DVwork_chunk *work_chunk = arg;
     int quant, dc, dct_mode, class1, j;
     int mb_index, mb_x, mb_y, last_index;
-    int y_stride, linesize;
     DCTELEM *block, *block1;
     int c_offset;
     uint8_t *y_ptr;
+    void (*idct_put)(uint8_t *dest, int line_size, DCTELEM *block);
     const uint8_t *buf_ptr;
     PutBitContext pb, vs_pb;
     GetBitContext gb;
@@ -527,59 +444,75 @@
     DECLARE_ALIGNED_16(DCTELEM, sblock[5*DV_MAX_BPM][64]);
     DECLARE_ALIGNED_8(uint8_t, mb_bit_buffer[80 + 4]); /* allow some slack */
     DECLARE_ALIGNED_8(uint8_t, vs_bit_buffer[5 * 80 + 4]); /* allow some slack */
-    const int log2_blocksize = 3-s->avctx->lowres;
-    int is_field_mode[5];
+    const int log2_blocksize= 3-s->avctx->lowres;
+    int dv100_dct_mode[5]; /* dct_mode is per-macroblock in DV100, not per-block */
 
-    assert((((int)mb_bit_buffer) & 7) == 0);
-    assert((((int)vs_bit_buffer) & 7) == 0);
+    assert((((long)mb_bit_buffer)&7)==0);
+    assert((((long)vs_bit_buffer)&7)==0);
 
     memset(sblock, 0, sizeof(sblock));
 
     /* pass 1 : read DC and AC coefficients in blocks */
-    buf_ptr = &s->buf[work_chunk->buf_offset*80];
-    block1  = &sblock[0][0];
-    mb1     = mb_data;
+    buf_ptr = buf_ptr1;
+    block1 = &sblock[0][0];
+    mb1 = mb_data;
     init_put_bits(&vs_pb, vs_bit_buffer, 5 * 80);
-    for (mb_index = 0; mb_index < 5; mb_index++, mb1 += s->sys->bpm, block1 += s->sys->bpm * 64) {
+    for(mb_index = 0; mb_index < 5; mb_index++, mb1 += s->sys->bpm, block1 += s->sys->bpm * 64) {
         /* skip header */
         quant = buf_ptr[3] & 0x0f;
         buf_ptr += 4;
         init_put_bits(&pb, mb_bit_buffer, 80);
-        mb    = mb1;
+        mb = mb1;
         block = block1;
-        is_field_mode[mb_index] = 0;
-        for (j = 0; j < s->sys->bpm; j++) {
+        for(j = 0;j < s->sys->bpm; j++) {
             last_index = s->sys->block_sizes[j];
             init_get_bits(&gb, buf_ptr, last_index);
 
             /* get the dc */
-            dc       = get_sbits(&gb, 9);
+            dc = get_sbits(&gb, 9);
             dct_mode = get_bits1(&gb);
-            class1   = get_bits(&gb, 2);
-            if (DV_PROFILE_IS_HD(s->sys)) {
-                mb->idct_put     = s->idct_put[0];
-                mb->scan_table   = s->dv_zigzag[0];
-                mb->factor_table = &s->sys->idct_factor[(j >= 4)*4*16*64 + class1*16*64 + quant*64];
-                is_field_mode[mb_index] |= !j && dct_mode;
-            } else {
-                mb->idct_put     = s->idct_put[dct_mode && log2_blocksize == 3];
-                mb->scan_table   = s->dv_zigzag[dct_mode];
-                mb->factor_table = &s->sys->idct_factor[(class1 == 3)*2*22*64 + dct_mode*22*64 +
-                                                        (quant + dv_quant_offset[class1])*64];
-            }
+            class1 = get_bits(&gb, 2);
+
+	    if (DV_PROFILE_IS_HD(s->sys)) {
+		if (j == 0) {
+                    /* macroblock Y location */
+                    int mb_y = mb_pos_ptr[2*mb_index+1];
+                    /* force non-field mode for 4x1 "bottom macro blocks" */
+                    if(mb_y == 134) {
+                        dv100_dct_mode[mb_index] = 0;
+                    } else {
+                        dv100_dct_mode[mb_index] = dct_mode;
+                    }
+                }
+		/* DV100 does not use the 2-4-8 DCT */
+		mb->dct_mode = 0;
+		if (s->sys->height == 1080) {
+		    mb->iweight_table = (j < 4) ? dv_iweight_1080_y : dv_iweight_1080_c;
+		} else { /* 720p */
+		    mb->iweight_table = (j < 4) ? dv_iweight_720_y : dv_iweight_720_c;
+		}
+		mb->qstep = dv100_qstep[quant] << class1;
+	    } else {
+		mb->dct_mode = dct_mode;
+		mb->iweight_table = dct_mode ? dv_iweight_248 : dv_iweight_88;
+		mb->shift_table = s->dv_idct_shift[class1 == 3][dct_mode]
+		    [quant + dv_quant_offset[class1]];
+	    }
+            mb->scan_table = s->dv_zigzag[mb->dct_mode];
+
             dc = dc << 2;
             /* convert to unsigned because 128 is not added in the
                standard IDCT */
             dc += 1024;
             block[0] = dc;
             buf_ptr += last_index >> 3;
-            mb->pos               = 0;
+            mb->pos = 0;
             mb->partial_bit_count = 0;
 
 #ifdef VLC_DEBUG
             printf("MB block: %d, %d ", mb_index, j);
 #endif
-            dv_decode_ac(&gb, mb, block);
+            dv_decode_ac(s, &gb, mb, block);
 
             /* write the remaining bits  in a new buffer only if the
                block is finished */
@@ -595,12 +528,12 @@
         printf("***pass 2 size=%d MB#=%d\n", put_bits_count(&pb), mb_index);
 #endif
         block = block1;
-        mb    = mb1;
+        mb = mb1;
         init_get_bits(&gb, mb_bit_buffer, put_bits_count(&pb));
         flush_put_bits(&pb);
-        for (j = 0; j < s->sys->bpm; j++, block += 64, mb++) {
+        for(j = 0;j < s->sys->bpm; j++, block += 64, mb++) {
             if (mb->pos < 64 && get_bits_left(&gb) > 0) {
-                dv_decode_ac(&gb, mb, block);
+                dv_decode_ac(s, &gb, mb, block);
                 /* if still not finished, no need to parse other blocks */
                 if (mb->pos < 64)
                     break;
@@ -617,16 +550,16 @@
     printf("***pass 3 size=%d\n", put_bits_count(&vs_pb));
 #endif
     block = &sblock[0][0];
-    mb    = mb_data;
+    mb = mb_data;
     init_get_bits(&gb, vs_bit_buffer, put_bits_count(&vs_pb));
     flush_put_bits(&vs_pb);
-    for (mb_index = 0; mb_index < 5; mb_index++) {
-        for (j = 0; j < s->sys->bpm; j++) {
+    for(mb_index = 0; mb_index < 5; mb_index++) {
+        for(j = 0;j < s->sys->bpm; j++) {
             if (mb->pos < 64) {
 #ifdef VLC_DEBUG
                 printf("start %d:%d\n", mb_index, j);
 #endif
-                dv_decode_ac(&gb, mb, block);
+                dv_decode_ac(s, &gb, mb, block);
             }
             if (mb->pos >= 64 && mb->pos < 127)
                 av_log(NULL, AV_LOG_ERROR, "AC EOB marker is absent pos=%d\n", mb->pos);
@@ -637,63 +570,96 @@
 
     /* compute idct and place blocks */
     block = &sblock[0][0];
-    mb    = mb_data;
-    for (mb_index = 0; mb_index < 5; mb_index++) {
-        dv_calculate_mb_xy(s, work_chunk, mb_index, &mb_x, &mb_y);
-
-        /* idct_put'ting luminance */
-        if ((s->sys->pix_fmt == PIX_FMT_YUV420P) ||
-            (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8)) ||
-            (s->sys->height >= 720 && mb_y != 134)) {
-            y_stride = (s->picture.linesize[0] << ((!is_field_mode[mb_index]) * log2_blocksize));
-        } else {
-            y_stride = (2 << log2_blocksize);
-        }
-        y_ptr = s->picture.data[0] + ((mb_y * s->picture.linesize[0] + mb_x) << log2_blocksize);
-        linesize = s->picture.linesize[0] << is_field_mode[mb_index];
-        mb[0]    .idct_put(y_ptr                                   , linesize, block + 0*64);
-        if (s->sys->video_stype == 4) { /* SD 422 */
-            mb[2].idct_put(y_ptr + (1 << log2_blocksize)           , linesize, block + 2*64);
-        } else {
-            mb[1].idct_put(y_ptr + (1 << log2_blocksize)           , linesize, block + 1*64);
-            mb[2].idct_put(y_ptr                         + y_stride, linesize, block + 2*64);
-            mb[3].idct_put(y_ptr + (1 << log2_blocksize) + y_stride, linesize, block + 3*64);
-        }
-        mb += 4;
-        block += 4*64;
-
-        /* idct_put'ting chrominance */
-        c_offset = (((mb_y >>  (s->sys->pix_fmt == PIX_FMT_YUV420P)) * s->picture.linesize[1] +
-                     (mb_x >> ((s->sys->pix_fmt == PIX_FMT_YUV411P) ? 2 : 1))) << log2_blocksize);
-        for (j = 2; j; j--) {
-            uint8_t *c_ptr = s->picture.data[j] + c_offset;
-            if (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8)) {
-                  uint64_t aligned_pixels[64/8];
-                  uint8_t *pixels = (uint8_t*)aligned_pixels;
-                  uint8_t *c_ptr1, *ptr1;
-                  int x, y;
-                  mb->idct_put(pixels, 8, block);
-                  for (y = 0; y < (1 << log2_blocksize); y++, c_ptr += s->picture.linesize[j], pixels += 8) {
-                      ptr1   = pixels + (1 << (log2_blocksize - 1));
-                      c_ptr1 = c_ptr + (s->picture.linesize[j] << log2_blocksize);
-                      for (x = 0; x < (1 << (log2_blocksize - 1)); x++) {
-                          c_ptr[x]  = pixels[x];
-                          c_ptr1[x] = ptr1[x];
-                      }
-                  }
-                  block += 64; mb++;
-            } else {
-                  y_stride = (mb_y == 134) ? (1 << log2_blocksize) :
-                                             s->picture.linesize[j] << ((!is_field_mode[mb_index]) * log2_blocksize);
-                  linesize = s->picture.linesize[j] << is_field_mode[mb_index];
-                  (mb++)->    idct_put(c_ptr           , linesize, block); block += 64;
-                  if (s->sys->bpm == 8) {
-                      (mb++)->idct_put(c_ptr + y_stride, linesize, block); block += 64;
-                  }
+    mb = mb_data;
+    for(mb_index = 0; mb_index < 5; mb_index++) {
+	mb_x = *mb_pos_ptr++;
+        mb_y = *mb_pos_ptr++;
+        if (s->sys->pix_fmt == PIX_FMT_YUV422P) { /* 4:2:2 */
+            y_ptr = s->picture.data[0] + ((mb_y * s->picture.linesize[0] + (mb_x>>1))<<log2_blocksize);
+            c_offset = ((mb_y * s->picture.linesize[1] + (mb_x >> 2))<<log2_blocksize);
+        } else { /* 4:1:1 or 4:2:0 */
+            y_ptr = s->picture.data[0] + ((mb_y * s->picture.linesize[0] + mb_x)<<log2_blocksize);
+            if (s->sys->pix_fmt == PIX_FMT_YUV411P)
+                c_offset = ((mb_y * s->picture.linesize[1] + (mb_x >> 2))<<log2_blocksize);
+            else /* 4:2:0 */
+                c_offset = (((mb_y >> 1) * s->picture.linesize[1] + (mb_x >> 1))<<log2_blocksize);
+        }
+        for(j = 0;j < s->sys->bpm; j++) {
+            idct_put = s->idct_put[mb->dct_mode && log2_blocksize==3];
+	    if (DV_PROFILE_IS_HD(s->sys)) { /* HD 4:2:2 */
+		if (j < 4) {  /* Four Y blocks */
+		    /* NOTE: at bottom of image in 1080i50/60, the macroblock is handled as 411 */
+                    if (s->sys->height == 1080 && mb_y == 134) {
+			idct_put(y_ptr + (j<<log2_blocksize), s->picture.linesize[0], block);
+                    } else {
+			idct_put(y_ptr + (((j & 1) + (j >> 1) * s->picture.linesize[0])<<log2_blocksize),
+                                 s->picture.linesize[0], block);
+                    }
+                } else {      /* Cr and Cb blocks */
+		    int chan = 2 - ((j-4)>>1);
+		    if (s->sys->height == 1080 && mb_y == 134) {
+			/* bottom edge: horizontal row of 2 blocks */
+			idct_put(s->picture.data[chan] + c_offset + ((j&1)<<log2_blocksize),
+				 s->picture.linesize[chan], block);
+		    } else {
+			idct_put(s->picture.data[chan] + c_offset + (((j & 1) * s->picture.linesize[chan])<<log2_blocksize),
+                                 s->picture.linesize[chan], block);
+		    }
+		}
+	    } else if (s->sys->pix_fmt == PIX_FMT_YUV422P) { /* SD 4:2:2 */
+                if (j == 0 || j == 2) {
+                    /* Y0 Y1 */
+                    idct_put(y_ptr + ((j >> 1)<<log2_blocksize),
+                             s->picture.linesize[0], block);
+                } else if(j > 3) {
+                    /* Cr Cb */
+                    idct_put(s->picture.data[6 - j] + c_offset,
+                             s->picture.linesize[6 - j], block);
+                }
+                /* note: j=1 and j=3 are "dummy" blocks in SD 4:2:2 */
+            } else { /* 4:1:1 or 4:2:0 */
+                if (j < 4) {
+                    if (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x < (704 / 8)) {
+                        /* NOTE: at end of line, the macroblock is handled as 420 */
+                        idct_put(y_ptr + (j<<log2_blocksize), s->picture.linesize[0], block);
+                    } else {
+                        idct_put(y_ptr + (((j & 1) + (j >> 1) * s->picture.linesize[0])<<log2_blocksize),
+                                 s->picture.linesize[0], block);
+                    }
+                } else {
+                    if (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8)) {
+                        uint64_t aligned_pixels[64/8];
+                        uint8_t *pixels= (uint8_t*)aligned_pixels;
+                        uint8_t *c_ptr, *c_ptr1, *ptr, *ptr1;
+                        int x, y, linesize;
+                        /* NOTE: at end of line, the macroblock is handled as 420 */
+                        idct_put(pixels, 8, block);
+                        linesize = s->picture.linesize[6 - j];
+                        c_ptr = s->picture.data[6 - j] + c_offset;
+                        ptr = pixels;
+                        for(y = 0;y < (1<<log2_blocksize); y++) {
+                            ptr1= ptr + (1<<(log2_blocksize-1));
+                            c_ptr1 = c_ptr + (linesize<<log2_blocksize);
+                            for(x=0; x < (1<<(log2_blocksize-1)); x++){
+                                c_ptr[x]= ptr[x]; c_ptr1[x]= ptr1[x];
+                            }
+                            c_ptr += linesize;
+                            ptr += 8;
+                        }
+                    } else {
+                        /* don't ask me why they inverted Cb and Cr ! */
+                        idct_put(s->picture.data[6 - j] + c_offset,
+                                 s->picture.linesize[6 - j], block);
+                    }
+                }
             }
+            block += 64;
+            mb++;
         }
+	if (DV_PROFILE_IS_HD(s->sys) && dv100_dct_mode[mb_index]) {
+		dv100_interleave(s, mb_x, mb_y, y_ptr, c_offset);
+	}
     }
-    return 0;
 }
 
 #if CONFIG_SMALL
@@ -702,21 +668,21 @@
 {
     int size;
     if (run < DV_VLC_MAP_RUN_SIZE && level < DV_VLC_MAP_LEV_SIZE) {
-        *vlc = dv_vlc_map[run][level].vlc | sign;
-        size = dv_vlc_map[run][level].size;
+        *vlc = dv_vlc_map_vlc[run][level] | sign;
+        size = dv_vlc_map_size[run][level];
     }
     else {
         if (level < DV_VLC_MAP_LEV_SIZE) {
-            *vlc = dv_vlc_map[0][level].vlc | sign;
-            size = dv_vlc_map[0][level].size;
+            *vlc = dv_vlc_map_vlc[0][level] | sign;
+            size = dv_vlc_map_size[0][level];
         } else {
             *vlc = 0xfe00 | (level << 1) | sign;
             size = 16;
         }
         if (run) {
-            *vlc |= ((run < 16) ? dv_vlc_map[run-1][0].vlc :
+            *vlc |= ((run < 16) ? dv_vlc_map_vlc[run-1][0] :
                                   (0x1f80 | (run - 1))) << size;
-            size +=  (run < 16) ? dv_vlc_map[run-1][0].size : 13;
+            size += (run < 16) ? dv_vlc_map_size[run-1][0] : 13;
         }
     }
 
@@ -728,12 +694,12 @@
     int size;
 
     if (run < DV_VLC_MAP_RUN_SIZE && level < DV_VLC_MAP_LEV_SIZE) {
-        size = dv_vlc_map[run][level].size;
+        size = dv_vlc_map_size[run][level];
     }
     else {
-        size = (level < DV_VLC_MAP_LEV_SIZE) ? dv_vlc_map[0][level].size : 16;
+        size = (level < DV_VLC_MAP_LEV_SIZE) ? dv_vlc_map_size[0][level] : 16;
         if (run) {
-            size += (run < 16) ? dv_vlc_map[run-1][0].size : 13;
+            size += (run < 16) ? dv_vlc_map_size[run-1][0] : 13;
         }
     }
     return size;
@@ -741,50 +707,55 @@
 #else
 static av_always_inline int dv_rl2vlc(int run, int l, int sign, uint32_t* vlc)
 {
-    *vlc = dv_vlc_map[run][l].vlc | sign;
-    return dv_vlc_map[run][l].size;
+    *vlc = dv_vlc_map_vlc[run][l] | sign;
+    return dv_vlc_map_size[run][l];
 }
 
 static av_always_inline int dv_rl2vlc_size(int run, int l)
 {
-    return dv_vlc_map[run][l].size;
+    return dv_vlc_map_size[run][l];
 }
 #endif
 
 typedef struct EncBlockInfo {
-    int      area_q[4];
-    int      bit_size[4];
-    int      prev[5];
-    int      cur_ac;
-    int      cno;
-    int      dct_mode;
-    DCTELEM  mb[64];
-    uint8_t  next[64];
-    uint8_t  sign[64];
-    uint8_t  partial_bit_count;
+    int area_q[4];
+    int bit_size[4];
+    int prev[5]; /* first nonzero component before each area start (not used in DV100) */
+    int cur_ac;
+    int cno;
+    int min_qlevel; /* DV100 only: minimum qlevel (for AC coefficients >255) */
+    int dct_mode;
+    DCTELEM mb[64];
+    /* used by DV100 only: a copy of the weighted and classified but
+       not-yet-quantized AC coefficients.  this is necessary for
+       re-quantizing at different steps. */
+    DCTELEM save[64];
+    uint8_t next[64];
+    uint8_t sign[64];
+    uint8_t partial_bit_count;
     uint32_t partial_bit_buffer; /* we can't use uint16_t here */
 } EncBlockInfo;
 
-static av_always_inline PutBitContext* dv_encode_ac(EncBlockInfo* bi,
-                                                    PutBitContext* pb_pool,
-                                                    PutBitContext* pb_end)
+static av_always_inline PutBitContext* dv_encode_ac(EncBlockInfo* bi, PutBitContext* pb_pool,
+                                       PutBitContext* pb_end)
 {
-    int prev, bits_left;
+    int prev;
+    int bits_left;
     PutBitContext* pb = pb_pool;
     int size = bi->partial_bit_count;
     uint32_t vlc = bi->partial_bit_buffer;
 
     bi->partial_bit_count = bi->partial_bit_buffer = 0;
-    for (;;){
+    for(;;){
        /* Find suitable storage space */
        for (; size > (bits_left = put_bits_left(pb)); pb++) {
           if (bits_left) {
               size -= bits_left;
               put_bits(pb, bits_left, vlc >> size);
-              vlc = vlc & ((1 << size) - 1);
+              vlc = vlc & ((1<<size)-1);
           }
           if (pb + 1 >= pb_end) {
-              bi->partial_bit_count  = size;
+              bi->partial_bit_count = size;
               bi->partial_bit_buffer = vlc;
               return pb;
           }
@@ -793,13 +764,13 @@
        /* Store VLC */
        put_bits(pb, size, vlc);
 
-       if (bi->cur_ac >= 64)
+       if(bi->cur_ac>=64)
            break;
 
        /* Construct the next VLC */
-       prev       = bi->cur_ac;
+       prev= bi->cur_ac;
        bi->cur_ac = bi->next[prev];
-       if (bi->cur_ac < 64){
+       if(bi->cur_ac < 64){
            size = dv_rl2vlc(bi->cur_ac - prev - 1, bi->mb[bi->cur_ac], bi->sign[bi->cur_ac], &vlc);
        } else {
            size = 4; vlc = 6; /* End Of Block stamp */
@@ -808,30 +779,15 @@
     return pb;
 }
 
-static av_always_inline int dv_guess_dct_mode(DVVideoContext *s, uint8_t *data, int linesize) {
-    if (s->avctx->flags & CODEC_FLAG_INTERLACED_DCT) {
-        int ps = s->ildct_cmp(NULL, data, NULL, linesize, 8) - 400;
-        if (ps > 0) {
-            int is = s->ildct_cmp(NULL, data           , NULL, linesize<<1, 4) +
-                     s->ildct_cmp(NULL, data + linesize, NULL, linesize<<1, 4);
-            return (ps > is);
-        }
-    }
-
-    return 0;
-}
-
-static av_always_inline int dv_init_enc_block(EncBlockInfo* bi, uint8_t *data, int linesize, DVVideoContext *s, int bias)
+static inline void dv_set_class_number_sd(DCTELEM* blk, EncBlockInfo* bi,
+					  const uint8_t* zigzag_scan, const int *weight, int bias)
 {
-    const int *weight;
-    const uint8_t* zigzag_scan;
-    DECLARE_ALIGNED_16(DCTELEM, blk[64]);
     int i, area;
     /* We offer two different methods for class number assignment: the
        method suggested in SMPTE 314M Table 22, and an improved
        method. The SMPTE method is very conservative; it assigns class
        3 (i.e. severe quantization) to any block where the largest AC
-       component is greater than 36. FFmpeg's DV encoder tracks AC bit
+       component is greater than 36. ffmpeg's DV encoder tracks AC bit
        consumption precisely, so there is no need to bias most blocks
        towards strongly lossy compression. Instead, we assign class 2
        to most blocks, and use class 3 only when strictly necessary
@@ -839,118 +795,249 @@
 
 #if 0 /* SMPTE spec method */
     static const int classes[] = {12, 24, 36, 0xffff};
-#else /* improved FFmpeg method */
+#else /* improved ffmpeg method */
     static const int classes[] = {-1, -1, 255, 0xffff};
 #endif
-    int max  = classes[0];
-    int prev = 0;
+    int max=classes[0];
+    int prev=0;
 
-    assert((((int)blk) & 15) == 0);
-
-    bi->area_q[0] = bi->area_q[1] = bi->area_q[2] = bi->area_q[3] = 0;
-    bi->partial_bit_count = 0;
-    bi->partial_bit_buffer = 0;
-    bi->cur_ac = 0;
-    if (data) {
-        bi->dct_mode = dv_guess_dct_mode(s, data, linesize);
-        s->get_pixels(blk, data, linesize);
-        s->fdct[bi->dct_mode](blk);
-    } else {
-        /* We rely on the fact that encoding all zeros leads to an immediate EOB,
-           which is precisely what the spec calls for in the "dummy" blocks. */
-        memset(blk, 0, sizeof(blk));
-        bi->dct_mode = 0;
-    }
     bi->mb[0] = blk[0];
 
-    zigzag_scan = bi->dct_mode ? ff_zigzag248_direct : ff_zigzag_direct;
-    weight = bi->dct_mode ? dv_weight_248 : dv_weight_88;
-
     for (area = 0; area < 4; area++) {
-       bi->prev[area]     = prev;
+       bi->prev[area] = prev;
        bi->bit_size[area] = 1; // 4 areas 4 bits for EOB :)
-       for (i = mb_area_start[area]; i < mb_area_start[area+1]; i++) {
+       for (i=mb_area_start[area]; i<mb_area_start[area+1]; i++) {
           int level = blk[zigzag_scan[i]];
 
-          if (level + 15 > 30U) {
-              bi->sign[i] = (level >> 31) & 1;
+          if (level+15 > 30U) {
+              bi->sign[i] = (level>>31)&1;
               /* weigh it and and shift down into range, adding for rounding */
               /* the extra division by a factor of 2^4 reverses the 8x expansion of the DCT
                  AND the 2x doubling of the weights */
-              level = (FFABS(level) * weight[i] + (1 << (dv_weight_bits+3))) >> (dv_weight_bits+4);
+              level = (FFABS(level) * weight[i] + (1<<(dv_weight_bits+3))) >> (dv_weight_bits+4);
               bi->mb[i] = level;
-              if (level > max)
-                  max = level;
+              if(level>max) max= level;
               bi->bit_size[area] += dv_rl2vlc_size(i - prev  - 1, level);
               bi->next[prev]= i;
-              prev = i;
+              prev= i;
           }
        }
     }
     bi->next[prev]= i;
-    for (bi->cno = 0; max > classes[bi->cno]; bi->cno++);
+    for(bi->cno = 0; max > classes[bi->cno]; bi->cno++);
 
     bi->cno += bias;
 
     if (bi->cno >= 3) {
         bi->cno = 3;
-        prev    = 0;
-        i       = bi->next[prev];
+        prev=0;
+        i= bi->next[prev];
         for (area = 0; area < 4; area++) {
-            bi->prev[area]     = prev;
+            bi->prev[area] = prev;
             bi->bit_size[area] = 1; // 4 areas 4 bits for EOB :)
-            for (; i < mb_area_start[area+1]; i = bi->next[i]) {
-                bi->mb[i] >>= 1;
+            for (; i<mb_area_start[area+1]; i= bi->next[i]) {
+                bi->mb[i] >>=1;
 
                 if (bi->mb[i]) {
                     bi->bit_size[area] += dv_rl2vlc_size(i - prev - 1, bi->mb[i]);
                     bi->next[prev]= i;
-                    prev = i;
+                    prev= i;
                 }
             }
         }
         bi->next[prev]= i;
     }
+}
 
-    return bi->bit_size[0] + bi->bit_size[1] + bi->bit_size[2] + bi->bit_size[3];
+/* After quantization, set the class number by looking at the largest
+   AC component. Increase the class number until it fits in 8 bits. */
+static inline void dv100_set_cno(EncBlockInfo *bi, int max, int bias)
+{
+    int prev, i;
+    int delta = 0;
+
+    /* starting cno */
+    bi->cno = bias;
+
+    /* bump the class number up if the maximum AC coefficient is too
+       large for 8 bits */
+    while ((max & ~(0xFF)) && (bi->cno < 3)) {
+	bi->cno++;
+	delta++;
+	max >>= 1;
+    }
+
+    /* if cno stays the same, we are done */
+    if(delta == 0) {
+	return;
+    }
+
+    /* divide AC components by 2^(delta), re-building the run-length table and
+       updating bit_size as we go */
+    bi->bit_size[0] = 4; /* EOB code is 4 bits */
+
+    /* skip through the run-length table, visiting all nonzero components */
+    prev = 0;
+
+    /* visit nonzero components and rescale them */
+    for (i = bi->next[prev]; i < 64; i = bi->next[i]) {
+	bi->mb[i] >>= delta;
+
+	/* clamp to max amplitude */
+	/* (yes, it is possible to hit this even when cno=3!) */
+	if (bi->mb[i] > 255)
+	    bi->mb[i] = 255;
+
+	/* maintain run-length table */
+	if (bi->mb[i]) {
+	    bi->bit_size[0] += dv_rl2vlc_size(i - prev - 1, bi->mb[i]);
+	    prev = i;
+	} else {
+	    bi->next[prev] = bi->next[i];
+	}
+    }
+    /*  mark EOB */
+    bi->next[prev] = i;
+}
+
+/* DV100 quantize
+   Perform quantization by divinding the AC component by the qstep.
+   As an optimization we use a fixed-point integer multiply instead
+   of a divide. */
+static av_always_inline int dv100_quantize(int level, int qsinv)
+{
+    /* this code is equivalent to */
+    /* return (level + qs/2) / qs; */
+
+    return (level * qsinv + 1024 + (1<<(dv100_qstep_bits-1))) >> dv100_qstep_bits;
+
+    /* the extra +1024 is needed to make the rounding come out right. */
+
+    /* I (DJM) have verified that the results are exactly the same as
+       division for level 0-2048 at all QNOs. */
+}
+
+/* this function just copies the DCT coefficients and performs
+   the initial (non-)quantization. */
+static inline void dv_set_class_number_hd(DCTELEM* blk, EncBlockInfo* bi,
+                                          const uint8_t* zigzag_scan, const int *weight, int bias)
+{
+    int i, max = 0;
+
+    /* the first quantization (none at all) */
+    bi->area_q[0] = 1;
+
+    /* LOOP1: weigh AC components and store to save[] */
+    /* (i=0 is the DC component; we only include it to make the
+       number of loop iterations even, for future possible SIMD optimization) */
+    for (i = 0; i < 64; i += 2) {
+	int level0, level1;
+
+	/* get the AC component (in zig-zag order) */
+	level0 = blk[zigzag_scan[i+0]];
+	level1 = blk[zigzag_scan[i+1]];
+
+	/* extract sign and make it the lowest bit */
+	bi->sign[i+0] = (level0>>31)&1;
+	bi->sign[i+1] = (level1>>31)&1;
+
+	/* take absolute value of the level */
+	level0 = FFABS(level0);
+	level1 = FFABS(level1);
+
+	/* weigh it */
+	level0 = (level0*weight[i+0] + 4096 + (1<<17)) >> 18;
+	level1 = (level1*weight[i+1] + 4096 + (1<<17)) >> 18;
+
+	/* save unquantized value */
+	bi->save[i+0] = level0;
+	bi->save[i+1] = level1;
+    }
+
+    /* find max component */
+    for (i = 0; i < 64; i++) {
+        int ac = bi->save[i];
+        if (ac > max)
+            max = ac;
+    }
+
+    /* copy DC component */
+    bi->mb[0] = blk[0];
+
+    /* the EOB code is 4 bits */
+    bi->bit_size[0] = 4;
+    bi->bit_size[1] = bi->bit_size[2] = bi->bit_size[3] = 0;
+
+    /* ensure that no AC coefficients are cut off */
+    bi->min_qlevel = ((max+256) >> 8);
+
+    bi->area_q[0] = 25; /* set to an "impossible" value */
+    bi->cno = 0;
+}
+
+
+//FIXME replace this by dsputil
+#define SC(x, y) ((s[x] - s[y]) ^ ((s[x] - s[y]) >> 7))
+static av_always_inline int dv_guess_dct_mode(DCTELEM *blk) {
+    DCTELEM *s;
+    int score88 = 0;
+    int score248 = 0;
+    int i;
+
+    /* Compute 8-8 score (small values give a better chance for 8-8 DCT) */
+    s = blk;
+    for(i=0; i<7; i++) {
+        score88 += SC(0,  8) + SC(1, 9) + SC(2, 10) + SC(3, 11) +
+                   SC(4, 12) + SC(5,13) + SC(6, 14) + SC(7, 15);
+        s += 8;
+    }
+    /* Compute 2-4-8 score (small values give a better chance for 2-4-8 DCT) */
+    s = blk;
+    for(i=0; i<6; i++) {
+        score248 += SC(0, 16) + SC(1,17) + SC(2, 18) + SC(3, 19) +
+                    SC(4, 20) + SC(5,21) + SC(6, 22) + SC(7, 23);
+        s += 8;
+    }
+
+    return (score88 - score248 > -10);
 }
 
-static inline void dv_guess_qnos(EncBlockInfo* blks, int* qnos)
+static inline void dv_guess_qnos_sd(EncBlockInfo* blks, int* qnos, int vs_total_ac_bits)
 {
     int size[5];
     int i, j, k, a, prev, a2;
     EncBlockInfo* b;
 
-    size[0] = size[1] = size[2] = size[3] = size[4] = 1 << 24;
+    size[0] = size[1] = size[2] = size[3] = size[4] = 1<<24;
     do {
        b = blks;
-       for (i = 0; i < 5; i++) {
+       for (i=0; i<5; i++) {
           if (!qnos[i])
               continue;
 
           qnos[i]--;
           size[i] = 0;
-          for (j = 0; j < 6; j++, b++) {
-             for (a = 0; a < 4; a++) {
+          for (j=0; j<6; j++, b++) {
+             for (a=0; a<4; a++) {
                 if (b->area_q[a] != dv_quant_shifts[qnos[i] + dv_quant_offset[b->cno]][a]) {
                     b->bit_size[a] = 1; // 4 areas 4 bits for EOB :)
                     b->area_q[a]++;
-                    prev = b->prev[a];
+                    prev= b->prev[a];
                     assert(b->next[prev] >= mb_area_start[a+1] || b->mb[prev]);
-                    for (k = b->next[prev] ; k < mb_area_start[a+1]; k = b->next[k]) {
+                    for (k= b->next[prev] ; k<mb_area_start[a+1]; k= b->next[k]) {
                        b->mb[k] >>= 1;
                        if (b->mb[k]) {
                            b->bit_size[a] += dv_rl2vlc_size(k - prev - 1, b->mb[k]);
-                           prev = k;
+                           prev= k;
                        } else {
-                           if (b->next[k] >= mb_area_start[a+1] && b->next[k]<64){
-                                for (a2 = a + 1; b->next[k] >= mb_area_start[a2+1]; a2++)
+                           if(b->next[k] >= mb_area_start[a+1] && b->next[k]<64){
+                                for(a2=a+1; b->next[k] >= mb_area_start[a2+1]; a2++)
                                     b->prev[a2] = prev;
-                                assert(a2 < 4);
+                                assert(a2<4);
                                 assert(b->mb[b->next[k]]);
                                 b->bit_size[a2] += dv_rl2vlc_size(b->next[k] - prev - 1, b->mb[b->next[k]])
                                                   -dv_rl2vlc_size(b->next[k] -    k - 1, b->mb[b->next[k]]);
-                                assert(b->prev[a2] == k && (a2 + 1 >= 4 || b->prev[a2+1] != k));
+                                assert(b->prev[a2]==k && (a2+1 >= 4 || b->prev[a2+1]!=k));
                                 b->prev[a2] = prev;
                            }
                            b->next[prev] = b->next[k];
@@ -961,141 +1048,492 @@
                 size[i] += b->bit_size[a];
              }
           }
-          if (vs_total_ac_bits >= size[0] + size[1] + size[2] + size[3] + size[4])
+          if(vs_total_ac_bits >= size[0] + size[1] + size[2] + size[3] + size[4])
                 return;
        }
     } while (qnos[0]|qnos[1]|qnos[2]|qnos[3]|qnos[4]);
 
 
-    for (a = 2; a == 2 || vs_total_ac_bits < size[0]; a += a){
+    for(a=2; a==2 || vs_total_ac_bits < size[0]; a+=a){
         b = blks;
-        size[0] = 5 * 6 * 4; //EOB
-        for (j = 0; j < 6 *5; j++, b++) {
-            prev = b->prev[0];
-            for (k = b->next[prev]; k < 64; k = b->next[k]) {
-                if (b->mb[k] < a && b->mb[k] > -a){
+        size[0] = 5*6*4; //EOB
+        for (j=0; j<6*5; j++, b++) {
+            prev= b->prev[0];
+            for (k= b->next[prev]; k<64; k= b->next[k]) {
+                if(b->mb[k] < a && b->mb[k] > -a){
                     b->next[prev] = b->next[k];
                 }else{
                     size[0] += dv_rl2vlc_size(k - prev - 1, b->mb[k]);
-                    prev = k;
+                    prev= k;
                 }
             }
         }
     }
 }
 
-static int dv_encode_video_segment(AVCodecContext *avctx, void *arg)
+static int dv100_actual_quantize(EncBlockInfo *b, int qlevel)
+{
+    int prev, k, qsinv;
+
+    int qno = DV100_QLEVEL_QNO(dv100_qlevels[qlevel]);
+    int cno = DV100_QLEVEL_CNO(dv100_qlevels[qlevel]);
+
+    if(b->area_q[0] == qno && b->cno == cno)
+        return b->bit_size[0];
+
+    qsinv = dv100_qstep_inv[qno];
+
+    /* record the new qstep */
+    b->area_q[0] = qno;
+    b->cno = cno;
+
+    /* reset encoded size (EOB = 4 bits) */
+    b->bit_size[0] = 4;
+
+    /* visit nonzero components and quantize */
+    prev = 0;
+    for (k = 1; k < 64; k++) {
+        /* quantize */
+        int ac = dv100_quantize(b->save[k], qsinv) >> cno;
+        if(ac) {
+            if(ac > 255)
+                ac = 255;
+
+            b->mb[k] = ac;
+            b->bit_size[0] += dv_rl2vlc_size(k - prev - 1, ac);
+            b->next[prev] = k;
+            prev = k;
+        }
+    }
+    b->next[prev] = k;
+
+    return b->bit_size[0];
+}
+
+static inline void dv_guess_qnos_hd(EncBlockInfo *blks, int* qnos, int vs_total_ac_bits, int qno_memory[5])
+{
+    EncBlockInfo *b;
+    int min_qlevel[5];
+    int qlevels[5];
+    int size[5];
+    int i, j;
+
+    static const int enable_finer = 1;
+
+    /* cache block sizes at hypothetical qlevels */
+    uint16_t size_cache[5*8][dv100_num_qlevels];
+
+    memset(size_cache, 0, sizeof(size_cache));
+
+    /* get minimum qlevels */
+    for (i = 0; i < 5; i++) {
+        min_qlevel[i] = 1;
+        for (j = 0; j < 8; j++) {
+            if (blks[8*i+j].min_qlevel > min_qlevel[i])
+                min_qlevel[i] = blks[8*i+j].min_qlevel;
+        }
+    }
+
+    /* initialize sizes */
+    for (i = 0; i < 5; i++) {
+        qlevels[i] = qno_memory[i];
+        if (qlevels[i] < min_qlevel[i])
+            qlevels[i] = min_qlevel[i];
+
+        qnos[i] = DV100_QLEVEL_QNO(dv100_qlevels[qlevels[i]]);
+	size[i] = 0;
+	for (j = 0; j < 8; j++) {
+            size_cache[8*i+j][qlevels[i]] = dv100_actual_quantize(&blks[8*i+j], qlevels[i]);
+            size[i] += size_cache[8*i+j][qlevels[i]];
+	}
+    }
+
+    /* must we go coarser? */
+    if((size[0]+size[1]+size[2]+size[3]+size[4]) > vs_total_ac_bits) {
+
+        int largest = (size[0] % 5); /* 'random' number */
+
+        do {
+            /* find the macroblock with the lowest qlevel */
+            for (i = 0; i < 5; i++) {
+                if ((qlevels[i] < (dv100_num_qlevels-1)) &&
+                    (qlevels[i] < qlevels[largest]))
+                    largest = i;
+            }
+
+            i = largest;
+
+            /* ensure that we don't enter infinite loop */
+            largest = (largest+1) % 5;
+
+            if (qlevels[i] >= (dv100_num_qlevels-1)) {
+                /* can't quantize any more */
+                continue;
+            }
+
+            /* quantize a little bit more */
+            qlevels[i] += dv100_qlevel_inc;
+            if (qlevels[i] > (dv100_num_qlevels-1))
+                qlevels[i] = dv100_num_qlevels-1;
+
+            qnos[i] = DV100_QLEVEL_QNO(dv100_qlevels[qlevels[i]]);
+            size[i] = 0;
+
+            /* for each block */
+            b = &blks[8*i];
+            for (j = 0; j < 8; j++, b++) {
+                /* accumulate block size into macroblock */
+                if(size_cache[8*i+j][qlevels[i]] == 0) {
+                    /* it is safe to use actual_quantize() here because we only go from finer to coarser,
+                       and it saves the final actual_quantize() down below */
+                    size_cache[8*i+j][qlevels[i]] = dv100_actual_quantize(b, qlevels[i]);
+                }
+                size[i] += size_cache[8*i+j][qlevels[i]];
+            } /* for each block */
+
+        } while ((vs_total_ac_bits < (size[0] + size[1] + size[2] + size[3] + size[4])) &&
+                 ((qlevels[0] < (dv100_num_qlevels-1)) || (qlevels[1] < (dv100_num_qlevels-1)) || (qlevels[2] < (dv100_num_qlevels-1)) || (qlevels[3] < (dv100_num_qlevels-1)) || (qlevels[4] < (dv100_num_qlevels-1))));
+
+    // can we go finer?
+    } else if(enable_finer &&
+              ((size[0]+size[1]+size[2]+size[3]+size[4]) < vs_total_ac_bits)) {
+
+        int save_qlevel;
+        int largest = (size[0] % 5); /* 'random' number */
+
+        while((qlevels[0] > min_qlevel[0]) ||
+              (qlevels[1] > min_qlevel[1]) ||
+              (qlevels[2] > min_qlevel[2]) ||
+              (qlevels[3] > min_qlevel[3]) ||
+              (qlevels[4] > min_qlevel[4])) {
+
+            /* find the macroblock with the highest qlevel */
+            for (i = 0; i < 5; i++) {
+                if ((qlevels[i] > min_qlevel[i]) && (qlevels[i] > qlevels[largest]))
+                    largest = i;
+            }
+
+            i = largest;
+
+            /* ensure that we don't enter infinite loop */
+            largest = (largest+1) % 5;
+
+            if (qlevels[i] <= min_qlevel[i]) {
+                /* can't unquantize any more */
+                continue;
+            }
+
+            /* quantize a little bit less */
+            save_qlevel = qlevels[i];
+            qlevels[i] -= dv100_qlevel_inc;
+            if (qlevels[i] < min_qlevel[i])
+                qlevels[i] = min_qlevel[i];
+
+            qnos[i] = DV100_QLEVEL_QNO(dv100_qlevels[qlevels[i]]);
+
+            size[i] = 0;
+
+            /* for each block */
+            b = &blks[8*i];
+            for (j = 0; j < 8; j++, b++) {
+                /* accumulate block size into macroblock */
+                if(size_cache[8*i+j][qlevels[i]] == 0) {
+                    size_cache[8*i+j][qlevels[i]] = dv100_actual_quantize(b, qlevels[i]);
+                }
+                size[i] += size_cache[8*i+j][qlevels[i]];
+            } /* for each block */
+
+            /* did we bust the limit? */
+            if(vs_total_ac_bits < (size[0] + size[1] + size[2] + size[3] + size[4])) {
+                /* go back down and exit */
+                qlevels[i] = save_qlevel;
+                qnos[i] = DV100_QLEVEL_QNO(dv100_qlevels[qlevels[i]]);
+                break;
+            }
+        }
+    }
+
+    /* now do the actual quantization */
+    for(i = 0; i < 5; i++) {
+        /* for each block */
+        b = &blks[8*i];
+        size[i] = 0;
+        for (j = 0; j < 8; j++, b++) {
+            /* accumulate block size into macroblock */
+            size[i] += dv100_actual_quantize(b, qlevels[i]);
+        } /* for each block */
+        qno_memory[i] = qlevels[i];
+    }
+}
+
+/* update all cno values into the blocks, over-writing the old values without
+   touching anything else. (only used for DV100) */
+static inline void dv_revise_cnos(uint8_t *dif, EncBlockInfo *blk, const DVprofile *profile)
+{
+    uint8_t *data;
+    int mb_index, j;
+
+    for (mb_index = 0; mb_index < 5; mb_index++) {
+	data = dif + mb_index*80 + 4;
+	for (j = 0; j < profile->bpm; j++) {
+	    /* zero out the class number */
+	    data[1] &= 0xCF;
+	    /* add the new one */
+	    data[1] |= blk[profile->bpm*mb_index+j].cno << 4;
+
+	    data += profile->block_sizes[j]/8;
+	}
+    }
+}
+
+static inline void dv_encode_video_segment(DVVideoContext *s,
+                                           uint8_t *dif,
+                                           const int mb_pos_ptr[10],
+                                           int qno_memory[5])
 {
-    DVVideoContext *s = avctx->priv_data;
-    DVwork_chunk *work_chunk = arg;
     int mb_index, i, j;
-    int mb_x, mb_y, c_offset, linesize, y_stride;
+    int mb_x, mb_y, c_offset, linesize;
     uint8_t*  y_ptr;
-    uint8_t*  dif;
-    uint8_t   scratch[64];
+    uint8_t*  data;
+    uint8_t*  ptr;
+    int       do_edge_wrap;
+    DECLARE_ALIGNED_16(DCTELEM, block[64]);
     EncBlockInfo  enc_blks[5*DV_MAX_BPM];
     PutBitContext pbs[5*DV_MAX_BPM];
     PutBitContext* pb;
     EncBlockInfo* enc_blk;
     int       vs_bit_size = 0;
-    int       qnos[5] = {15, 15, 15, 15, 15}; /* No quantization */
-    int*      qnosp = &qnos[0];
+    int       qnos[5];
+
+    assert((((int)block) & 15) == 0);
 
-    dif = &s->buf[work_chunk->buf_offset*80];
     enc_blk = &enc_blks[0];
-    for (mb_index = 0; mb_index < 5; mb_index++) {
-        dv_calculate_mb_xy(s, work_chunk, mb_index, &mb_x, &mb_y);
+    pb = &pbs[0];
+    for(mb_index = 0; mb_index < 5; mb_index++) {
 
-        /* initializing luminance blocks */
-        if ((s->sys->pix_fmt == PIX_FMT_YUV420P) ||
-            (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8)) ||
-            (s->sys->height >= 720 && mb_y != 134)) {
-            y_stride = s->picture.linesize[0] << 3;
-        } else {
-            y_stride = 16;
-        }
-        y_ptr    = s->picture.data[0] + ((mb_y * s->picture.linesize[0] + mb_x) << 3);
-        linesize = s->picture.linesize[0];
+	/* DV100 DCT mode is per-macroblock, not per-block */
+	int dv100_dct_mode = 0;
 
-        if (s->sys->video_stype == 4) { /* SD 422 */
-            vs_bit_size +=
-            dv_init_enc_block(enc_blk+0, y_ptr               , linesize, s, 0) +
-            dv_init_enc_block(enc_blk+1, NULL                , linesize, s, 0) +
-            dv_init_enc_block(enc_blk+2, y_ptr + 8           , linesize, s, 0) +
-            dv_init_enc_block(enc_blk+3, NULL                , linesize, s, 0);
-        } else {
-            vs_bit_size +=
-            dv_init_enc_block(enc_blk+0, y_ptr               , linesize, s, 0) +
-            dv_init_enc_block(enc_blk+1, y_ptr + 8           , linesize, s, 0) +
-            dv_init_enc_block(enc_blk+2, y_ptr     + y_stride, linesize, s, 0) +
-            dv_init_enc_block(enc_blk+3, y_ptr + 8 + y_stride, linesize, s, 0);
-        }
-        enc_blk += 4;
-
-        /* initializing chrominance blocks */
-        c_offset = (((mb_y >>  (s->sys->pix_fmt == PIX_FMT_YUV420P)) * s->picture.linesize[1] +
-                     (mb_x >> ((s->sys->pix_fmt == PIX_FMT_YUV411P) ? 2 : 1))) << 3);
-        for (j = 2; j; j--) {
-            uint8_t *c_ptr = s->picture.data[j] + c_offset;
-            linesize = s->picture.linesize[j];
-            y_stride = (mb_y == 134) ? 8 : (s->picture.linesize[j] << 3);
-            if (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8)) {
-                uint8_t* d;
-                uint8_t* b = scratch;
-                for (i = 0; i < 8; i++) {
-                    d = c_ptr + (linesize << 3);
-                    b[0] = c_ptr[0]; b[1] = c_ptr[1]; b[2] = c_ptr[2]; b[3] = c_ptr[3];
-                    b[4] =     d[0]; b[5] =     d[1]; b[6] =     d[2]; b[7] =     d[3];
-                    c_ptr += linesize;
-                    b += 8;
+        mb_x = *mb_pos_ptr++;
+        mb_y = *mb_pos_ptr++;
+	if (s->sys->pix_fmt == PIX_FMT_YUV422P) {
+            y_ptr = s->picture.data[0] + (mb_y * s->picture.linesize[0] * 8) + (mb_x * 4);
+        } else { /* 4:1:1 or 4:2:0 */
+            y_ptr = s->picture.data[0] + (mb_y * s->picture.linesize[0] * 8) + (mb_x * 8);
+        }
+	if (s->sys->pix_fmt == PIX_FMT_YUV420P) {
+            c_offset = (((mb_y >> 1) * s->picture.linesize[1] * 8) + ((mb_x >> 1) * 8));
+        } else { /* 4:2:2 or 4:1:1 */
+            c_offset = ((mb_y * s->picture.linesize[1] * 8) + ((mb_x >> 2) * 8));
+        }
+        do_edge_wrap = 0;
+	/* Start with no quantization (15 for 25/50Mbps, 1 for 100Mbps) */
+        qnos[mb_index] = DV_PROFILE_IS_HD(s->sys) ? 1 : 15;
+        ptr = dif + mb_index*80 + 4;
+        for(j = 0;j < s->sys->bpm; j++) {
+            int dummy = 0;
+	    if (DV_PROFILE_IS_HD(s->sys)) { /* all HD formats */
+		if (j < 4) {  /* Four Y blocks */
+                    /* NOTE: at bottom of image in 1080i50/60, the macroblock is handled as 411 */
+                    if (s->sys->height == 1080 && mb_y == 134) {
+                        data = y_ptr + (j * 8);
+                    } else {
+                        data = y_ptr + ((j & 1) * 8) + ((j >> 1) * 8 * s->picture.linesize[0]);
+                    }
+                    linesize = s->picture.linesize[0];
+                } else {      /* Cr and Cb blocks */
+		    int chan = 2 - ((j-4)>>1);
+		    if (s->sys->height == 1080 && mb_y == 134) {
+			/* bottom edge: horizontal row of 2 blocks */
+			data = s->picture.data[chan] + c_offset + ((j&1) * 8);
+		    } else {
+			data = s->picture.data[chan] + c_offset + ((j&1) * 8 * s->picture.linesize[chan]);
+		    }
+		    linesize = s->picture.linesize[chan];
+		}
+	    } else if (s->sys->pix_fmt == PIX_FMT_YUV422P) { /* 4:2:2 */
+                if (j == 0 || j == 2) {
+                    /* Y0 Y1 */
+                    data = y_ptr + ((j>>1) * 8);
+                    linesize = s->picture.linesize[0];
+                } else if (j > 3) {
+                    /* Cr Cb */
+                    data = s->picture.data[6 - j] + c_offset;
+                    linesize = s->picture.linesize[6 - j];
+                } else {
+                    /* j=1 and j=3 are "dummy" blocks, used for AC data only */
+                    data = 0;
+                    linesize = 0;
+                    dummy = 1;
+                }
+            } else { /* 4:1:1 or 4:2:0 */
+                if (j < 4) {  /* Four Y blocks */
+                    /* NOTE: at end of line, the macroblock is handled as 420 */
+                    if (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x < (704 / 8)) {
+                        data = y_ptr + (j * 8);
+                    } else {
+                        data = y_ptr + ((j & 1) * 8) + ((j >> 1) * 8 * s->picture.linesize[0]);
+                    }
+                    linesize = s->picture.linesize[0];
+                } else {      /* Cr and Cb blocks */
+                    /* don't ask Fabrice why they inverted Cb and Cr ! */
+                    data = s->picture.data[6 - j] + c_offset;
+                    linesize = s->picture.linesize[6 - j];
+                    if (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8))
+                        do_edge_wrap = 1;
                 }
-                c_ptr = scratch;
-                linesize = 8;
             }
 
-            vs_bit_size += dv_init_enc_block(    enc_blk++, c_ptr           , linesize, s, 1);
-            if (s->sys->bpm == 8) {
-                vs_bit_size += dv_init_enc_block(enc_blk++, c_ptr + y_stride, linesize, s, 1);
+            /* decide whether to use DV100 field macroblock mode */
+            /* note that 4x1 "bottom macro blocks" cannot use field mode */
+            if ((s->sys->height == 1080) && (j == 0) &&
+                /* some decoders appear not to support field mode in the entire
+                   1080i60 A0-A16 or 1080i50 A0-A1 regions, even though not all
+                   of those macroblocks are "bottom macro blocks" */
+                ((DV_PROFILE_IS_1080i50(s->sys) && (mb_y != 0) && (mb_y != 134)) ||
+                 (DV_PROFILE_IS_1080i60(s->sys) && (mb_y >= 8) && (mb_y < 128)))
+                && (s->avctx->flags & CODEC_FLAG_INTERLACED_DCT)) {
+                /* XXX could have a better heuristic for this */
+                int p = 0, q = 0, line;
+                for (line=0;line<6;line++) {
+                    for (i=0;i<8;i++) {
+                        int dp, dq;
+                        dp = data[(line+0)*linesize+i] - data[(line+1)*linesize+i];
+                        dq = data[(line+0)*linesize+i] - data[(line+2)*linesize+i];
+                        p += dp*dp;
+                        q += dq*dq;
+                    }
+                }
+                dv100_dct_mode = (p>(q-100));
             }
-        }
-    }
 
-    if (vs_total_ac_bits < vs_bit_size)
-        dv_guess_qnos(&enc_blks[0], qnosp);
+            /* Everything is set up -- now just copy data -> DCT block */
+            if (do_edge_wrap) {  /* Edge wrap copy: 4x16 -> 8x8 */
+                uint8_t* d;
+                DCTELEM *b = block;
+                for (i=0;i<8;i++) {
+                   d = data + 8 * linesize;
+                   b[0] = data[0]; b[1] = data[1]; b[2] = data[2]; b[3] = data[3];
+                   b[4] =    d[0]; b[5] =    d[1]; b[6] =    d[2]; b[7] =    d[3];
+                   data += linesize;
+                   b += 8;
+                }
+	    } else if (dv100_dct_mode) { /* DV100 field DCT */
+                DCTELEM *b = block;
+		uint8_t *data0, *data1, *d;
+		int off;
+		if (s->sys->height == 1080 && mb_y == 134) {
+		    off = 16;
+		} else {
+		    off = 8*linesize;
+		}
+		if(j < 2 || j == 4 || j == 6) {
+		    data0 = data;
+		    data1 = data + off;
+		} else {
+		    data0 = data - off;
+		    data1 = data;
+		    data0 += linesize;
+		    data1 += linesize;
+		}
+		d = data0;
+		for (i=0;i<4;i++) {
+		    b[0] = d[0]; b[1] = d[1]; b[2] = d[2]; b[3] = d[3];
+		    b[4] = d[4]; b[5] = d[5]; b[6] = d[6]; b[7] = d[7];
+		    b += 8;
+		    d += 2*linesize;
+		}
+		d = data1;
+		for (i=0;i<4;i++) {
+		    b[0] = d[0]; b[1] = d[1]; b[2] = d[2]; b[3] = d[3];
+		    b[4] = d[4]; b[5] = d[5]; b[6] = d[6]; b[7] = d[7];
+		    b += 8;
+		    d += 2*linesize;
+		}
+            } else {             /* Simple copy: 8x8 -> 8x8 */
+                if (!dummy)
+                    s->get_pixels(block, data, linesize);
+            }
 
-    /* DIF encoding process */
-    for (j=0; j<5*s->sys->bpm;) {
-        int start_mb = j;
+            if((s->avctx->flags & CODEC_FLAG_INTERLACED_DCT) &&
+	       !DV_PROFILE_IS_HD(s->sys))
+                enc_blk->dct_mode = dv_guess_dct_mode(block);
+            else
+                enc_blk->dct_mode = 0;
+            enc_blk->area_q[0] = enc_blk->area_q[1] = enc_blk->area_q[2] = enc_blk->area_q[3] = 0;
+            enc_blk->partial_bit_count = 0;
+            enc_blk->partial_bit_buffer = 0;
+            enc_blk->cur_ac = 0;
+
+            if (dummy) {
+                /* We rely on the fact that encoding all zeros leads to an immediate EOB,
+                   which is precisely what the spec calls for in the "dummy" blocks. */
+                memset(block, 0, sizeof(block));
+            } else {
+                s->fdct[enc_blk->dct_mode](block);
+            }
 
-        dif[3] = *qnosp++;
-        dif += 4;
+	    if (DV_PROFILE_IS_HD(s->sys)) {
+		const int *weights;
+		if (s->sys->height == 1080) {
+		    weights = (j < 4) ? dv_weight_1080_y : dv_weight_1080_c;
+		} else { /* 720p */
+		    weights = (j < 4) ? dv_weight_720_y : dv_weight_720_c;
+		}
+		dv_set_class_number_hd(block, enc_blk,
+				       ff_zigzag_direct,
+				       weights,
+				       dv100_min_bias+(j>>2)*dv100_chroma_bias);
+	    } else {
+		dv_set_class_number_sd(block, enc_blk,
+				       enc_blk->dct_mode ? ff_zigzag248_direct : ff_zigzag_direct,
+				       enc_blk->dct_mode ? dv_weight_248 : dv_weight_88,
+				       j>>2);
+	    }
+
+            init_put_bits(pb, ptr, s->sys->block_sizes[j]/8);
+
+            put_bits(pb, 9, (uint16_t)(((enc_blk->mb[0] >> 3) - 1024 + 2) >> 2));
+            put_bits(pb, 1, DV_PROFILE_IS_HD(s->sys) ? ((j == 0) ? dv100_dct_mode : 1) : enc_blk->dct_mode);
+            put_bits(pb, 2, enc_blk->cno);
+
+            vs_bit_size += enc_blk->bit_size[0] + enc_blk->bit_size[1] +
+                           enc_blk->bit_size[2] + enc_blk->bit_size[3];
+            ++enc_blk;
+            ++pb;
+            ptr += s->sys->block_sizes[j]/8;
+        }
+    }
 
-        /* First pass over individual cells only */
-        for (i=0; i<s->sys->bpm; i++, j++) {
-            int sz = s->sys->block_sizes[i]>>3;
+    if (DV_PROFILE_IS_HD(s->sys)) {
+        /* unconditional */
+        dv_guess_qnos_hd(&enc_blks[0], &qnos[0], s->sys->vs_total_ac_bits, qno_memory);
+    } else if (s->sys->vs_total_ac_bits < vs_bit_size) {
+        dv_guess_qnos_sd(&enc_blks[0], &qnos[0], s->sys->vs_total_ac_bits);
+    }
 
-            init_put_bits(&pbs[j], dif, sz);
-            put_bits(&pbs[j], 9, (uint16_t)(((enc_blks[j].mb[0] >> 3) - 1024 + 2) >> 2));
-            put_bits(&pbs[j], 1, enc_blks[j].dct_mode);
-            put_bits(&pbs[j], 2, enc_blks[j].cno);
+    for (i=0; i<5; i++) {
+       dif[i*80 + 3] = qnos[i];
+    }
 
-            dv_encode_ac(&enc_blks[j], &pbs[j], &pbs[j+1]);
-            dif += sz;
-        }
+    /* First pass over individual cells only */
+    for (j=0; j<5*s->sys->bpm; j++)
+       dv_encode_ac(&enc_blks[j], &pbs[j], &pbs[j+1]);
 
-        /* Second pass over each MB space */
-        pb = &pbs[start_mb];
+    /* Second pass over each MB space */
+    for (j=0; j<5*s->sys->bpm; j+=s->sys->bpm) {
+        pb= &pbs[j];
         for (i=0; i<s->sys->bpm; i++) {
-            if (enc_blks[start_mb+i].partial_bit_count)
-                pb = dv_encode_ac(&enc_blks[start_mb+i], pb, &pbs[start_mb+s->sys->bpm]);
+            if (enc_blks[i+j].partial_bit_count)
+                pb=dv_encode_ac(&enc_blks[i+j], pb, &pbs[j+s->sys->bpm]);
         }
     }
 
-    /* Third and final pass over the whole video segment space */
-    pb = &pbs[0];
+    /* Third and final pass over the whole vides segment space */
+    pb= &pbs[0];
     for (j=0; j<5*s->sys->bpm; j++) {
        if (enc_blks[j].partial_bit_count)
-           pb = dv_encode_ac(&enc_blks[j], pb, &pbs[s->sys->bpm*5]);
+           pb=dv_encode_ac(&enc_blks[j], pb, &pbs[s->sys->bpm*5]);
        if (enc_blks[j].partial_bit_count)
             av_log(NULL, AV_LOG_ERROR, "ac bitstream overflow\n");
     }
@@ -1103,12 +1541,512 @@
     for (j=0; j<5*s->sys->bpm; j++)
        flush_put_bits(&pbs[j]);
 
+    if (DV_PROFILE_IS_HD(s->sys))
+	dv_revise_cnos(dif, enc_blks, s->sys);
+}
+
+/* macroblock permutations common to all formats */
+static const uint8_t super_x_order[] = {2,1,3,0,4};
+static const uint8_t super_y_bases[] = {2,6,8,0,4};
+
+void find_macroblock_dv25_411(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10])
+{
+    /* starting x coordinate of horizontal superblocks, in units of blocks */
+    static const uint8_t super_x_starts[] = {0,4,9,13,18};
+
+    int mb_index;
+    int *mb = &mbloc[0];
+    for (mb_index = 0; mb_index < 5; mb_index++, mb += 2) {
+	/* index of this block within the DIF sequence (0-135) */
+	int vid_block_num = av*15 + seg*5 + mb_index;
+
+	/* X and Y indices of the superblock we're inside */
+	int super_x = super_x_order[vid_block_num % 5];
+	int super_y = (super_y_bases[vid_block_num % 5] + seq) % sys->difseg_size;
+
+	/* index within the superblock */
+	int within_super = vid_block_num / 5;
+
+	/* locate us within the superblock's "Tetris" pattern */
+	int within_super_x, within_super_y;
+
+	if (super_x & 1) {
+	    /* super_x is ODD */
+	    if (within_super < 3) {
+		within_super_x = 0;
+		within_super_y = 3 + within_super;
+	    } else if (within_super < 9) {
+		within_super_x = 1;
+		within_super_y = 5 - (within_super-3);
+	    } else if (within_super < 15) {
+		within_super_x = 2;
+		within_super_y = (within_super-9);
+	    } else if (within_super < 21) {
+		within_super_x = 3;
+		within_super_y = 5 - (within_super-15);
+	    } else {
+		within_super_x = 4;
+		within_super_y = (within_super-21);
+	    }
+	} else {
+	    /* super_x is EVEN */
+	    if (within_super < 6) {
+		within_super_x = 0;
+		within_super_y = within_super;
+	    } else if (within_super < 12) {
+		within_super_x = 1;
+		within_super_y = 5 - (within_super-6);
+	    } else if (within_super < 18) {
+		within_super_x = 2;
+		within_super_y = (within_super - 12);
+	    } else if (within_super < 24) {
+		within_super_x = 3;
+		within_super_y = 5 - (within_super-18);
+	    } else {
+		within_super_x = 4;
+		within_super_y = (within_super-24);
+		/* special case for rightmost superblock */
+		if (super_x == 4) {
+		    within_super_y *= 2;
+		}
+	    }
+	}
+
+	mb[0] = 4*(super_x_starts[super_x] + within_super_x);
+	mb[1] = 6*super_y + within_super_y;
+    }
+}
+
+/* return x,y given an index into the 9x3 brick pattern */
+static void macroblock_brick_pattern(int within_super, int *within_super_x, int *within_super_y)
+{
+    if (within_super < 3) {
+	*within_super_x = 0;
+	*within_super_y = within_super;
+    } else if (within_super < 6) {
+	*within_super_x = 1;
+	*within_super_y = 2 - (within_super-3);
+    } else if (within_super < 9) {
+	*within_super_x = 2;
+	*within_super_y = (within_super-6);
+    } else if (within_super < 12) {
+	*within_super_x = 3;
+	*within_super_y = 2 - (within_super-9);
+    } else if (within_super < 15) {
+	*within_super_x = 4;
+	*within_super_y = (within_super-12);
+    } else if (within_super < 18) {
+	*within_super_x = 5;
+	*within_super_y = 2 - (within_super-15);
+    } else if (within_super < 21) {
+	*within_super_x = 6;
+	*within_super_y = (within_super-18);
+    } else if (within_super < 24) {
+	*within_super_x = 7;
+	*within_super_y = 2 - (within_super-21);
+    } else {
+	*within_super_x = 8;
+	*within_super_y = (within_super-24);
+    }
+}
+
+void find_macroblock_dv25_420(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10])
+{
+    int mb_index;
+    int *mb = &mbloc[0];
+    for (mb_index = 0; mb_index < 5; mb_index++, mb += 2) {
+	/* index of this block within the DIF sequence (0-135) */
+	int vid_block_num = av*15 + seg*5 + mb_index;
+
+	/* X and Y indices of the superblock we're inside */
+	int super_x = super_x_order[vid_block_num % 5];
+	int super_y = (super_y_bases[vid_block_num % 5] + seq) % sys->difseg_size;
+
+	/* index within the superblock */
+	int within_super = vid_block_num / 5;
+
+	/* locate us within the superblock's "brick" pattern */
+	int within_super_x, within_super_y;
+
+	macroblock_brick_pattern(within_super, &within_super_x, &within_super_y);
+
+	mb[0] = 2*(9*super_x + within_super_x);
+	mb[1] = 2*(3*super_y + within_super_y);
+    }
+}
+
+void find_macroblock_dv50(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10])
+{
+    int mb_index;
+    int *mb = &mbloc[0];
+    for (mb_index = 0; mb_index < 5; mb_index++, mb += 2) {
+
+	/* index of this block within the DIF sequence (0-135) */
+	int vid_block_num = av*15 + seg*5 + mb_index;
+
+	int ysupers = 2 * sys->difseg_size;
+
+	/* X and Y indices of the superblock we're inside */
+	int super_x = super_x_order[vid_block_num % 5];
+	int super_y = (2*(super_y_bases[vid_block_num % 5] + seq) + channel) % ysupers;
+
+	/* index within the superblock */
+	int within_super = vid_block_num / 5;
+
+	/* locate us within the superblock's "brick" pattern */
+	int within_super_x, within_super_y;
+
+	macroblock_brick_pattern(within_super, &within_super_x, &within_super_y);
+
+	/* macroblocks are 16x8 pixels */
+	mb[0] = 4*(9*super_x + within_super_x);
+	mb[1] = (3*super_y + within_super_y);
+    }
+}
+
+void find_macroblock_dv100_1080i60(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10])
+{
+    /* starting 't' values indexed by DIF sequence */
+    static const uint8_t t_starts[] = {0,2,4,1,3,0,2,4,1,3};
+
+    int mb_index;
+    int *mb = &mbloc[0];
+    for (mb_index = 0; mb_index < 5; mb_index++, mb += 2) {
+	/* one "divided block" h  per channel (0-3) */
+	int hx = channel & 1;
+	int hy = channel >>1;
+
+	/* X and Y indices of the superblock we're inside */
+	/* superblocks are 9x3 blocks */
+	int super_x = super_x_order[mb_index];
+
+	/* the superblock y coordinates use a permutation */
+
+	int s = seq/5; /* first half of channel? */
+	int t = (t_starts[seq] + av*3 + seg) % 5;
+
+	int super_y = (super_y_bases[mb_index] + 4*channel + s + 2*t) % 10;
+
+	/* index within the superblock */
+	int within_super = ((av*3 + seg + 27*seq)/5) % 27;
+
+	/* locate us within the superblock's "brick" pattern */
+	int within_super_x = within_super % 9;
+	int within_super_y = within_super / 9;
+
+	/* block x,y coordinates within divided block */
+	int divblock_x = (9*super_x + within_super_x);
+	int divblock_y = (3*super_y + within_super_y);
+
+	/* coordinates within rearranged frame */
+	int re_x = 18*(divblock_x/9) + 9*hx + (divblock_x % 9);
+	int re_y = 2*divblock_y + hy;
+
+	/* de-rearrange the macroblock */
+	int block_x, block_y;
+	if (re_x >= 80) {
+	    /* right edge strip */
+	    if (re_y < 32) {
+		/* A0-A7 */
+		block_x = 10 * (re_y/4) + (re_x-80);
+		block_y = re_y % 4;
+	    } else if (re_y < 56) {
+		/* A8-A15 */
+		block_x = 10*((re_y-32)/3) + (re_x - 80);
+		block_y = 64 + (re_y-32) % 3;
+	    } else {
+		/* B16 */
+		block_x = 10*(re_y-56) + ((re_x - 80) % 10);
+		block_x *= 2; /* B blocks are twice as wide as A blocks */
+		block_y = 67;
+	    }
+	} else {
+	    block_x = re_x;
+	    block_y = re_y + 4;
+	}
+
+	/* macroblocks are 16x16 pixels */
+	mb[0] = 4*block_x;
+	mb[1] = 2*block_y;
+    }
+}
+
+void find_macroblock_dv100_1080i50(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10])
+{
+    int mb_index;
+    int *mb = &mbloc[0];
+    for (mb_index = 0; mb_index < 5; mb_index++, mb += 2) {
+	/* one "divided block" h  per channel (0-3) */
+	int hx = channel & 1;
+	int hy = channel >>1;
+
+	/* X and Y indices of the superblock we're inside */
+	/* superblocks are 9x3 blocks */
+	int super_x, super_y;
+
+	/* index within the superblock */
+	int within_super;
+
+	/* macroblock location */
+	int block_x, block_y;
+
+	if (channel == 0 && seq == 11) { /* edge unit */
+	    super_x = mb_index;
+	    super_y = 0;
+
+	    within_super = (av*3 + seg + 27*seq) % 27;
+	    block_x = 27*super_x + within_super;
+
+	    if (block_x < 90) { /* A0 */
+		block_y = 0;
+	    } else { /* A1 */
+		/* A1 macroblocks are wide and short */
+		block_x = 2*(block_x-90);
+		block_y = 67;
+	    }
+	} else {
+	    static const int super_y_pattern[] =  {0,5,10,4,9,3,8,2,7,1,6};
+	    int within_super_x, within_super_y;
+	    int divblock_x, divblock_y;
+	    int re_x, re_y;
+
+	    super_x = super_x_order[mb_index];
+
+	    /* the superblock y coordinates use a permutation */
+	    super_y = (super_y_bases[mb_index] + super_y_pattern[(seq+3*channel)%11] + seg + av*3) % 11;
+
+	    within_super = ((av*3 + seg + 27*seq)/11) % 27;
+
+	    /* locate us within the superblock's "brick" pattern */
+	    within_super_x = within_super % 9;
+	    within_super_y = within_super / 9;
+
+	    /* block x,y coordinates within divided block */
+	    divblock_x = (9*super_x + within_super_x);
+	    divblock_y = (3*super_y + within_super_y);
+
+	    /* coordinates within rearranged frame */
+	    re_x = 18*(divblock_x/9) + 9*hx + (divblock_x % 9);
+	    re_y = 2*divblock_y + hy;
+
+	    block_x = re_x;
+	    block_y = re_y + 1;
+	    assert(block_x >= 0 && block_x < 90);
+	    assert(block_y >= 0 && block_y < 67);
+	}
+
+	/* macroblocks are 16x16 pixels */
+	mb[0] = 4*block_x;
+	mb[1] = 2*block_y;
+    }
+}
+
+void find_macroblock_dv100_720p60(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10])
+{
+    /* starting 't' values indexed by DIF sequence */
+    static const uint8_t t_starts[] = {0,2,4,1,3,0,2,4,1,3};
+
+    int mb_index;
+    int *mb = &mbloc[0];
+    for (mb_index = 0; mb_index < 5; mb_index++, mb += 2) {
+	/* one "divided block" h  per channel (0-3) */
+	int hx = channel & 1;
+	int hy = channel >>1;
+
+	/* X and Y indices of the superblock we're inside */
+	/* superblocks are 9x3 blocks */
+	int super_x = super_x_order[mb_index];
+
+	/* the superblock y coordinates use a permutation */
+
+	int s = seq/5; /* first half of channel? */
+	int t = (t_starts[seq] + av*3 + seg) % 5;
+
+	int super_y = (super_y_bases[mb_index] + 4*channel + s + 2*t) % 10;
+
+	/* index within the superblock */
+	int within_super = ((av*3 + seg + 27*seq)/5) % 27;
+
+	/* locate us within the superblock's "tetris" pattern */
+	int within_super_x, within_super_y;
+	int divblock_x, divblock_y;
+	int block_x, block_y;
+
+	if (super_y & 1) { /* lower tetris */
+	    if (within_super < 3) {
+		within_super_x = 3 + within_super;
+		within_super_y = 4;
+	    } else if (within_super < 9) {
+		within_super_x = within_super - 3;
+		within_super_y = 5;
+	    } else if (within_super < 15) {
+		within_super_x = within_super - 9;
+		within_super_y = 6;
+	    } else if (within_super < 21) {
+		within_super_x = within_super - 15;
+		within_super_y = 7;
+	    } else {
+		within_super_x = within_super - 21;
+		within_super_y = 8;
+	    }
+	} else { /* upper tetris */
+	    if (within_super < 6) {
+		within_super_x = within_super;
+		within_super_y = 0;
+	    } else if (within_super < 12) {
+		within_super_x = within_super - 6;
+		within_super_y = 1;
+	    } else if (within_super < 18) {
+		within_super_x = within_super - 12;
+		within_super_y = 2;
+	    } else if (within_super < 24) {
+		within_super_x = within_super - 18;
+		within_super_y = 3;
+	    } else {
+		within_super_x = within_super - 24;
+		within_super_y = 4;
+	    }
+	}
+
+	/* block x,y coordinates within divided block */
+	divblock_x = (6*super_x + within_super_x);
+	divblock_y = (9*(super_y>>1) + within_super_y);
+
+	/* coordinates within rearranged frame */
+	block_x = 12*(divblock_x/6) + 6*hx + (divblock_x % 6);
+	block_y = divblock_y + 45*hy;
+
+	/* macroblocks are 16x16 pixels */
+	mb[0] = 4*block_x;
+	mb[1] = 2*block_y;
+    }
+}
+
+static int dv_decode_mt(AVCodecContext *avctx, void* arg)
+{
+    DVVideoContext *s = avctx->priv_data;
+	void *sl = *(size_t*)arg;
+    int i;
+
+    for (i = 0; i < s->sys->n_difchan*27; i++) {
+	int slice = ((size_t)sl)*s->sys->n_difchan*27 + i;
+
+	/* which DIF channel is this? */
+	int chan = slice / (s->sys->difseg_size * 27);
+
+	/* slice within the DIF channel */
+	int chan_slice = slice % (s->sys->difseg_size * 27);
+
+	/* DIF sequence */
+	int seq = chan_slice / 27;
+
+	/* AV sequence */
+	int av = (chan_slice/3) % 9;
+
+	/* video segment */
+	int seg = chan_slice % 3;
+
+	/* byte offset of this channel's data */
+	int chan_offset = chan * s->sys->difseg_size * 150 * 80;
+
+	/* first byte of first DIF block in this video segment */
+	uint8_t *dif = &s->buf[((chan_slice/27)*6+(chan_slice/3)+chan_slice*5+7)*80 + chan_offset];
+
+	/* macroblock locations (x,y for each of the 5 macroblocks) */
+	int mbloc[5*2];
+
+	/* in 1080i50, channel !=0 / seq == 11 are unused */
+	if (DV_PROFILE_IS_1080i50(s->sys) && chan != 0 && seq == 11)
+	    continue;
+
+	if (s->sys->find_macroblock) {
+	    s->sys->find_macroblock(s->sys, chan, seq, av, seg, mbloc);
+	} else {
+	    int i;
+	    int *mb = &mbloc[0];
+	    for (i = 0; i < 5; i++, mb += 2) {
+		uint32_t v = s->sys->video_place[slice*5 + i];
+		mb[0] = v & 0xff;
+		mb[1] = v >> 8;
+	    }
+	}
+
+	dv_decode_video_segment(s, dif, mbloc);
+    }
     return 0;
 }
 
+#ifdef CONFIG_DVVIDEO_ENCODER
+static int dv_encode_mt(AVCodecContext *avctx, void* arg)
+{
+    DVVideoContext *s = avctx->priv_data;
+	void *sl = *(size_t*)arg;
+    /* maintain QNOs used for last set of macroblocks
+       as a starting point for future macroblocks
+       (for speed optimization only, doesn't affect quality) */
+    int qno_memory[5];
+    int i;
+
+    for (i = 0; i < 5; i++)
+        qno_memory[i] = dv100_starting_qno;
+
+    for (i = 0; i < s->sys->n_difchan*27; i++) {
+	int slice = ((size_t)sl)*s->sys->n_difchan*27 + i;
+
+	/* which DIF channel is this? */
+	int chan = slice / (s->sys->difseg_size * 27);
+
+	/* slice within the DIF channel */
+	int chan_slice = slice % (s->sys->difseg_size * 27);
+
+	/* DIF sequence */
+	int seq = chan_slice / 27;
+
+	/* AV sequence */
+	int av = (chan_slice/3) % 9;
+
+	/* video segment */
+	int seg = chan_slice % 3;
+
+	/* byte offset of this channel's data */
+	int chan_offset = chan * s->sys->difseg_size * 150 * 80;
+
+	/* first byte of first DIF block in this video segment */
+	uint8_t *dif = &s->buf[((chan_slice/27)*6+(chan_slice/3)+chan_slice*5+7)*80 + chan_offset];
+
+	/* macroblock locations (x,y for each of the 5 macroblocks) */
+	int mbloc[5*2];
+
+	/* in 1080i50, channel !=0 / seq == 11 are unused */
+	if (DV_PROFILE_IS_1080i50(s->sys) && chan != 0 && seq == 11) {
+	    /* clear the dummy DIF blocks */
+	    int b;
+	    for (b = 0; b < 5; b++, dif += 80)
+		memset(dif+3, 0xff, 77);
+	    continue;
+	}
+
+	if (s->sys->find_macroblock) {
+	    s->sys->find_macroblock(s->sys, chan, seq, av, seg, mbloc);
+	} else {
+	    int i;
+	    int *mb = &mbloc[0];
+	    for (i = 0; i < 5; i++, mb += 2) {
+		uint32_t v = s->sys->video_place[slice*5 + i];
+		mb[0] = v & 0xff;
+		mb[1] = v >> 8;
+	    }
+	}
+
+	dv_encode_video_segment(s, dif, mbloc, qno_memory);
+    }
+    return 0;
+}
+#endif
+
 #if CONFIG_DVVIDEO_DECODER
 /* NOTE: exactly one frame must be given (120000 bytes for NTSC,
-   144000 bytes for PAL - or twice those for 50Mbps) */
+   144000 bytes for PAL - or twice those for 50Mbps - or 4x for 100Mbps) */
 static int dvvideo_decode_frame(AVCodecContext *avctx,
                                  void *data, int *data_size,
                                  const uint8_t *buf, int buf_size)
@@ -1116,105 +2054,100 @@
     DVVideoContext *s = avctx->priv_data;
 
     s->sys = dv_frame_profile(buf);
-    if (!s->sys || buf_size < s->sys->frame_size || dv_init_dynamic_tables(s->sys))
+    if (!s->sys || buf_size < s->sys->frame_size)
         return -1; /* NOTE: we only accept several full frames */
 
-    if (s->picture.data[0])
+    if(s->picture.data[0])
         avctx->release_buffer(avctx, &s->picture);
 
     s->picture.reference = 0;
     s->picture.key_frame = 1;
     s->picture.pict_type = FF_I_TYPE;
-    avctx->pix_fmt   = s->sys->pix_fmt;
-    avctx->time_base = s->sys->time_base;
+    avctx->pix_fmt = s->sys->pix_fmt;
+    avctx->time_base = (AVRational){s->sys->frame_rate_base, s->sys->frame_rate};
     avcodec_set_dimensions(avctx, s->sys->width, s->sys->height);
-    if (avctx->get_buffer(avctx, &s->picture) < 0) {
+    if(avctx->get_buffer(avctx, &s->picture) < 0) {
         av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
         return -1;
     }
     s->picture.interlaced_frame = 1;
-    s->picture.top_field_first  = 0;
+    s->picture.top_field_first = 0;
 
     s->buf = buf;
-    avctx->execute(avctx, dv_decode_video_segment, s->sys->work_chunks, NULL,
-                   dv_work_pool_size(s->sys), sizeof(DVwork_chunk));
+    avctx->execute(avctx, dv_decode_mt, (void**)&dv_anchor[0], NULL, s->sys->difseg_size, sizeof(void*));
 
     emms_c();
 
     /* return image */
     *data_size = sizeof(AVFrame);
-    *(AVFrame*)data = s->picture;
+    *(AVFrame*)data= s->picture;
 
     return s->sys->frame_size;
 }
 #endif /* CONFIG_DVVIDEO_DECODER */
 
 
-static inline int dv_write_pack(enum dv_pack_type pack_id, DVVideoContext *c,
-                                uint8_t* buf)
+static int dv_write_pack(enum dv_pack_type pack_id, DVVideoContext *c, uint8_t* buf, int seq)
 {
-    /*
-     * Here's what SMPTE314M says about these two:
-     *    (page 6) APTn, AP1n, AP2n, AP3n: These data shall be identical
-     *             as track application IDs (APTn = 001, AP1n =
-     *             001, AP2n = 001, AP3n = 001), if the source signal
-     *             comes from a digital VCR. If the signal source is
-     *             unknown, all bits for these data shall be set to 1.
-     *    (page 12) STYPE: STYPE defines a signal type of video signal
-     *                     00000b = 4:1:1 compression
-     *                     00100b = 4:2:2 compression
-     *                     XXXXXX = Reserved
-     * Now, I've got two problems with these statements:
-     *   1. it looks like APT == 111b should be a safe bet, but it isn't.
-     *      It seems that for PAL as defined in IEC 61834 we have to set
-     *      APT to 000 and for SMPTE314M to 001.
-     *   2. It is not at all clear what STYPE is used for 4:2:0 PAL
-     *      compression scheme (if any).
-     */
-    int apt   = (c->sys->pix_fmt == PIX_FMT_YUV420P ? 0 : 1);
-
-    uint8_t aspect = 0;
-    if ((int)(av_q2d(c->avctx->sample_aspect_ratio) * c->avctx->width / c->avctx->height * 10) >= 17) /* 16:9 */
-        aspect = 0x02;
+    int apt;
+    uint8_t aspect;
+
+    /* Its hard to tell what SMPTE requires w.r.t. APT, but Quicktime needs it.
+     * We set it based on pix_fmt value but it really should be per DV profile */
+    if (DV_PROFILE_IS_HD(c->sys)) {
+	    apt = 0;
+    } else {
+	    apt = (c->sys->pix_fmt == PIX_FMT_YUV422P ? 1 : 0);
+    }
+
+    if (DV_PROFILE_IS_HD(c->sys)) {
+	/* HD formats are always 16:9 */
+	aspect = 0x07;
+    } else {
+	aspect = 0; /* 4:3 is the default*/
+        if((int)(av_q2d(c->avctx->sample_aspect_ratio) * c->avctx->width / c->avctx->height * 10) >= 17) /* 16:9 */
+            aspect = 0x07; // REGRESSION: 0x02???
+    }
+
 
     buf[0] = (uint8_t)pack_id;
     switch (pack_id) {
     case dv_header525: /* I can't imagine why these two weren't defined as real */
     case dv_header625: /* packs in SMPTE314M -- they definitely look like ones */
-          buf[1] = 0xf8 |        /* reserved -- always 1 */
-                   (apt & 0x07); /* APT: Track application ID */
-          buf[2] = (0    << 7) | /* TF1: audio data is 0 - valid; 1 - invalid */
+          buf[1] = 0xf8 |               /* reserved -- always 1 */
+                   (apt & 0x07);        /* APT: Track application ID */
+          buf[2] = (0 << 7)    | /* TF1: audio data is 0 - valid; 1 - invalid */
                    (0x0f << 3) | /* reserved -- always 1 */
                    (apt & 0x07); /* AP1: Audio application ID */
-          buf[3] = (0    << 7) | /* TF2: video data is 0 - valid; 1 - invalid */
+          buf[3] = (0 << 7)    | /* TF2: video data is 0 - valid; 1 - invalid */
                    (0x0f << 3) | /* reserved -- always 1 */
                    (apt & 0x07); /* AP2: Video application ID */
-          buf[4] = (0    << 7) | /* TF3: subcode(SSYB) is 0 - valid; 1 - invalid */
+          buf[4] = (0 << 7)    | /* TF3: subcode(SSYB) is 0 - valid; 1 - invalid */
                    (0x0f << 3) | /* reserved -- always 1 */
                    (apt & 0x07); /* AP3: Subcode application ID */
           break;
     case dv_video_source:
-          buf[1] = 0xff;      /* reserved -- always 1 */
+          buf[1] = 0xff; /* reserved -- always 1 */
           buf[2] = (1 << 7) | /* B/W: 0 - b/w, 1 - color */
                    (1 << 6) | /* following CLF is valid - 0, invalid - 1 */
-                   (3 << 4) | /* CLF: color frames ID (see ITU-R BT.470-4) */
-                   0xf;       /* reserved -- always 1 */
+                   (3 << 4) | /* CLF: color frames id (see ITU-R BT.470-4) */
+                   0xf; /* reserved -- always 1 */
           buf[3] = (3 << 6) | /* reserved -- always 1 */
                    (c->sys->dsf << 5) | /*  system: 60fields/50fields */
-                   c->sys->video_stype; /* signal type video compression */
-          buf[4] = 0xff;      /* VISC: 0xff -- no information */
+	           c->sys->video_stype; /* signal type video compression */
+          buf[4] = 0xff; /* VISC: 0xff -- no information */
           break;
     case dv_video_control:
           buf[1] = (0 << 6) | /* Copy generation management (CGMS) 0 -- free */
-                   0x3f;      /* reserved -- always 1 */
-          buf[2] = 0xc8 |     /* reserved -- always b11001xxx */
+                   0x3f; /* reserved -- always 1 */
+          buf[2] = 0xc8 | /* reserved -- always b11001xxx */
                    aspect;
-          buf[3] = (1 << 7) | /* frame/field flag 1 -- frame, 0 -- field */
-                   (1 << 6) | /* first/second field flag 0 -- field 2, 1 -- field 1 */
-                   (1 << 5) | /* frame change flag 0 -- same picture as before, 1 -- different */
+          buf[3] = (1 << 7) | /* Frame/field flag 1 -- frame, 0 -- field */
+                   (1 << 6) | /* First/second field flag 0 -- field 2, 1 -- field 1 */
+                   (1 << 5) | /* Frame change flag 0 -- same picture as before, 1 -- different */
                    (1 << 4) | /* 1 - interlaced, 0 - noninterlaced */
-                   0xc;       /* reserved -- always b1100 */
-          buf[4] = 0xff;      /* reserved -- always 1 */
+                   0xc; /* reserved -- always b1100 */
+          buf[4] = 0xff; /* reserved -- always 1 */
           break;
     default:
           buf[1] = buf[2] = buf[3] = buf[4] = 0xff;
@@ -1229,11 +2162,11 @@
 
     for (chan = 0; chan < c->sys->n_difchan; chan++) {
         for (i = 0; i < c->sys->difseg_size; i++) {
-            memset(buf, 0xff, 80 * 6); /* first 6 DIF blocks are for control data */
+            memset(buf, 0xff, 80 * 6); /* First 6 DIF blocks are for control data */
 
             /* DV header: 1DIF */
             buf += dv_write_dif_id(dv_sect_header, chan, i, 0, buf);
-            buf += dv_write_pack((c->sys->dsf ? dv_header625 : dv_header525), c, buf);
+            buf += dv_write_pack((c->sys->dsf ? dv_header625 : dv_header525), c, buf, i);
             buf += 72; /* unused bytes */
 
             /* DV subcode: 2DIFs */
@@ -1247,11 +2180,11 @@
             /* DV VAUX: 3DIFS */
             for (j = 0; j < 3; j++) {
                 buf += dv_write_dif_id(dv_sect_vaux, chan, i, j, buf);
-                buf += dv_write_pack(dv_video_source,  c, buf);
-                buf += dv_write_pack(dv_video_control, c, buf);
+                buf += dv_write_pack(dv_video_source,  c, buf, i);
+                buf += dv_write_pack(dv_video_control, c, buf, i);
                 buf += 7*5;
-                buf += dv_write_pack(dv_video_source,  c, buf);
-                buf += dv_write_pack(dv_video_control, c, buf);
+                buf += dv_write_pack(dv_video_source,  c, buf, i);
+                buf += dv_write_pack(dv_video_control, c, buf, i);
                 buf += 4*5 + 2; /* unused bytes */
             }
 
@@ -1263,7 +2196,7 @@
                     buf += 77; /* audio control & shuffled PCM audio */
                 }
                 buf += dv_write_dif_id(dv_sect_video, chan, i, j, buf);
-                buf += 77; /* 1 video macroblock: 1 bytes control
+                buf += 77; /* 1 video macro block: 1 bytes control
                               4 * 14 bytes Y 8x8 data
                               10 bytes Cr 8x8 data
                               10 bytes Cb 8x8 data */
@@ -1279,17 +2212,18 @@
     DVVideoContext *s = c->priv_data;
 
     s->sys = dv_codec_profile(c);
-    if (!s->sys || buf_size < s->sys->frame_size || dv_init_dynamic_tables(s->sys))
+    if (!s->sys)
+        return -1;
+    if(buf_size < s->sys->frame_size)
         return -1;
 
-    c->pix_fmt           = s->sys->pix_fmt;
-    s->picture           = *((AVFrame *)data);
+    c->pix_fmt = s->sys->pix_fmt;
+    s->picture = *((AVFrame *)data);
     s->picture.key_frame = 1;
     s->picture.pict_type = FF_I_TYPE;
 
     s->buf = buf;
-    c->execute(c, dv_encode_video_segment, s->sys->work_chunks, NULL,
-               dv_work_pool_size(s->sys), sizeof(DVwork_chunk));
+    c->execute(c, dv_encode_mt, (void**)&dv_anchor[0], NULL, s->sys->difseg_size, sizeof(void*));
 
     emms_c();
 
@@ -1303,7 +2237,7 @@
 {
     DVVideoContext *s = c->priv_data;
 
-    if (s->picture.data[0])
+    if(s->picture.data[0])
         c->release_buffer(c, &s->picture);
 
     return 0;
@@ -1318,7 +2252,7 @@
     sizeof(DVVideoContext),
     dvvideo_init,
     dvvideo_encode_frame,
-    .pix_fmts  = (enum PixelFormat[]) {PIX_FMT_YUV411P, PIX_FMT_YUV422P, PIX_FMT_YUV420P, PIX_FMT_NONE},
+    .pix_fmts = (enum PixelFormat[]) {PIX_FMT_YUV411P, PIX_FMT_YUV422P, PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name = NULL_IF_CONFIG_SMALL("DV (Digital Video)"),
 };
 #endif // CONFIG_DVVIDEO_ENCODER
--- libavcodec/dvdata.h	2009-02-01 13:00:19.000000000 +1100
+++ ../ffmpeg-0.5-DVCPROHD/libavcodec/dvdata.h	2009-03-16 12:11:28.083444869 +1100
@@ -30,11 +30,6 @@
 #include "libavutil/rational.h"
 #include "avcodec.h"
 
-typedef struct DVwork_chunk {
-    uint16_t  buf_offset;
-    uint16_t  mb_coordinates[5];
-} DVwork_chunk;
-
 /*
  * DVprofile is used to express the differences between various
  * DV flavors. For now it's primarily used for differentiating
@@ -42,31 +37,145 @@
  * DV specs as well (e.g. SMPTE314M vs. IEC 61834).
  */
 typedef struct DVprofile {
-    int              dsf;                   /* value of the dsf in the DV header */
-    int              video_stype;           /* stype for VAUX source pack */
-    int              frame_size;            /* total size of one frame in bytes */
-    int              difseg_size;           /* number of DIF segments per DIF channel */
-    int              n_difchan;             /* number of DIF channels per frame */
-    AVRational       time_base;             /* 1/framerate */
-    int              ltc_divisor;           /* FPS from the LTS standpoint */
-    int              height;                /* picture height in pixels */
-    int              width;                 /* picture width in pixels */
-    AVRational       sar[2];                /* sample aspect ratios for 4:3 and 16:9 */
-    DVwork_chunk    *work_chunks;           /* each thread gets its own chunk of frame to work on */
-    uint32_t        *idct_factor;           /* set of iDCT factor tables */
-    enum PixelFormat pix_fmt;               /* picture pixel format */
-    int              bpm;                   /* blocks per macroblock */
-    const uint8_t   *block_sizes;           /* AC block sizes, in bits */
-    int              audio_stride;          /* size of audio_shuffle table */
-    int              audio_min_samples[3];  /* min amount of audio samples */
-                                            /* for 48kHz, 44.1kHz and 32kHz */
-    int              audio_samples_dist[5]; /* how many samples are supposed to be */
-                                            /* in each frame in a 5 frames window */
-    const uint8_t  (*audio_shuffle)[9];     /* PCM shuffling table */
+    int              dsf;                 /* value of the dsf in the DV header */
+    int              video_stype;         /* stype for VAUX source pack */
+    int              frame_size;          /* total size of one frame in bytes */
+    int              difseg_size;         /* number of DIF segments per DIF channel */
+    int              n_difchan;           /* number of DIF channels per frame */
+    int              frame_rate;
+    int              frame_rate_base;
+    int              ltc_divisor;         /* FPS from the LTS standpoint */
+    int              height;              /* picture height in pixels */
+    int              width;               /* picture width in pixels */
+    AVRational       sar[2];              /* sample aspect ratios for 4:3 and 16:9 */
+    const uint16_t  *video_place;         /* positions of all DV macro blocks XXX remove this */
+
+    /* return macroblock location, in multiples of blocks (5 macroblocks at a time, (x,y) in mbloc[]) */
+    void           (*find_macroblock)(const struct DVprofile*, int channel, int seq, int av, int seg, int mbloc[10]);
+
+    enum PixelFormat pix_fmt;             /* picture pixel format */
+    int              bpm;                 /* blocks per macroblock */
+    const uint8_t   *block_sizes;         /* AC block sizes, in bits */
+    int              vs_total_ac_bits;    /* bit budget for AC only in 5 blocks */
+
+    int              audio_stride;        /* size of audio_shuffle table */
+    int              audio_min_samples[3];/* min ammount of audio samples */
+                                          /* for 48Khz, 44.1Khz and 32Khz */
+    int              audio_samples_dist[5];/* how many samples are supposed to be */
+                                         /* in each frame in a 5 frames window */
+    const uint8_t  (*audio_shuffle)[9];  /* PCM shuffling table */
 } DVprofile;
 
 #define NB_DV_VLC 409
 
+/* maximum number of blocks per macroblock in any DV format */
+#define DV_MAX_BPM 8
+
+/* DV100 quantization tables */
+
+/* setting this to 1 results in a faster codec but
+ * somewhat lower image quality */
+#define DV100_SACRIFICE_QUALITY_FOR_SPEED 1
+
+/* quantization quanta by QNO for DV100 */
+static const uint8_t dv100_qstep[16] = {
+	1, // QNO = 0 and 1 both have no quantization
+	1,
+	2, 3, 4, 5, 6, 7, 8, 16, 18, 20, 22, 24, 28, 52
+};
+
+/* pack combination of QNO and CNO into a single 8-bit value */
+#define DV100_MAKE_QLEVEL(qno,cno) ((qno<<2) | (cno))
+#define DV100_QLEVEL_QNO(qlevel) (qlevel>>2)
+#define DV100_QLEVEL_CNO(qlevel) (qlevel&0x3)
+
+/* The quantization step is determined by a combination of QNO and
+   CNO. We refer to these combinations as "qlevels" (this term is our
+   own, it's not mentioned in the spec). We use CNO, a multiplier on
+   the quantization step, to "fill in the gaps" between quantization
+   steps associated with successive values of QNO. e.g. there is no
+   QNO for a quantization step of 10, but we can use QNO=5 CNO=1 to
+   get the same result. The table below encodes combinations of QNO
+   and CNO in order of increasing quantization coarseness. */
+
+static const uint8_t dv100_qlevels[] = {
+    DV100_MAKE_QLEVEL( 1,0), //  1*1= 1
+    DV100_MAKE_QLEVEL( 1,0), //  1*1= 1
+    DV100_MAKE_QLEVEL( 2,0), //  2*1= 2
+    DV100_MAKE_QLEVEL( 3,0), //  3*1= 3
+    DV100_MAKE_QLEVEL( 4,0), //  4*1= 4
+    DV100_MAKE_QLEVEL( 5,0), //  5*1= 5
+    DV100_MAKE_QLEVEL( 6,0), //  6*1= 6
+    DV100_MAKE_QLEVEL( 7,0), //  7*1= 7
+    DV100_MAKE_QLEVEL( 8,0), //  8*1= 8
+    DV100_MAKE_QLEVEL( 5,1), //  5*2=10
+    DV100_MAKE_QLEVEL( 6,1), //  6*2=12
+    DV100_MAKE_QLEVEL( 7,1), //  7*2=14
+    DV100_MAKE_QLEVEL( 9,0), // 16*1=16
+    DV100_MAKE_QLEVEL(10,0), // 18*1=18
+    DV100_MAKE_QLEVEL(11,0), // 20*1=20
+    DV100_MAKE_QLEVEL(12,0), // 22*1=22
+    DV100_MAKE_QLEVEL(13,0), // 24*1=24
+    DV100_MAKE_QLEVEL(14,0), // 28*1=28
+    DV100_MAKE_QLEVEL( 9,1), // 16*2=32
+    DV100_MAKE_QLEVEL(10,1), // 18*2=36
+    DV100_MAKE_QLEVEL(11,1), // 20*2=40
+    DV100_MAKE_QLEVEL(12,1), // 22*2=44
+    DV100_MAKE_QLEVEL(13,1), // 24*2=48
+    DV100_MAKE_QLEVEL(15,0), // 52*1=52
+    DV100_MAKE_QLEVEL(14,1), // 28*2=56
+    DV100_MAKE_QLEVEL( 9,2), // 16*4=64
+    DV100_MAKE_QLEVEL(10,2), // 18*4=72
+    DV100_MAKE_QLEVEL(11,2), // 20*4=80
+    DV100_MAKE_QLEVEL(12,2), // 22*4=88
+    DV100_MAKE_QLEVEL(13,2), // 24*4=96
+    // ...
+    DV100_MAKE_QLEVEL(15,3), // 52*8=416
+};
+
+static const int dv100_num_qlevels = sizeof(dv100_qlevels)/sizeof(dv100_qlevels[0]);
+
+/* how much to increase qlevel when we need to compress more coarsely */
+/* this is a tradeoff between encoding speed and space efficiency */
+/* the highest-quality, lowest-speed option it to use 1 for all qlevels. */
+static const uint8_t dv100_qstep_delta[16] = {
+#if DV100_SACRIFICE_QUALITY_FOR_SPEED
+    0, 2, 0, 5, 0, 0, 0, 0, 1, 6, 0, 0, 0, 0, 0, 0,
+#else
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+#endif
+};
+
+/* how much to decrease qlevel when we can compress more finely */
+/* must be the "inverse" of dv100_qstep_delta */
+static const uint8_t dv100_qbackstep_delta[16] = {
+#if DV100_SACRIFICE_QUALITY_FOR_SPEED
+    0, 0, 0, 2, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 0, 6,
+#else
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+#endif
+};
+
+#if DV100_SACRIFICE_QUALITY_FOR_SPEED
+static const int dv100_min_bias = 0;
+static const int dv100_chroma_bias = 0;
+static const int dv100_starting_qno = 1;
+static const int dv100_min_qno = 1;
+static const int dv100_qlevel_inc = 4;
+#else
+static const int dv100_min_bias = 0;
+static const int dv100_chroma_bias = 0;
+static const int dv100_starting_qno = 1;
+static const int dv100_min_qno = 1;
+static const int dv100_qlevel_inc = 1;
+#endif
+
+// 1/qstep, shifted up by 16 bits
+static const int dv100_qstep_bits = 16;
+static const int dv100_qstep_inv[16] = {
+	65536,  65536,  32768,  21845,  16384,  13107,  10923,  9362,  8192,  4096,  3641,  3277,  2979,  2731,  2341,  1260,
+};
+
 /*
  * There's a catch about the following three tables: the mapping they establish
  * between (run, level) and vlc is not 1-1. So you have to watch out for that
@@ -238,38 +347,38 @@
 };
 
 static const uint8_t dv_vlc_level[409] = {
-   1,   2,   1,   3,   4,   1,   2,   5,
-   6,   1,   1,   7,   8,   1,   1,   2,
-   3,   4,   9,  10,  11,   1,   1,   1,
-   1,   2,   2,   3,   5,   6,   7,  12,
-  13,  14,  15,  16,  17,   1,   1,   1,
-   1,   2,   2,   3,   3,   4,   5,   8,
-  18,  19,  20,  21,  22,   3,   4,   5,
-   6,   9,  10,  11,   0,   0,   3,   4,
-   6,  12,  13,  14,   0,   0,   0,   0,
-   2,   2,   2,   2,   3,   3,   5,   7,
-   7,   8,   9,  10,  11,  15,  16,  17,
-   0,   0,   0,   0,   0,   0,   0,   0,
-   0,   0,   0,   0,   0,   0,   0,   0,
-   0,   0,   0,   0,   0,   0,   0,   0,
-   0,   0,   0,   0,   0,   0,   0,   0,
-   0,   0,   0,   0,   0,   0,   0,   0,
-   0,   0,   0,   0,   0,   0,   0,   0,
-   0,   0,   0,   0,   0,   0,   0,   0,
-   0,   0,   0,   0,   0,   0,   0,   0,
-   0,   1,   2,   3,   4,   5,   6,   7,
-   8,   9,  10,  11,  12,  13,  14,  15,
-  16,  17,  18,  19,  20,  21,  22,  23,
-  24,  25,  26,  27,  28,  29,  30,  31,
-  32,  33,  34,  35,  36,  37,  38,  39,
-  40,  41,  42,  43,  44,  45,  46,  47,
-  48,  49,  50,  51,  52,  53,  54,  55,
-  56,  57,  58,  59,  60,  61,  62,  63,
-  64,  65,  66,  67,  68,  69,  70,  71,
-  72,  73,  74,  75,  76,  77,  78,  79,
-  80,  81,  82,  83,  84,  85,  86,  87,
-  88,  89,  90,  91,  92,  93,  94,  95,
-  96,  97,  98,  99, 100, 101, 102, 103,
+  1,  2,  1,  3,  4,  1,  2,  5,
+  6,  1,  1,  7,  8,  1,  1,  2,
+  3,  4,  9, 10, 11,  1,  1,  1,
+  1,  2,  2,  3,  5,  6,  7, 12,
+ 13, 14, 15, 16, 17,  1,  1,  1,
+  1,  2,  2,  3,  3,  4,  5,  8,
+ 18, 19, 20, 21, 22,  3,  4,  5,
+  6,  9, 10, 11,  0,  0,  3,  4,
+  6, 12, 13, 14,  0,  0,  0,  0,
+  2,  2,  2,  2,  3,  3,  5,  7,
+  7,  8,  9, 10, 11, 15, 16, 17,
+  0,  0,  0,  0,  0,  0,  0,  0,
+  0,  0,  0,  0,  0,  0,  0,  0,
+  0,  0,  0,  0,  0,  0,  0,  0,
+  0,  0,  0,  0,  0,  0,  0,  0,
+  0,  0,  0,  0,  0,  0,  0,  0,
+  0,  0,  0,  0,  0,  0,  0,  0,
+  0,  0,  0,  0,  0,  0,  0,  0,
+  0,  0,  0,  0,  0,  0,  0,  0,
+  0,  1,  2,  3,  4,  5,  6,  7,
+  8,  9, 10, 11, 12, 13, 14, 15,
+ 16, 17, 18, 19, 20, 21, 22, 23,
+ 24, 25, 26, 27, 28, 29, 30, 31,
+ 32, 33, 34, 35, 36, 37, 38, 39,
+ 40, 41, 42, 43, 44, 45, 46, 47,
+ 48, 49, 50, 51, 52, 53, 54, 55,
+ 56, 57, 58, 59, 60, 61, 62, 63,
+ 64, 65, 66, 67, 68, 69, 70, 71,
+ 72, 73, 74, 75, 76, 77, 78, 79,
+ 80, 81, 82, 83, 84, 85, 86, 87,
+ 88, 89, 90, 91, 92, 93, 94, 95,
+ 96, 97, 98, 99, 100, 101, 102, 103,
  104, 105, 106, 107, 108, 109, 110, 111,
  112, 113, 114, 115, 116, 117, 118, 119,
  120, 121, 122, 123, 124, 125, 126, 127,
@@ -289,10 +398,32 @@
  232, 233, 234, 235, 236, 237, 238, 239,
  240, 241, 242, 243, 244, 245, 246, 247,
  248, 249, 250, 251, 252, 253, 254, 255,
-   0,
+  0,
 };
 
 /* unquant tables (not used directly) */
+static const uint8_t dv_88_areas[64] = {
+    0,0,0,1,1,1,2,2,
+    0,0,1,1,1,2,2,2,
+    0,1,1,1,2,2,2,3,
+    1,1,1,2,2,2,3,3,
+    1,1,2,2,2,3,3,3,
+    1,2,2,2,3,3,3,3,
+    2,2,2,3,3,3,3,3,
+    2,2,3,3,3,3,3,3,
+};
+
+static const uint8_t dv_248_areas[64] = {
+    0,0,1,1,1,2,2,3,
+    0,0,1,1,2,2,2,3,
+    0,1,1,2,2,2,3,3,
+    0,1,1,2,2,2,3,3,
+    1,1,2,2,2,3,3,3,
+    1,1,2,2,2,3,3,3,
+    1,2,2,2,3,3,3,3,
+    1,2,2,3,3,3,3,3,
+};
+
 static const uint8_t dv_quant_shifts[22][4] = {
   { 3,3,4,4 },
   { 3,3,4,4 },
@@ -318,14 +449,2134 @@
   { 0,0,0,0 },
 };
 
-static const uint8_t dv_quant_offset[4] = { 6,  3,  0,  1 };
-static const uint8_t dv_quant_areas[4]  = { 6, 21, 43, 64 };
+static const uint8_t dv_quant_offset[4] = { 6, 3, 0, 1 };
 
-/* quantization quanta by QNO for DV100 */
-static const uint8_t dv100_qstep[16] = {
-    1, /* QNO = 0 and 1 both have no quantization */
-    1,
-    2, 3, 4, 5, 6, 7, 8, 16, 18, 20, 22, 24, 28, 52
+/* NOTE: I prefer hardcoding the positioning of dv blocks, it is
+   simpler :-) */
+
+static const uint16_t dv_place_420[1620] = {
+ 0x0c24, 0x2412, 0x3036, 0x0000, 0x1848,
+ 0x0e24, 0x2612, 0x3236, 0x0200, 0x1a48,
+ 0x1024, 0x2812, 0x3436, 0x0400, 0x1c48,
+ 0x1026, 0x2814, 0x3438, 0x0402, 0x1c4a,
+ 0x0e26, 0x2614, 0x3238, 0x0202, 0x1a4a,
+ 0x0c26, 0x2414, 0x3038, 0x0002, 0x184a,
+ 0x0c28, 0x2416, 0x303a, 0x0004, 0x184c,
+ 0x0e28, 0x2616, 0x323a, 0x0204, 0x1a4c,
+ 0x1028, 0x2816, 0x343a, 0x0404, 0x1c4c,
+ 0x102a, 0x2818, 0x343c, 0x0406, 0x1c4e,
+ 0x0e2a, 0x2618, 0x323c, 0x0206, 0x1a4e,
+ 0x0c2a, 0x2418, 0x303c, 0x0006, 0x184e,
+ 0x0c2c, 0x241a, 0x303e, 0x0008, 0x1850,
+ 0x0e2c, 0x261a, 0x323e, 0x0208, 0x1a50,
+ 0x102c, 0x281a, 0x343e, 0x0408, 0x1c50,
+ 0x102e, 0x281c, 0x3440, 0x040a, 0x1c52,
+ 0x0e2e, 0x261c, 0x3240, 0x020a, 0x1a52,
+ 0x0c2e, 0x241c, 0x3040, 0x000a, 0x1852,
+ 0x0c30, 0x241e, 0x3042, 0x000c, 0x1854,
+ 0x0e30, 0x261e, 0x3242, 0x020c, 0x1a54,
+ 0x1030, 0x281e, 0x3442, 0x040c, 0x1c54,
+ 0x1032, 0x2820, 0x3444, 0x040e, 0x1c56,
+ 0x0e32, 0x2620, 0x3244, 0x020e, 0x1a56,
+ 0x0c32, 0x2420, 0x3044, 0x000e, 0x1856,
+ 0x0c34, 0x2422, 0x3046, 0x0010, 0x1858,
+ 0x0e34, 0x2622, 0x3246, 0x0210, 0x1a58,
+ 0x1034, 0x2822, 0x3446, 0x0410, 0x1c58,
+ 0x1224, 0x2a12, 0x3636, 0x0600, 0x1e48,
+ 0x1424, 0x2c12, 0x3836, 0x0800, 0x2048,
+ 0x1624, 0x2e12, 0x3a36, 0x0a00, 0x2248,
+ 0x1626, 0x2e14, 0x3a38, 0x0a02, 0x224a,
+ 0x1426, 0x2c14, 0x3838, 0x0802, 0x204a,
+ 0x1226, 0x2a14, 0x3638, 0x0602, 0x1e4a,
+ 0x1228, 0x2a16, 0x363a, 0x0604, 0x1e4c,
+ 0x1428, 0x2c16, 0x383a, 0x0804, 0x204c,
+ 0x1628, 0x2e16, 0x3a3a, 0x0a04, 0x224c,
+ 0x162a, 0x2e18, 0x3a3c, 0x0a06, 0x224e,
+ 0x142a, 0x2c18, 0x383c, 0x0806, 0x204e,
+ 0x122a, 0x2a18, 0x363c, 0x0606, 0x1e4e,
+ 0x122c, 0x2a1a, 0x363e, 0x0608, 0x1e50,
+ 0x142c, 0x2c1a, 0x383e, 0x0808, 0x2050,
+ 0x162c, 0x2e1a, 0x3a3e, 0x0a08, 0x2250,
+ 0x162e, 0x2e1c, 0x3a40, 0x0a0a, 0x2252,
+ 0x142e, 0x2c1c, 0x3840, 0x080a, 0x2052,
+ 0x122e, 0x2a1c, 0x3640, 0x060a, 0x1e52,
+ 0x1230, 0x2a1e, 0x3642, 0x060c, 0x1e54,
+ 0x1430, 0x2c1e, 0x3842, 0x080c, 0x2054,
+ 0x1630, 0x2e1e, 0x3a42, 0x0a0c, 0x2254,
+ 0x1632, 0x2e20, 0x3a44, 0x0a0e, 0x2256,
+ 0x1432, 0x2c20, 0x3844, 0x080e, 0x2056,
+ 0x1232, 0x2a20, 0x3644, 0x060e, 0x1e56,
+ 0x1234, 0x2a22, 0x3646, 0x0610, 0x1e58,
+ 0x1434, 0x2c22, 0x3846, 0x0810, 0x2058,
+ 0x1634, 0x2e22, 0x3a46, 0x0a10, 0x2258,
+ 0x1824, 0x3012, 0x3c36, 0x0c00, 0x2448,
+ 0x1a24, 0x3212, 0x3e36, 0x0e00, 0x2648,
+ 0x1c24, 0x3412, 0x4036, 0x1000, 0x2848,
+ 0x1c26, 0x3414, 0x4038, 0x1002, 0x284a,
+ 0x1a26, 0x3214, 0x3e38, 0x0e02, 0x264a,
+ 0x1826, 0x3014, 0x3c38, 0x0c02, 0x244a,
+ 0x1828, 0x3016, 0x3c3a, 0x0c04, 0x244c,
+ 0x1a28, 0x3216, 0x3e3a, 0x0e04, 0x264c,
+ 0x1c28, 0x3416, 0x403a, 0x1004, 0x284c,
+ 0x1c2a, 0x3418, 0x403c, 0x1006, 0x284e,
+ 0x1a2a, 0x3218, 0x3e3c, 0x0e06, 0x264e,
+ 0x182a, 0x3018, 0x3c3c, 0x0c06, 0x244e,
+ 0x182c, 0x301a, 0x3c3e, 0x0c08, 0x2450,
+ 0x1a2c, 0x321a, 0x3e3e, 0x0e08, 0x2650,
+ 0x1c2c, 0x341a, 0x403e, 0x1008, 0x2850,
+ 0x1c2e, 0x341c, 0x4040, 0x100a, 0x2852,
+ 0x1a2e, 0x321c, 0x3e40, 0x0e0a, 0x2652,
+ 0x182e, 0x301c, 0x3c40, 0x0c0a, 0x2452,
+ 0x1830, 0x301e, 0x3c42, 0x0c0c, 0x2454,
+ 0x1a30, 0x321e, 0x3e42, 0x0e0c, 0x2654,
+ 0x1c30, 0x341e, 0x4042, 0x100c, 0x2854,
+ 0x1c32, 0x3420, 0x4044, 0x100e, 0x2856,
+ 0x1a32, 0x3220, 0x3e44, 0x0e0e, 0x2656,
+ 0x1832, 0x3020, 0x3c44, 0x0c0e, 0x2456,
+ 0x1834, 0x3022, 0x3c46, 0x0c10, 0x2458,
+ 0x1a34, 0x3222, 0x3e46, 0x0e10, 0x2658,
+ 0x1c34, 0x3422, 0x4046, 0x1010, 0x2858,
+ 0x1e24, 0x3612, 0x4236, 0x1200, 0x2a48,
+ 0x2024, 0x3812, 0x4436, 0x1400, 0x2c48,
+ 0x2224, 0x3a12, 0x4636, 0x1600, 0x2e48,
+ 0x2226, 0x3a14, 0x4638, 0x1602, 0x2e4a,
+ 0x2026, 0x3814, 0x4438, 0x1402, 0x2c4a,
+ 0x1e26, 0x3614, 0x4238, 0x1202, 0x2a4a,
+ 0x1e28, 0x3616, 0x423a, 0x1204, 0x2a4c,
+ 0x2028, 0x3816, 0x443a, 0x1404, 0x2c4c,
+ 0x2228, 0x3a16, 0x463a, 0x1604, 0x2e4c,
+ 0x222a, 0x3a18, 0x463c, 0x1606, 0x2e4e,
+ 0x202a, 0x3818, 0x443c, 0x1406, 0x2c4e,
+ 0x1e2a, 0x3618, 0x423c, 0x1206, 0x2a4e,
+ 0x1e2c, 0x361a, 0x423e, 0x1208, 0x2a50,
+ 0x202c, 0x381a, 0x443e, 0x1408, 0x2c50,
+ 0x222c, 0x3a1a, 0x463e, 0x1608, 0x2e50,
+ 0x222e, 0x3a1c, 0x4640, 0x160a, 0x2e52,
+ 0x202e, 0x381c, 0x4440, 0x140a, 0x2c52,
+ 0x1e2e, 0x361c, 0x4240, 0x120a, 0x2a52,
+ 0x1e30, 0x361e, 0x4242, 0x120c, 0x2a54,
+ 0x2030, 0x381e, 0x4442, 0x140c, 0x2c54,
+ 0x2230, 0x3a1e, 0x4642, 0x160c, 0x2e54,
+ 0x2232, 0x3a20, 0x4644, 0x160e, 0x2e56,
+ 0x2032, 0x3820, 0x4444, 0x140e, 0x2c56,
+ 0x1e32, 0x3620, 0x4244, 0x120e, 0x2a56,
+ 0x1e34, 0x3622, 0x4246, 0x1210, 0x2a58,
+ 0x2034, 0x3822, 0x4446, 0x1410, 0x2c58,
+ 0x2234, 0x3a22, 0x4646, 0x1610, 0x2e58,
+ 0x2424, 0x3c12, 0x0036, 0x1800, 0x3048,
+ 0x2624, 0x3e12, 0x0236, 0x1a00, 0x3248,
+ 0x2824, 0x4012, 0x0436, 0x1c00, 0x3448,
+ 0x2826, 0x4014, 0x0438, 0x1c02, 0x344a,
+ 0x2626, 0x3e14, 0x0238, 0x1a02, 0x324a,
+ 0x2426, 0x3c14, 0x0038, 0x1802, 0x304a,
+ 0x2428, 0x3c16, 0x003a, 0x1804, 0x304c,
+ 0x2628, 0x3e16, 0x023a, 0x1a04, 0x324c,
+ 0x2828, 0x4016, 0x043a, 0x1c04, 0x344c,
+ 0x282a, 0x4018, 0x043c, 0x1c06, 0x344e,
+ 0x262a, 0x3e18, 0x023c, 0x1a06, 0x324e,
+ 0x242a, 0x3c18, 0x003c, 0x1806, 0x304e,
+ 0x242c, 0x3c1a, 0x003e, 0x1808, 0x3050,
+ 0x262c, 0x3e1a, 0x023e, 0x1a08, 0x3250,
+ 0x282c, 0x401a, 0x043e, 0x1c08, 0x3450,
+ 0x282e, 0x401c, 0x0440, 0x1c0a, 0x3452,
+ 0x262e, 0x3e1c, 0x0240, 0x1a0a, 0x3252,
+ 0x242e, 0x3c1c, 0x0040, 0x180a, 0x3052,
+ 0x2430, 0x3c1e, 0x0042, 0x180c, 0x3054,
+ 0x2630, 0x3e1e, 0x0242, 0x1a0c, 0x3254,
+ 0x2830, 0x401e, 0x0442, 0x1c0c, 0x3454,
+ 0x2832, 0x4020, 0x0444, 0x1c0e, 0x3456,
+ 0x2632, 0x3e20, 0x0244, 0x1a0e, 0x3256,
+ 0x2432, 0x3c20, 0x0044, 0x180e, 0x3056,
+ 0x2434, 0x3c22, 0x0046, 0x1810, 0x3058,
+ 0x2634, 0x3e22, 0x0246, 0x1a10, 0x3258,
+ 0x2834, 0x4022, 0x0446, 0x1c10, 0x3458,
+ 0x2a24, 0x4212, 0x0636, 0x1e00, 0x3648,
+ 0x2c24, 0x4412, 0x0836, 0x2000, 0x3848,
+ 0x2e24, 0x4612, 0x0a36, 0x2200, 0x3a48,
+ 0x2e26, 0x4614, 0x0a38, 0x2202, 0x3a4a,
+ 0x2c26, 0x4414, 0x0838, 0x2002, 0x384a,
+ 0x2a26, 0x4214, 0x0638, 0x1e02, 0x364a,
+ 0x2a28, 0x4216, 0x063a, 0x1e04, 0x364c,
+ 0x2c28, 0x4416, 0x083a, 0x2004, 0x384c,
+ 0x2e28, 0x4616, 0x0a3a, 0x2204, 0x3a4c,
+ 0x2e2a, 0x4618, 0x0a3c, 0x2206, 0x3a4e,
+ 0x2c2a, 0x4418, 0x083c, 0x2006, 0x384e,
+ 0x2a2a, 0x4218, 0x063c, 0x1e06, 0x364e,
+ 0x2a2c, 0x421a, 0x063e, 0x1e08, 0x3650,
+ 0x2c2c, 0x441a, 0x083e, 0x2008, 0x3850,
+ 0x2e2c, 0x461a, 0x0a3e, 0x2208, 0x3a50,
+ 0x2e2e, 0x461c, 0x0a40, 0x220a, 0x3a52,
+ 0x2c2e, 0x441c, 0x0840, 0x200a, 0x3852,
+ 0x2a2e, 0x421c, 0x0640, 0x1e0a, 0x3652,
+ 0x2a30, 0x421e, 0x0642, 0x1e0c, 0x3654,
+ 0x2c30, 0x441e, 0x0842, 0x200c, 0x3854,
+ 0x2e30, 0x461e, 0x0a42, 0x220c, 0x3a54,
+ 0x2e32, 0x4620, 0x0a44, 0x220e, 0x3a56,
+ 0x2c32, 0x4420, 0x0844, 0x200e, 0x3856,
+ 0x2a32, 0x4220, 0x0644, 0x1e0e, 0x3656,
+ 0x2a34, 0x4222, 0x0646, 0x1e10, 0x3658,
+ 0x2c34, 0x4422, 0x0846, 0x2010, 0x3858,
+ 0x2e34, 0x4622, 0x0a46, 0x2210, 0x3a58,
+ 0x3024, 0x0012, 0x0c36, 0x2400, 0x3c48,
+ 0x3224, 0x0212, 0x0e36, 0x2600, 0x3e48,
+ 0x3424, 0x0412, 0x1036, 0x2800, 0x4048,
+ 0x3426, 0x0414, 0x1038, 0x2802, 0x404a,
+ 0x3226, 0x0214, 0x0e38, 0x2602, 0x3e4a,
+ 0x3026, 0x0014, 0x0c38, 0x2402, 0x3c4a,
+ 0x3028, 0x0016, 0x0c3a, 0x2404, 0x3c4c,
+ 0x3228, 0x0216, 0x0e3a, 0x2604, 0x3e4c,
+ 0x3428, 0x0416, 0x103a, 0x2804, 0x404c,
+ 0x342a, 0x0418, 0x103c, 0x2806, 0x404e,
+ 0x322a, 0x0218, 0x0e3c, 0x2606, 0x3e4e,
+ 0x302a, 0x0018, 0x0c3c, 0x2406, 0x3c4e,
+ 0x302c, 0x001a, 0x0c3e, 0x2408, 0x3c50,
+ 0x322c, 0x021a, 0x0e3e, 0x2608, 0x3e50,
+ 0x342c, 0x041a, 0x103e, 0x2808, 0x4050,
+ 0x342e, 0x041c, 0x1040, 0x280a, 0x4052,
+ 0x322e, 0x021c, 0x0e40, 0x260a, 0x3e52,
+ 0x302e, 0x001c, 0x0c40, 0x240a, 0x3c52,
+ 0x3030, 0x001e, 0x0c42, 0x240c, 0x3c54,
+ 0x3230, 0x021e, 0x0e42, 0x260c, 0x3e54,
+ 0x3430, 0x041e, 0x1042, 0x280c, 0x4054,
+ 0x3432, 0x0420, 0x1044, 0x280e, 0x4056,
+ 0x3232, 0x0220, 0x0e44, 0x260e, 0x3e56,
+ 0x3032, 0x0020, 0x0c44, 0x240e, 0x3c56,
+ 0x3034, 0x0022, 0x0c46, 0x2410, 0x3c58,
+ 0x3234, 0x0222, 0x0e46, 0x2610, 0x3e58,
+ 0x3434, 0x0422, 0x1046, 0x2810, 0x4058,
+ 0x3624, 0x0612, 0x1236, 0x2a00, 0x4248,
+ 0x3824, 0x0812, 0x1436, 0x2c00, 0x4448,
+ 0x3a24, 0x0a12, 0x1636, 0x2e00, 0x4648,
+ 0x3a26, 0x0a14, 0x1638, 0x2e02, 0x464a,
+ 0x3826, 0x0814, 0x1438, 0x2c02, 0x444a,
+ 0x3626, 0x0614, 0x1238, 0x2a02, 0x424a,
+ 0x3628, 0x0616, 0x123a, 0x2a04, 0x424c,
+ 0x3828, 0x0816, 0x143a, 0x2c04, 0x444c,
+ 0x3a28, 0x0a16, 0x163a, 0x2e04, 0x464c,
+ 0x3a2a, 0x0a18, 0x163c, 0x2e06, 0x464e,
+ 0x382a, 0x0818, 0x143c, 0x2c06, 0x444e,
+ 0x362a, 0x0618, 0x123c, 0x2a06, 0x424e,
+ 0x362c, 0x061a, 0x123e, 0x2a08, 0x4250,
+ 0x382c, 0x081a, 0x143e, 0x2c08, 0x4450,
+ 0x3a2c, 0x0a1a, 0x163e, 0x2e08, 0x4650,
+ 0x3a2e, 0x0a1c, 0x1640, 0x2e0a, 0x4652,
+ 0x382e, 0x081c, 0x1440, 0x2c0a, 0x4452,
+ 0x362e, 0x061c, 0x1240, 0x2a0a, 0x4252,
+ 0x3630, 0x061e, 0x1242, 0x2a0c, 0x4254,
+ 0x3830, 0x081e, 0x1442, 0x2c0c, 0x4454,
+ 0x3a30, 0x0a1e, 0x1642, 0x2e0c, 0x4654,
+ 0x3a32, 0x0a20, 0x1644, 0x2e0e, 0x4656,
+ 0x3832, 0x0820, 0x1444, 0x2c0e, 0x4456,
+ 0x3632, 0x0620, 0x1244, 0x2a0e, 0x4256,
+ 0x3634, 0x0622, 0x1246, 0x2a10, 0x4258,
+ 0x3834, 0x0822, 0x1446, 0x2c10, 0x4458,
+ 0x3a34, 0x0a22, 0x1646, 0x2e10, 0x4658,
+ 0x3c24, 0x0c12, 0x1836, 0x3000, 0x0048,
+ 0x3e24, 0x0e12, 0x1a36, 0x3200, 0x0248,
+ 0x4024, 0x1012, 0x1c36, 0x3400, 0x0448,
+ 0x4026, 0x1014, 0x1c38, 0x3402, 0x044a,
+ 0x3e26, 0x0e14, 0x1a38, 0x3202, 0x024a,
+ 0x3c26, 0x0c14, 0x1838, 0x3002, 0x004a,
+ 0x3c28, 0x0c16, 0x183a, 0x3004, 0x004c,
+ 0x3e28, 0x0e16, 0x1a3a, 0x3204, 0x024c,
+ 0x4028, 0x1016, 0x1c3a, 0x3404, 0x044c,
+ 0x402a, 0x1018, 0x1c3c, 0x3406, 0x044e,
+ 0x3e2a, 0x0e18, 0x1a3c, 0x3206, 0x024e,
+ 0x3c2a, 0x0c18, 0x183c, 0x3006, 0x004e,
+ 0x3c2c, 0x0c1a, 0x183e, 0x3008, 0x0050,
+ 0x3e2c, 0x0e1a, 0x1a3e, 0x3208, 0x0250,
+ 0x402c, 0x101a, 0x1c3e, 0x3408, 0x0450,
+ 0x402e, 0x101c, 0x1c40, 0x340a, 0x0452,
+ 0x3e2e, 0x0e1c, 0x1a40, 0x320a, 0x0252,
+ 0x3c2e, 0x0c1c, 0x1840, 0x300a, 0x0052,
+ 0x3c30, 0x0c1e, 0x1842, 0x300c, 0x0054,
+ 0x3e30, 0x0e1e, 0x1a42, 0x320c, 0x0254,
+ 0x4030, 0x101e, 0x1c42, 0x340c, 0x0454,
+ 0x4032, 0x1020, 0x1c44, 0x340e, 0x0456,
+ 0x3e32, 0x0e20, 0x1a44, 0x320e, 0x0256,
+ 0x3c32, 0x0c20, 0x1844, 0x300e, 0x0056,
+ 0x3c34, 0x0c22, 0x1846, 0x3010, 0x0058,
+ 0x3e34, 0x0e22, 0x1a46, 0x3210, 0x0258,
+ 0x4034, 0x1022, 0x1c46, 0x3410, 0x0458,
+ 0x4224, 0x1212, 0x1e36, 0x3600, 0x0648,
+ 0x4424, 0x1412, 0x2036, 0x3800, 0x0848,
+ 0x4624, 0x1612, 0x2236, 0x3a00, 0x0a48,
+ 0x4626, 0x1614, 0x2238, 0x3a02, 0x0a4a,
+ 0x4426, 0x1414, 0x2038, 0x3802, 0x084a,
+ 0x4226, 0x1214, 0x1e38, 0x3602, 0x064a,
+ 0x4228, 0x1216, 0x1e3a, 0x3604, 0x064c,
+ 0x4428, 0x1416, 0x203a, 0x3804, 0x084c,
+ 0x4628, 0x1616, 0x223a, 0x3a04, 0x0a4c,
+ 0x462a, 0x1618, 0x223c, 0x3a06, 0x0a4e,
+ 0x442a, 0x1418, 0x203c, 0x3806, 0x084e,
+ 0x422a, 0x1218, 0x1e3c, 0x3606, 0x064e,
+ 0x422c, 0x121a, 0x1e3e, 0x3608, 0x0650,
+ 0x442c, 0x141a, 0x203e, 0x3808, 0x0850,
+ 0x462c, 0x161a, 0x223e, 0x3a08, 0x0a50,
+ 0x462e, 0x161c, 0x2240, 0x3a0a, 0x0a52,
+ 0x442e, 0x141c, 0x2040, 0x380a, 0x0852,
+ 0x422e, 0x121c, 0x1e40, 0x360a, 0x0652,
+ 0x4230, 0x121e, 0x1e42, 0x360c, 0x0654,
+ 0x4430, 0x141e, 0x2042, 0x380c, 0x0854,
+ 0x4630, 0x161e, 0x2242, 0x3a0c, 0x0a54,
+ 0x4632, 0x1620, 0x2244, 0x3a0e, 0x0a56,
+ 0x4432, 0x1420, 0x2044, 0x380e, 0x0856,
+ 0x4232, 0x1220, 0x1e44, 0x360e, 0x0656,
+ 0x4234, 0x1222, 0x1e46, 0x3610, 0x0658,
+ 0x4434, 0x1422, 0x2046, 0x3810, 0x0858,
+ 0x4634, 0x1622, 0x2246, 0x3a10, 0x0a58,
+ 0x0024, 0x1812, 0x2436, 0x3c00, 0x0c48,
+ 0x0224, 0x1a12, 0x2636, 0x3e00, 0x0e48,
+ 0x0424, 0x1c12, 0x2836, 0x4000, 0x1048,
+ 0x0426, 0x1c14, 0x2838, 0x4002, 0x104a,
+ 0x0226, 0x1a14, 0x2638, 0x3e02, 0x0e4a,
+ 0x0026, 0x1814, 0x2438, 0x3c02, 0x0c4a,
+ 0x0028, 0x1816, 0x243a, 0x3c04, 0x0c4c,
+ 0x0228, 0x1a16, 0x263a, 0x3e04, 0x0e4c,
+ 0x0428, 0x1c16, 0x283a, 0x4004, 0x104c,
+ 0x042a, 0x1c18, 0x283c, 0x4006, 0x104e,
+ 0x022a, 0x1a18, 0x263c, 0x3e06, 0x0e4e,
+ 0x002a, 0x1818, 0x243c, 0x3c06, 0x0c4e,
+ 0x002c, 0x181a, 0x243e, 0x3c08, 0x0c50,
+ 0x022c, 0x1a1a, 0x263e, 0x3e08, 0x0e50,
+ 0x042c, 0x1c1a, 0x283e, 0x4008, 0x1050,
+ 0x042e, 0x1c1c, 0x2840, 0x400a, 0x1052,
+ 0x022e, 0x1a1c, 0x2640, 0x3e0a, 0x0e52,
+ 0x002e, 0x181c, 0x2440, 0x3c0a, 0x0c52,
+ 0x0030, 0x181e, 0x2442, 0x3c0c, 0x0c54,
+ 0x0230, 0x1a1e, 0x2642, 0x3e0c, 0x0e54,
+ 0x0430, 0x1c1e, 0x2842, 0x400c, 0x1054,
+ 0x0432, 0x1c20, 0x2844, 0x400e, 0x1056,
+ 0x0232, 0x1a20, 0x2644, 0x3e0e, 0x0e56,
+ 0x0032, 0x1820, 0x2444, 0x3c0e, 0x0c56,
+ 0x0034, 0x1822, 0x2446, 0x3c10, 0x0c58,
+ 0x0234, 0x1a22, 0x2646, 0x3e10, 0x0e58,
+ 0x0434, 0x1c22, 0x2846, 0x4010, 0x1058,
+ 0x0624, 0x1e12, 0x2a36, 0x4200, 0x1248,
+ 0x0824, 0x2012, 0x2c36, 0x4400, 0x1448,
+ 0x0a24, 0x2212, 0x2e36, 0x4600, 0x1648,
+ 0x0a26, 0x2214, 0x2e38, 0x4602, 0x164a,
+ 0x0826, 0x2014, 0x2c38, 0x4402, 0x144a,
+ 0x0626, 0x1e14, 0x2a38, 0x4202, 0x124a,
+ 0x0628, 0x1e16, 0x2a3a, 0x4204, 0x124c,
+ 0x0828, 0x2016, 0x2c3a, 0x4404, 0x144c,
+ 0x0a28, 0x2216, 0x2e3a, 0x4604, 0x164c,
+ 0x0a2a, 0x2218, 0x2e3c, 0x4606, 0x164e,
+ 0x082a, 0x2018, 0x2c3c, 0x4406, 0x144e,
+ 0x062a, 0x1e18, 0x2a3c, 0x4206, 0x124e,
+ 0x062c, 0x1e1a, 0x2a3e, 0x4208, 0x1250,
+ 0x082c, 0x201a, 0x2c3e, 0x4408, 0x1450,
+ 0x0a2c, 0x221a, 0x2e3e, 0x4608, 0x1650,
+ 0x0a2e, 0x221c, 0x2e40, 0x460a, 0x1652,
+ 0x082e, 0x201c, 0x2c40, 0x440a, 0x1452,
+ 0x062e, 0x1e1c, 0x2a40, 0x420a, 0x1252,
+ 0x0630, 0x1e1e, 0x2a42, 0x420c, 0x1254,
+ 0x0830, 0x201e, 0x2c42, 0x440c, 0x1454,
+ 0x0a30, 0x221e, 0x2e42, 0x460c, 0x1654,
+ 0x0a32, 0x2220, 0x2e44, 0x460e, 0x1656,
+ 0x0832, 0x2020, 0x2c44, 0x440e, 0x1456,
+ 0x0632, 0x1e20, 0x2a44, 0x420e, 0x1256,
+ 0x0634, 0x1e22, 0x2a46, 0x4210, 0x1258,
+ 0x0834, 0x2022, 0x2c46, 0x4410, 0x1458,
+ 0x0a34, 0x2222, 0x2e46, 0x4610, 0x1658,
+};
+
+static const uint16_t dv_place_411P[1620] = {
+ 0x0c24, 0x2710, 0x3334, 0x0000, 0x1848,
+ 0x0d24, 0x2810, 0x3434, 0x0100, 0x1948,
+ 0x0e24, 0x2910, 0x3534, 0x0200, 0x1a48,
+ 0x0f24, 0x2914, 0x3538, 0x0300, 0x1b48,
+ 0x1024, 0x2814, 0x3438, 0x0400, 0x1c48,
+ 0x1124, 0x2714, 0x3338, 0x0500, 0x1d48,
+ 0x1128, 0x2614, 0x3238, 0x0504, 0x1d4c,
+ 0x1028, 0x2514, 0x3138, 0x0404, 0x1c4c,
+ 0x0f28, 0x2414, 0x3038, 0x0304, 0x1b4c,
+ 0x0e28, 0x2418, 0x303c, 0x0204, 0x1a4c,
+ 0x0d28, 0x2518, 0x313c, 0x0104, 0x194c,
+ 0x0c28, 0x2618, 0x323c, 0x0004, 0x184c,
+ 0x0c2c, 0x2718, 0x333c, 0x0008, 0x1850,
+ 0x0d2c, 0x2818, 0x343c, 0x0108, 0x1950,
+ 0x0e2c, 0x2918, 0x353c, 0x0208, 0x1a50,
+ 0x0f2c, 0x291c, 0x3540, 0x0308, 0x1b50,
+ 0x102c, 0x281c, 0x3440, 0x0408, 0x1c50,
+ 0x112c, 0x271c, 0x3340, 0x0508, 0x1d50,
+ 0x1130, 0x261c, 0x3240, 0x050c, 0x1d54,
+ 0x1030, 0x251c, 0x3140, 0x040c, 0x1c54,
+ 0x0f30, 0x241c, 0x3040, 0x030c, 0x1b54,
+ 0x0e30, 0x2420, 0x3044, 0x020c, 0x1a54,
+ 0x0d30, 0x2520, 0x3144, 0x010c, 0x1954,
+ 0x0c30, 0x2620, 0x3244, 0x000c, 0x1854,
+ 0x0c34, 0x2720, 0x3344, 0x0010, 0x1858,
+ 0x0d34, 0x2820, 0x3444, 0x0110, 0x1a58,
+ 0x0e34, 0x2920, 0x3544, 0x0210, 0x1c58,
+ 0x1224, 0x2d10, 0x3934, 0x0600, 0x1e48,
+ 0x1324, 0x2e10, 0x3a34, 0x0700, 0x1f48,
+ 0x1424, 0x2f10, 0x3b34, 0x0800, 0x2048,
+ 0x1524, 0x2f14, 0x3b38, 0x0900, 0x2148,
+ 0x1624, 0x2e14, 0x3a38, 0x0a00, 0x2248,
+ 0x1724, 0x2d14, 0x3938, 0x0b00, 0x2348,
+ 0x1728, 0x2c14, 0x3838, 0x0b04, 0x234c,
+ 0x1628, 0x2b14, 0x3738, 0x0a04, 0x224c,
+ 0x1528, 0x2a14, 0x3638, 0x0904, 0x214c,
+ 0x1428, 0x2a18, 0x363c, 0x0804, 0x204c,
+ 0x1328, 0x2b18, 0x373c, 0x0704, 0x1f4c,
+ 0x1228, 0x2c18, 0x383c, 0x0604, 0x1e4c,
+ 0x122c, 0x2d18, 0x393c, 0x0608, 0x1e50,
+ 0x132c, 0x2e18, 0x3a3c, 0x0708, 0x1f50,
+ 0x142c, 0x2f18, 0x3b3c, 0x0808, 0x2050,
+ 0x152c, 0x2f1c, 0x3b40, 0x0908, 0x2150,
+ 0x162c, 0x2e1c, 0x3a40, 0x0a08, 0x2250,
+ 0x172c, 0x2d1c, 0x3940, 0x0b08, 0x2350,
+ 0x1730, 0x2c1c, 0x3840, 0x0b0c, 0x2354,
+ 0x1630, 0x2b1c, 0x3740, 0x0a0c, 0x2254,
+ 0x1530, 0x2a1c, 0x3640, 0x090c, 0x2154,
+ 0x1430, 0x2a20, 0x3644, 0x080c, 0x2054,
+ 0x1330, 0x2b20, 0x3744, 0x070c, 0x1f54,
+ 0x1230, 0x2c20, 0x3844, 0x060c, 0x1e54,
+ 0x1234, 0x2d20, 0x3944, 0x0610, 0x1e58,
+ 0x1334, 0x2e20, 0x3a44, 0x0710, 0x2058,
+ 0x1434, 0x2f20, 0x3b44, 0x0810, 0x2258,
+ 0x1824, 0x3310, 0x3f34, 0x0c00, 0x2448,
+ 0x1924, 0x3410, 0x4034, 0x0d00, 0x2548,
+ 0x1a24, 0x3510, 0x4134, 0x0e00, 0x2648,
+ 0x1b24, 0x3514, 0x4138, 0x0f00, 0x2748,
+ 0x1c24, 0x3414, 0x4038, 0x1000, 0x2848,
+ 0x1d24, 0x3314, 0x3f38, 0x1100, 0x2948,
+ 0x1d28, 0x3214, 0x3e38, 0x1104, 0x294c,
+ 0x1c28, 0x3114, 0x3d38, 0x1004, 0x284c,
+ 0x1b28, 0x3014, 0x3c38, 0x0f04, 0x274c,
+ 0x1a28, 0x3018, 0x3c3c, 0x0e04, 0x264c,
+ 0x1928, 0x3118, 0x3d3c, 0x0d04, 0x254c,
+ 0x1828, 0x3218, 0x3e3c, 0x0c04, 0x244c,
+ 0x182c, 0x3318, 0x3f3c, 0x0c08, 0x2450,
+ 0x192c, 0x3418, 0x403c, 0x0d08, 0x2550,
+ 0x1a2c, 0x3518, 0x413c, 0x0e08, 0x2650,
+ 0x1b2c, 0x351c, 0x4140, 0x0f08, 0x2750,
+ 0x1c2c, 0x341c, 0x4040, 0x1008, 0x2850,
+ 0x1d2c, 0x331c, 0x3f40, 0x1108, 0x2950,
+ 0x1d30, 0x321c, 0x3e40, 0x110c, 0x2954,
+ 0x1c30, 0x311c, 0x3d40, 0x100c, 0x2854,
+ 0x1b30, 0x301c, 0x3c40, 0x0f0c, 0x2754,
+ 0x1a30, 0x3020, 0x3c44, 0x0e0c, 0x2654,
+ 0x1930, 0x3120, 0x3d44, 0x0d0c, 0x2554,
+ 0x1830, 0x3220, 0x3e44, 0x0c0c, 0x2454,
+ 0x1834, 0x3320, 0x3f44, 0x0c10, 0x2458,
+ 0x1934, 0x3420, 0x4044, 0x0d10, 0x2658,
+ 0x1a34, 0x3520, 0x4144, 0x0e10, 0x2858,
+ 0x1e24, 0x3910, 0x4534, 0x1200, 0x2a48,
+ 0x1f24, 0x3a10, 0x4634, 0x1300, 0x2b48,
+ 0x2024, 0x3b10, 0x4734, 0x1400, 0x2c48,
+ 0x2124, 0x3b14, 0x4738, 0x1500, 0x2d48,
+ 0x2224, 0x3a14, 0x4638, 0x1600, 0x2e48,
+ 0x2324, 0x3914, 0x4538, 0x1700, 0x2f48,
+ 0x2328, 0x3814, 0x4438, 0x1704, 0x2f4c,
+ 0x2228, 0x3714, 0x4338, 0x1604, 0x2e4c,
+ 0x2128, 0x3614, 0x4238, 0x1504, 0x2d4c,
+ 0x2028, 0x3618, 0x423c, 0x1404, 0x2c4c,
+ 0x1f28, 0x3718, 0x433c, 0x1304, 0x2b4c,
+ 0x1e28, 0x3818, 0x443c, 0x1204, 0x2a4c,
+ 0x1e2c, 0x3918, 0x453c, 0x1208, 0x2a50,
+ 0x1f2c, 0x3a18, 0x463c, 0x1308, 0x2b50,
+ 0x202c, 0x3b18, 0x473c, 0x1408, 0x2c50,
+ 0x212c, 0x3b1c, 0x4740, 0x1508, 0x2d50,
+ 0x222c, 0x3a1c, 0x4640, 0x1608, 0x2e50,
+ 0x232c, 0x391c, 0x4540, 0x1708, 0x2f50,
+ 0x2330, 0x381c, 0x4440, 0x170c, 0x2f54,
+ 0x2230, 0x371c, 0x4340, 0x160c, 0x2e54,
+ 0x2130, 0x361c, 0x4240, 0x150c, 0x2d54,
+ 0x2030, 0x3620, 0x4244, 0x140c, 0x2c54,
+ 0x1f30, 0x3720, 0x4344, 0x130c, 0x2b54,
+ 0x1e30, 0x3820, 0x4444, 0x120c, 0x2a54,
+ 0x1e34, 0x3920, 0x4544, 0x1210, 0x2a58,
+ 0x1f34, 0x3a20, 0x4644, 0x1310, 0x2c58,
+ 0x2034, 0x3b20, 0x4744, 0x1410, 0x2e58,
+ 0x2424, 0x3f10, 0x0334, 0x1800, 0x3048,
+ 0x2524, 0x4010, 0x0434, 0x1900, 0x3148,
+ 0x2624, 0x4110, 0x0534, 0x1a00, 0x3248,
+ 0x2724, 0x4114, 0x0538, 0x1b00, 0x3348,
+ 0x2824, 0x4014, 0x0438, 0x1c00, 0x3448,
+ 0x2924, 0x3f14, 0x0338, 0x1d00, 0x3548,
+ 0x2928, 0x3e14, 0x0238, 0x1d04, 0x354c,
+ 0x2828, 0x3d14, 0x0138, 0x1c04, 0x344c,
+ 0x2728, 0x3c14, 0x0038, 0x1b04, 0x334c,
+ 0x2628, 0x3c18, 0x003c, 0x1a04, 0x324c,
+ 0x2528, 0x3d18, 0x013c, 0x1904, 0x314c,
+ 0x2428, 0x3e18, 0x023c, 0x1804, 0x304c,
+ 0x242c, 0x3f18, 0x033c, 0x1808, 0x3050,
+ 0x252c, 0x4018, 0x043c, 0x1908, 0x3150,
+ 0x262c, 0x4118, 0x053c, 0x1a08, 0x3250,
+ 0x272c, 0x411c, 0x0540, 0x1b08, 0x3350,
+ 0x282c, 0x401c, 0x0440, 0x1c08, 0x3450,
+ 0x292c, 0x3f1c, 0x0340, 0x1d08, 0x3550,
+ 0x2930, 0x3e1c, 0x0240, 0x1d0c, 0x3554,
+ 0x2830, 0x3d1c, 0x0140, 0x1c0c, 0x3454,
+ 0x2730, 0x3c1c, 0x0040, 0x1b0c, 0x3354,
+ 0x2630, 0x3c20, 0x0044, 0x1a0c, 0x3254,
+ 0x2530, 0x3d20, 0x0144, 0x190c, 0x3154,
+ 0x2430, 0x3e20, 0x0244, 0x180c, 0x3054,
+ 0x2434, 0x3f20, 0x0344, 0x1810, 0x3058,
+ 0x2534, 0x4020, 0x0444, 0x1910, 0x3258,
+ 0x2634, 0x4120, 0x0544, 0x1a10, 0x3458,
+ 0x2a24, 0x4510, 0x0934, 0x1e00, 0x3648,
+ 0x2b24, 0x4610, 0x0a34, 0x1f00, 0x3748,
+ 0x2c24, 0x4710, 0x0b34, 0x2000, 0x3848,
+ 0x2d24, 0x4714, 0x0b38, 0x2100, 0x3948,
+ 0x2e24, 0x4614, 0x0a38, 0x2200, 0x3a48,
+ 0x2f24, 0x4514, 0x0938, 0x2300, 0x3b48,
+ 0x2f28, 0x4414, 0x0838, 0x2304, 0x3b4c,
+ 0x2e28, 0x4314, 0x0738, 0x2204, 0x3a4c,
+ 0x2d28, 0x4214, 0x0638, 0x2104, 0x394c,
+ 0x2c28, 0x4218, 0x063c, 0x2004, 0x384c,
+ 0x2b28, 0x4318, 0x073c, 0x1f04, 0x374c,
+ 0x2a28, 0x4418, 0x083c, 0x1e04, 0x364c,
+ 0x2a2c, 0x4518, 0x093c, 0x1e08, 0x3650,
+ 0x2b2c, 0x4618, 0x0a3c, 0x1f08, 0x3750,
+ 0x2c2c, 0x4718, 0x0b3c, 0x2008, 0x3850,
+ 0x2d2c, 0x471c, 0x0b40, 0x2108, 0x3950,
+ 0x2e2c, 0x461c, 0x0a40, 0x2208, 0x3a50,
+ 0x2f2c, 0x451c, 0x0940, 0x2308, 0x3b50,
+ 0x2f30, 0x441c, 0x0840, 0x230c, 0x3b54,
+ 0x2e30, 0x431c, 0x0740, 0x220c, 0x3a54,
+ 0x2d30, 0x421c, 0x0640, 0x210c, 0x3954,
+ 0x2c30, 0x4220, 0x0644, 0x200c, 0x3854,
+ 0x2b30, 0x4320, 0x0744, 0x1f0c, 0x3754,
+ 0x2a30, 0x4420, 0x0844, 0x1e0c, 0x3654,
+ 0x2a34, 0x4520, 0x0944, 0x1e10, 0x3658,
+ 0x2b34, 0x4620, 0x0a44, 0x1f10, 0x3858,
+ 0x2c34, 0x4720, 0x0b44, 0x2010, 0x3a58,
+ 0x3024, 0x0310, 0x0f34, 0x2400, 0x3c48,
+ 0x3124, 0x0410, 0x1034, 0x2500, 0x3d48,
+ 0x3224, 0x0510, 0x1134, 0x2600, 0x3e48,
+ 0x3324, 0x0514, 0x1138, 0x2700, 0x3f48,
+ 0x3424, 0x0414, 0x1038, 0x2800, 0x4048,
+ 0x3524, 0x0314, 0x0f38, 0x2900, 0x4148,
+ 0x3528, 0x0214, 0x0e38, 0x2904, 0x414c,
+ 0x3428, 0x0114, 0x0d38, 0x2804, 0x404c,
+ 0x3328, 0x0014, 0x0c38, 0x2704, 0x3f4c,
+ 0x3228, 0x0018, 0x0c3c, 0x2604, 0x3e4c,
+ 0x3128, 0x0118, 0x0d3c, 0x2504, 0x3d4c,
+ 0x3028, 0x0218, 0x0e3c, 0x2404, 0x3c4c,
+ 0x302c, 0x0318, 0x0f3c, 0x2408, 0x3c50,
+ 0x312c, 0x0418, 0x103c, 0x2508, 0x3d50,
+ 0x322c, 0x0518, 0x113c, 0x2608, 0x3e50,
+ 0x332c, 0x051c, 0x1140, 0x2708, 0x3f50,
+ 0x342c, 0x041c, 0x1040, 0x2808, 0x4050,
+ 0x352c, 0x031c, 0x0f40, 0x2908, 0x4150,
+ 0x3530, 0x021c, 0x0e40, 0x290c, 0x4154,
+ 0x3430, 0x011c, 0x0d40, 0x280c, 0x4054,
+ 0x3330, 0x001c, 0x0c40, 0x270c, 0x3f54,
+ 0x3230, 0x0020, 0x0c44, 0x260c, 0x3e54,
+ 0x3130, 0x0120, 0x0d44, 0x250c, 0x3d54,
+ 0x3030, 0x0220, 0x0e44, 0x240c, 0x3c54,
+ 0x3034, 0x0320, 0x0f44, 0x2410, 0x3c58,
+ 0x3134, 0x0420, 0x1044, 0x2510, 0x3e58,
+ 0x3234, 0x0520, 0x1144, 0x2610, 0x4058,
+ 0x3624, 0x0910, 0x1534, 0x2a00, 0x4248,
+ 0x3724, 0x0a10, 0x1634, 0x2b00, 0x4348,
+ 0x3824, 0x0b10, 0x1734, 0x2c00, 0x4448,
+ 0x3924, 0x0b14, 0x1738, 0x2d00, 0x4548,
+ 0x3a24, 0x0a14, 0x1638, 0x2e00, 0x4648,
+ 0x3b24, 0x0914, 0x1538, 0x2f00, 0x4748,
+ 0x3b28, 0x0814, 0x1438, 0x2f04, 0x474c,
+ 0x3a28, 0x0714, 0x1338, 0x2e04, 0x464c,
+ 0x3928, 0x0614, 0x1238, 0x2d04, 0x454c,
+ 0x3828, 0x0618, 0x123c, 0x2c04, 0x444c,
+ 0x3728, 0x0718, 0x133c, 0x2b04, 0x434c,
+ 0x3628, 0x0818, 0x143c, 0x2a04, 0x424c,
+ 0x362c, 0x0918, 0x153c, 0x2a08, 0x4250,
+ 0x372c, 0x0a18, 0x163c, 0x2b08, 0x4350,
+ 0x382c, 0x0b18, 0x173c, 0x2c08, 0x4450,
+ 0x392c, 0x0b1c, 0x1740, 0x2d08, 0x4550,
+ 0x3a2c, 0x0a1c, 0x1640, 0x2e08, 0x4650,
+ 0x3b2c, 0x091c, 0x1540, 0x2f08, 0x4750,
+ 0x3b30, 0x081c, 0x1440, 0x2f0c, 0x4754,
+ 0x3a30, 0x071c, 0x1340, 0x2e0c, 0x4654,
+ 0x3930, 0x061c, 0x1240, 0x2d0c, 0x4554,
+ 0x3830, 0x0620, 0x1244, 0x2c0c, 0x4454,
+ 0x3730, 0x0720, 0x1344, 0x2b0c, 0x4354,
+ 0x3630, 0x0820, 0x1444, 0x2a0c, 0x4254,
+ 0x3634, 0x0920, 0x1544, 0x2a10, 0x4258,
+ 0x3734, 0x0a20, 0x1644, 0x2b10, 0x4458,
+ 0x3834, 0x0b20, 0x1744, 0x2c10, 0x4658,
+ 0x3c24, 0x0f10, 0x1b34, 0x3000, 0x0048,
+ 0x3d24, 0x1010, 0x1c34, 0x3100, 0x0148,
+ 0x3e24, 0x1110, 0x1d34, 0x3200, 0x0248,
+ 0x3f24, 0x1114, 0x1d38, 0x3300, 0x0348,
+ 0x4024, 0x1014, 0x1c38, 0x3400, 0x0448,
+ 0x4124, 0x0f14, 0x1b38, 0x3500, 0x0548,
+ 0x4128, 0x0e14, 0x1a38, 0x3504, 0x054c,
+ 0x4028, 0x0d14, 0x1938, 0x3404, 0x044c,
+ 0x3f28, 0x0c14, 0x1838, 0x3304, 0x034c,
+ 0x3e28, 0x0c18, 0x183c, 0x3204, 0x024c,
+ 0x3d28, 0x0d18, 0x193c, 0x3104, 0x014c,
+ 0x3c28, 0x0e18, 0x1a3c, 0x3004, 0x004c,
+ 0x3c2c, 0x0f18, 0x1b3c, 0x3008, 0x0050,
+ 0x3d2c, 0x1018, 0x1c3c, 0x3108, 0x0150,
+ 0x3e2c, 0x1118, 0x1d3c, 0x3208, 0x0250,
+ 0x3f2c, 0x111c, 0x1d40, 0x3308, 0x0350,
+ 0x402c, 0x101c, 0x1c40, 0x3408, 0x0450,
+ 0x412c, 0x0f1c, 0x1b40, 0x3508, 0x0550,
+ 0x4130, 0x0e1c, 0x1a40, 0x350c, 0x0554,
+ 0x4030, 0x0d1c, 0x1940, 0x340c, 0x0454,
+ 0x3f30, 0x0c1c, 0x1840, 0x330c, 0x0354,
+ 0x3e30, 0x0c20, 0x1844, 0x320c, 0x0254,
+ 0x3d30, 0x0d20, 0x1944, 0x310c, 0x0154,
+ 0x3c30, 0x0e20, 0x1a44, 0x300c, 0x0054,
+ 0x3c34, 0x0f20, 0x1b44, 0x3010, 0x0058,
+ 0x3d34, 0x1020, 0x1c44, 0x3110, 0x0258,
+ 0x3e34, 0x1120, 0x1d44, 0x3210, 0x0458,
+ 0x4224, 0x1510, 0x2134, 0x3600, 0x0648,
+ 0x4324, 0x1610, 0x2234, 0x3700, 0x0748,
+ 0x4424, 0x1710, 0x2334, 0x3800, 0x0848,
+ 0x4524, 0x1714, 0x2338, 0x3900, 0x0948,
+ 0x4624, 0x1614, 0x2238, 0x3a00, 0x0a48,
+ 0x4724, 0x1514, 0x2138, 0x3b00, 0x0b48,
+ 0x4728, 0x1414, 0x2038, 0x3b04, 0x0b4c,
+ 0x4628, 0x1314, 0x1f38, 0x3a04, 0x0a4c,
+ 0x4528, 0x1214, 0x1e38, 0x3904, 0x094c,
+ 0x4428, 0x1218, 0x1e3c, 0x3804, 0x084c,
+ 0x4328, 0x1318, 0x1f3c, 0x3704, 0x074c,
+ 0x4228, 0x1418, 0x203c, 0x3604, 0x064c,
+ 0x422c, 0x1518, 0x213c, 0x3608, 0x0650,
+ 0x432c, 0x1618, 0x223c, 0x3708, 0x0750,
+ 0x442c, 0x1718, 0x233c, 0x3808, 0x0850,
+ 0x452c, 0x171c, 0x2340, 0x3908, 0x0950,
+ 0x462c, 0x161c, 0x2240, 0x3a08, 0x0a50,
+ 0x472c, 0x151c, 0x2140, 0x3b08, 0x0b50,
+ 0x4730, 0x141c, 0x2040, 0x3b0c, 0x0b54,
+ 0x4630, 0x131c, 0x1f40, 0x3a0c, 0x0a54,
+ 0x4530, 0x121c, 0x1e40, 0x390c, 0x0954,
+ 0x4430, 0x1220, 0x1e44, 0x380c, 0x0854,
+ 0x4330, 0x1320, 0x1f44, 0x370c, 0x0754,
+ 0x4230, 0x1420, 0x2044, 0x360c, 0x0654,
+ 0x4234, 0x1520, 0x2144, 0x3610, 0x0658,
+ 0x4334, 0x1620, 0x2244, 0x3710, 0x0858,
+ 0x4434, 0x1720, 0x2344, 0x3810, 0x0a58,
+ 0x0024, 0x1b10, 0x2734, 0x3c00, 0x0c48,
+ 0x0124, 0x1c10, 0x2834, 0x3d00, 0x0d48,
+ 0x0224, 0x1d10, 0x2934, 0x3e00, 0x0e48,
+ 0x0324, 0x1d14, 0x2938, 0x3f00, 0x0f48,
+ 0x0424, 0x1c14, 0x2838, 0x4000, 0x1048,
+ 0x0524, 0x1b14, 0x2738, 0x4100, 0x1148,
+ 0x0528, 0x1a14, 0x2638, 0x4104, 0x114c,
+ 0x0428, 0x1914, 0x2538, 0x4004, 0x104c,
+ 0x0328, 0x1814, 0x2438, 0x3f04, 0x0f4c,
+ 0x0228, 0x1818, 0x243c, 0x3e04, 0x0e4c,
+ 0x0128, 0x1918, 0x253c, 0x3d04, 0x0d4c,
+ 0x0028, 0x1a18, 0x263c, 0x3c04, 0x0c4c,
+ 0x002c, 0x1b18, 0x273c, 0x3c08, 0x0c50,
+ 0x012c, 0x1c18, 0x283c, 0x3d08, 0x0d50,
+ 0x022c, 0x1d18, 0x293c, 0x3e08, 0x0e50,
+ 0x032c, 0x1d1c, 0x2940, 0x3f08, 0x0f50,
+ 0x042c, 0x1c1c, 0x2840, 0x4008, 0x1050,
+ 0x052c, 0x1b1c, 0x2740, 0x4108, 0x1150,
+ 0x0530, 0x1a1c, 0x2640, 0x410c, 0x1154,
+ 0x0430, 0x191c, 0x2540, 0x400c, 0x1054,
+ 0x0330, 0x181c, 0x2440, 0x3f0c, 0x0f54,
+ 0x0230, 0x1820, 0x2444, 0x3e0c, 0x0e54,
+ 0x0130, 0x1920, 0x2544, 0x3d0c, 0x0d54,
+ 0x0030, 0x1a20, 0x2644, 0x3c0c, 0x0c54,
+ 0x0034, 0x1b20, 0x2744, 0x3c10, 0x0c58,
+ 0x0134, 0x1c20, 0x2844, 0x3d10, 0x0e58,
+ 0x0234, 0x1d20, 0x2944, 0x3e10, 0x1058,
+ 0x0624, 0x2110, 0x2d34, 0x4200, 0x1248,
+ 0x0724, 0x2210, 0x2e34, 0x4300, 0x1348,
+ 0x0824, 0x2310, 0x2f34, 0x4400, 0x1448,
+ 0x0924, 0x2314, 0x2f38, 0x4500, 0x1548,
+ 0x0a24, 0x2214, 0x2e38, 0x4600, 0x1648,
+ 0x0b24, 0x2114, 0x2d38, 0x4700, 0x1748,
+ 0x0b28, 0x2014, 0x2c38, 0x4704, 0x174c,
+ 0x0a28, 0x1f14, 0x2b38, 0x4604, 0x164c,
+ 0x0928, 0x1e14, 0x2a38, 0x4504, 0x154c,
+ 0x0828, 0x1e18, 0x2a3c, 0x4404, 0x144c,
+ 0x0728, 0x1f18, 0x2b3c, 0x4304, 0x134c,
+ 0x0628, 0x2018, 0x2c3c, 0x4204, 0x124c,
+ 0x062c, 0x2118, 0x2d3c, 0x4208, 0x1250,
+ 0x072c, 0x2218, 0x2e3c, 0x4308, 0x1350,
+ 0x082c, 0x2318, 0x2f3c, 0x4408, 0x1450,
+ 0x092c, 0x231c, 0x2f40, 0x4508, 0x1550,
+ 0x0a2c, 0x221c, 0x2e40, 0x4608, 0x1650,
+ 0x0b2c, 0x211c, 0x2d40, 0x4708, 0x1750,
+ 0x0b30, 0x201c, 0x2c40, 0x470c, 0x1754,
+ 0x0a30, 0x1f1c, 0x2b40, 0x460c, 0x1654,
+ 0x0930, 0x1e1c, 0x2a40, 0x450c, 0x1554,
+ 0x0830, 0x1e20, 0x2a44, 0x440c, 0x1454,
+ 0x0730, 0x1f20, 0x2b44, 0x430c, 0x1354,
+ 0x0630, 0x2020, 0x2c44, 0x420c, 0x1254,
+ 0x0634, 0x2120, 0x2d44, 0x4210, 0x1258,
+ 0x0734, 0x2220, 0x2e44, 0x4310, 0x1458,
+ 0x0834, 0x2320, 0x2f44, 0x4410, 0x1658,
+};
+
+static const uint16_t dv_place_411[1350] = {
+ 0x0c24, 0x2710, 0x3334, 0x0000, 0x1848,
+ 0x0d24, 0x2810, 0x3434, 0x0100, 0x1948,
+ 0x0e24, 0x2910, 0x3534, 0x0200, 0x1a48,
+ 0x0f24, 0x2914, 0x3538, 0x0300, 0x1b48,
+ 0x1024, 0x2814, 0x3438, 0x0400, 0x1c48,
+ 0x1124, 0x2714, 0x3338, 0x0500, 0x1d48,
+ 0x1128, 0x2614, 0x3238, 0x0504, 0x1d4c,
+ 0x1028, 0x2514, 0x3138, 0x0404, 0x1c4c,
+ 0x0f28, 0x2414, 0x3038, 0x0304, 0x1b4c,
+ 0x0e28, 0x2418, 0x303c, 0x0204, 0x1a4c,
+ 0x0d28, 0x2518, 0x313c, 0x0104, 0x194c,
+ 0x0c28, 0x2618, 0x323c, 0x0004, 0x184c,
+ 0x0c2c, 0x2718, 0x333c, 0x0008, 0x1850,
+ 0x0d2c, 0x2818, 0x343c, 0x0108, 0x1950,
+ 0x0e2c, 0x2918, 0x353c, 0x0208, 0x1a50,
+ 0x0f2c, 0x291c, 0x3540, 0x0308, 0x1b50,
+ 0x102c, 0x281c, 0x3440, 0x0408, 0x1c50,
+ 0x112c, 0x271c, 0x3340, 0x0508, 0x1d50,
+ 0x1130, 0x261c, 0x3240, 0x050c, 0x1d54,
+ 0x1030, 0x251c, 0x3140, 0x040c, 0x1c54,
+ 0x0f30, 0x241c, 0x3040, 0x030c, 0x1b54,
+ 0x0e30, 0x2420, 0x3044, 0x020c, 0x1a54,
+ 0x0d30, 0x2520, 0x3144, 0x010c, 0x1954,
+ 0x0c30, 0x2620, 0x3244, 0x000c, 0x1854,
+ 0x0c34, 0x2720, 0x3344, 0x0010, 0x1858,
+ 0x0d34, 0x2820, 0x3444, 0x0110, 0x1a58,
+ 0x0e34, 0x2920, 0x3544, 0x0210, 0x1c58,
+ 0x1224, 0x2d10, 0x3934, 0x0600, 0x1e48,
+ 0x1324, 0x2e10, 0x3a34, 0x0700, 0x1f48,
+ 0x1424, 0x2f10, 0x3b34, 0x0800, 0x2048,
+ 0x1524, 0x2f14, 0x3b38, 0x0900, 0x2148,
+ 0x1624, 0x2e14, 0x3a38, 0x0a00, 0x2248,
+ 0x1724, 0x2d14, 0x3938, 0x0b00, 0x2348,
+ 0x1728, 0x2c14, 0x3838, 0x0b04, 0x234c,
+ 0x1628, 0x2b14, 0x3738, 0x0a04, 0x224c,
+ 0x1528, 0x2a14, 0x3638, 0x0904, 0x214c,
+ 0x1428, 0x2a18, 0x363c, 0x0804, 0x204c,
+ 0x1328, 0x2b18, 0x373c, 0x0704, 0x1f4c,
+ 0x1228, 0x2c18, 0x383c, 0x0604, 0x1e4c,
+ 0x122c, 0x2d18, 0x393c, 0x0608, 0x1e50,
+ 0x132c, 0x2e18, 0x3a3c, 0x0708, 0x1f50,
+ 0x142c, 0x2f18, 0x3b3c, 0x0808, 0x2050,
+ 0x152c, 0x2f1c, 0x3b40, 0x0908, 0x2150,
+ 0x162c, 0x2e1c, 0x3a40, 0x0a08, 0x2250,
+ 0x172c, 0x2d1c, 0x3940, 0x0b08, 0x2350,
+ 0x1730, 0x2c1c, 0x3840, 0x0b0c, 0x2354,
+ 0x1630, 0x2b1c, 0x3740, 0x0a0c, 0x2254,
+ 0x1530, 0x2a1c, 0x3640, 0x090c, 0x2154,
+ 0x1430, 0x2a20, 0x3644, 0x080c, 0x2054,
+ 0x1330, 0x2b20, 0x3744, 0x070c, 0x1f54,
+ 0x1230, 0x2c20, 0x3844, 0x060c, 0x1e54,
+ 0x1234, 0x2d20, 0x3944, 0x0610, 0x1e58,
+ 0x1334, 0x2e20, 0x3a44, 0x0710, 0x2058,
+ 0x1434, 0x2f20, 0x3b44, 0x0810, 0x2258,
+ 0x1824, 0x3310, 0x0334, 0x0c00, 0x2448,
+ 0x1924, 0x3410, 0x0434, 0x0d00, 0x2548,
+ 0x1a24, 0x3510, 0x0534, 0x0e00, 0x2648,
+ 0x1b24, 0x3514, 0x0538, 0x0f00, 0x2748,
+ 0x1c24, 0x3414, 0x0438, 0x1000, 0x2848,
+ 0x1d24, 0x3314, 0x0338, 0x1100, 0x2948,
+ 0x1d28, 0x3214, 0x0238, 0x1104, 0x294c,
+ 0x1c28, 0x3114, 0x0138, 0x1004, 0x284c,
+ 0x1b28, 0x3014, 0x0038, 0x0f04, 0x274c,
+ 0x1a28, 0x3018, 0x003c, 0x0e04, 0x264c,
+ 0x1928, 0x3118, 0x013c, 0x0d04, 0x254c,
+ 0x1828, 0x3218, 0x023c, 0x0c04, 0x244c,
+ 0x182c, 0x3318, 0x033c, 0x0c08, 0x2450,
+ 0x192c, 0x3418, 0x043c, 0x0d08, 0x2550,
+ 0x1a2c, 0x3518, 0x053c, 0x0e08, 0x2650,
+ 0x1b2c, 0x351c, 0x0540, 0x0f08, 0x2750,
+ 0x1c2c, 0x341c, 0x0440, 0x1008, 0x2850,
+ 0x1d2c, 0x331c, 0x0340, 0x1108, 0x2950,
+ 0x1d30, 0x321c, 0x0240, 0x110c, 0x2954,
+ 0x1c30, 0x311c, 0x0140, 0x100c, 0x2854,
+ 0x1b30, 0x301c, 0x0040, 0x0f0c, 0x2754,
+ 0x1a30, 0x3020, 0x0044, 0x0e0c, 0x2654,
+ 0x1930, 0x3120, 0x0144, 0x0d0c, 0x2554,
+ 0x1830, 0x3220, 0x0244, 0x0c0c, 0x2454,
+ 0x1834, 0x3320, 0x0344, 0x0c10, 0x2458,
+ 0x1934, 0x3420, 0x0444, 0x0d10, 0x2658,
+ 0x1a34, 0x3520, 0x0544, 0x0e10, 0x2858,
+ 0x1e24, 0x3910, 0x0934, 0x1200, 0x2a48,
+ 0x1f24, 0x3a10, 0x0a34, 0x1300, 0x2b48,
+ 0x2024, 0x3b10, 0x0b34, 0x1400, 0x2c48,
+ 0x2124, 0x3b14, 0x0b38, 0x1500, 0x2d48,
+ 0x2224, 0x3a14, 0x0a38, 0x1600, 0x2e48,
+ 0x2324, 0x3914, 0x0938, 0x1700, 0x2f48,
+ 0x2328, 0x3814, 0x0838, 0x1704, 0x2f4c,
+ 0x2228, 0x3714, 0x0738, 0x1604, 0x2e4c,
+ 0x2128, 0x3614, 0x0638, 0x1504, 0x2d4c,
+ 0x2028, 0x3618, 0x063c, 0x1404, 0x2c4c,
+ 0x1f28, 0x3718, 0x073c, 0x1304, 0x2b4c,
+ 0x1e28, 0x3818, 0x083c, 0x1204, 0x2a4c,
+ 0x1e2c, 0x3918, 0x093c, 0x1208, 0x2a50,
+ 0x1f2c, 0x3a18, 0x0a3c, 0x1308, 0x2b50,
+ 0x202c, 0x3b18, 0x0b3c, 0x1408, 0x2c50,
+ 0x212c, 0x3b1c, 0x0b40, 0x1508, 0x2d50,
+ 0x222c, 0x3a1c, 0x0a40, 0x1608, 0x2e50,
+ 0x232c, 0x391c, 0x0940, 0x1708, 0x2f50,
+ 0x2330, 0x381c, 0x0840, 0x170c, 0x2f54,
+ 0x2230, 0x371c, 0x0740, 0x160c, 0x2e54,
+ 0x2130, 0x361c, 0x0640, 0x150c, 0x2d54,
+ 0x2030, 0x3620, 0x0644, 0x140c, 0x2c54,
+ 0x1f30, 0x3720, 0x0744, 0x130c, 0x2b54,
+ 0x1e30, 0x3820, 0x0844, 0x120c, 0x2a54,
+ 0x1e34, 0x3920, 0x0944, 0x1210, 0x2a58,
+ 0x1f34, 0x3a20, 0x0a44, 0x1310, 0x2c58,
+ 0x2034, 0x3b20, 0x0b44, 0x1410, 0x2e58,
+ 0x2424, 0x0310, 0x0f34, 0x1800, 0x3048,
+ 0x2524, 0x0410, 0x1034, 0x1900, 0x3148,
+ 0x2624, 0x0510, 0x1134, 0x1a00, 0x3248,
+ 0x2724, 0x0514, 0x1138, 0x1b00, 0x3348,
+ 0x2824, 0x0414, 0x1038, 0x1c00, 0x3448,
+ 0x2924, 0x0314, 0x0f38, 0x1d00, 0x3548,
+ 0x2928, 0x0214, 0x0e38, 0x1d04, 0x354c,
+ 0x2828, 0x0114, 0x0d38, 0x1c04, 0x344c,
+ 0x2728, 0x0014, 0x0c38, 0x1b04, 0x334c,
+ 0x2628, 0x0018, 0x0c3c, 0x1a04, 0x324c,
+ 0x2528, 0x0118, 0x0d3c, 0x1904, 0x314c,
+ 0x2428, 0x0218, 0x0e3c, 0x1804, 0x304c,
+ 0x242c, 0x0318, 0x0f3c, 0x1808, 0x3050,
+ 0x252c, 0x0418, 0x103c, 0x1908, 0x3150,
+ 0x262c, 0x0518, 0x113c, 0x1a08, 0x3250,
+ 0x272c, 0x051c, 0x1140, 0x1b08, 0x3350,
+ 0x282c, 0x041c, 0x1040, 0x1c08, 0x3450,
+ 0x292c, 0x031c, 0x0f40, 0x1d08, 0x3550,
+ 0x2930, 0x021c, 0x0e40, 0x1d0c, 0x3554,
+ 0x2830, 0x011c, 0x0d40, 0x1c0c, 0x3454,
+ 0x2730, 0x001c, 0x0c40, 0x1b0c, 0x3354,
+ 0x2630, 0x0020, 0x0c44, 0x1a0c, 0x3254,
+ 0x2530, 0x0120, 0x0d44, 0x190c, 0x3154,
+ 0x2430, 0x0220, 0x0e44, 0x180c, 0x3054,
+ 0x2434, 0x0320, 0x0f44, 0x1810, 0x3058,
+ 0x2534, 0x0420, 0x1044, 0x1910, 0x3258,
+ 0x2634, 0x0520, 0x1144, 0x1a10, 0x3458,
+ 0x2a24, 0x0910, 0x1534, 0x1e00, 0x3648,
+ 0x2b24, 0x0a10, 0x1634, 0x1f00, 0x3748,
+ 0x2c24, 0x0b10, 0x1734, 0x2000, 0x3848,
+ 0x2d24, 0x0b14, 0x1738, 0x2100, 0x3948,
+ 0x2e24, 0x0a14, 0x1638, 0x2200, 0x3a48,
+ 0x2f24, 0x0914, 0x1538, 0x2300, 0x3b48,
+ 0x2f28, 0x0814, 0x1438, 0x2304, 0x3b4c,
+ 0x2e28, 0x0714, 0x1338, 0x2204, 0x3a4c,
+ 0x2d28, 0x0614, 0x1238, 0x2104, 0x394c,
+ 0x2c28, 0x0618, 0x123c, 0x2004, 0x384c,
+ 0x2b28, 0x0718, 0x133c, 0x1f04, 0x374c,
+ 0x2a28, 0x0818, 0x143c, 0x1e04, 0x364c,
+ 0x2a2c, 0x0918, 0x153c, 0x1e08, 0x3650,
+ 0x2b2c, 0x0a18, 0x163c, 0x1f08, 0x3750,
+ 0x2c2c, 0x0b18, 0x173c, 0x2008, 0x3850,
+ 0x2d2c, 0x0b1c, 0x1740, 0x2108, 0x3950,
+ 0x2e2c, 0x0a1c, 0x1640, 0x2208, 0x3a50,
+ 0x2f2c, 0x091c, 0x1540, 0x2308, 0x3b50,
+ 0x2f30, 0x081c, 0x1440, 0x230c, 0x3b54,
+ 0x2e30, 0x071c, 0x1340, 0x220c, 0x3a54,
+ 0x2d30, 0x061c, 0x1240, 0x210c, 0x3954,
+ 0x2c30, 0x0620, 0x1244, 0x200c, 0x3854,
+ 0x2b30, 0x0720, 0x1344, 0x1f0c, 0x3754,
+ 0x2a30, 0x0820, 0x1444, 0x1e0c, 0x3654,
+ 0x2a34, 0x0920, 0x1544, 0x1e10, 0x3658,
+ 0x2b34, 0x0a20, 0x1644, 0x1f10, 0x3858,
+ 0x2c34, 0x0b20, 0x1744, 0x2010, 0x3a58,
+ 0x3024, 0x0f10, 0x1b34, 0x2400, 0x0048,
+ 0x3124, 0x1010, 0x1c34, 0x2500, 0x0148,
+ 0x3224, 0x1110, 0x1d34, 0x2600, 0x0248,
+ 0x3324, 0x1114, 0x1d38, 0x2700, 0x0348,
+ 0x3424, 0x1014, 0x1c38, 0x2800, 0x0448,
+ 0x3524, 0x0f14, 0x1b38, 0x2900, 0x0548,
+ 0x3528, 0x0e14, 0x1a38, 0x2904, 0x054c,
+ 0x3428, 0x0d14, 0x1938, 0x2804, 0x044c,
+ 0x3328, 0x0c14, 0x1838, 0x2704, 0x034c,
+ 0x3228, 0x0c18, 0x183c, 0x2604, 0x024c,
+ 0x3128, 0x0d18, 0x193c, 0x2504, 0x014c,
+ 0x3028, 0x0e18, 0x1a3c, 0x2404, 0x004c,
+ 0x302c, 0x0f18, 0x1b3c, 0x2408, 0x0050,
+ 0x312c, 0x1018, 0x1c3c, 0x2508, 0x0150,
+ 0x322c, 0x1118, 0x1d3c, 0x2608, 0x0250,
+ 0x332c, 0x111c, 0x1d40, 0x2708, 0x0350,
+ 0x342c, 0x101c, 0x1c40, 0x2808, 0x0450,
+ 0x352c, 0x0f1c, 0x1b40, 0x2908, 0x0550,
+ 0x3530, 0x0e1c, 0x1a40, 0x290c, 0x0554,
+ 0x3430, 0x0d1c, 0x1940, 0x280c, 0x0454,
+ 0x3330, 0x0c1c, 0x1840, 0x270c, 0x0354,
+ 0x3230, 0x0c20, 0x1844, 0x260c, 0x0254,
+ 0x3130, 0x0d20, 0x1944, 0x250c, 0x0154,
+ 0x3030, 0x0e20, 0x1a44, 0x240c, 0x0054,
+ 0x3034, 0x0f20, 0x1b44, 0x2410, 0x0058,
+ 0x3134, 0x1020, 0x1c44, 0x2510, 0x0258,
+ 0x3234, 0x1120, 0x1d44, 0x2610, 0x0458,
+ 0x3624, 0x1510, 0x2134, 0x2a00, 0x0648,
+ 0x3724, 0x1610, 0x2234, 0x2b00, 0x0748,
+ 0x3824, 0x1710, 0x2334, 0x2c00, 0x0848,
+ 0x3924, 0x1714, 0x2338, 0x2d00, 0x0948,
+ 0x3a24, 0x1614, 0x2238, 0x2e00, 0x0a48,
+ 0x3b24, 0x1514, 0x2138, 0x2f00, 0x0b48,
+ 0x3b28, 0x1414, 0x2038, 0x2f04, 0x0b4c,
+ 0x3a28, 0x1314, 0x1f38, 0x2e04, 0x0a4c,
+ 0x3928, 0x1214, 0x1e38, 0x2d04, 0x094c,
+ 0x3828, 0x1218, 0x1e3c, 0x2c04, 0x084c,
+ 0x3728, 0x1318, 0x1f3c, 0x2b04, 0x074c,
+ 0x3628, 0x1418, 0x203c, 0x2a04, 0x064c,
+ 0x362c, 0x1518, 0x213c, 0x2a08, 0x0650,
+ 0x372c, 0x1618, 0x223c, 0x2b08, 0x0750,
+ 0x382c, 0x1718, 0x233c, 0x2c08, 0x0850,
+ 0x392c, 0x171c, 0x2340, 0x2d08, 0x0950,
+ 0x3a2c, 0x161c, 0x2240, 0x2e08, 0x0a50,
+ 0x3b2c, 0x151c, 0x2140, 0x2f08, 0x0b50,
+ 0x3b30, 0x141c, 0x2040, 0x2f0c, 0x0b54,
+ 0x3a30, 0x131c, 0x1f40, 0x2e0c, 0x0a54,
+ 0x3930, 0x121c, 0x1e40, 0x2d0c, 0x0954,
+ 0x3830, 0x1220, 0x1e44, 0x2c0c, 0x0854,
+ 0x3730, 0x1320, 0x1f44, 0x2b0c, 0x0754,
+ 0x3630, 0x1420, 0x2044, 0x2a0c, 0x0654,
+ 0x3634, 0x1520, 0x2144, 0x2a10, 0x0658,
+ 0x3734, 0x1620, 0x2244, 0x2b10, 0x0858,
+ 0x3834, 0x1720, 0x2344, 0x2c10, 0x0a58,
+ 0x0024, 0x1b10, 0x2734, 0x3000, 0x0c48,
+ 0x0124, 0x1c10, 0x2834, 0x3100, 0x0d48,
+ 0x0224, 0x1d10, 0x2934, 0x3200, 0x0e48,
+ 0x0324, 0x1d14, 0x2938, 0x3300, 0x0f48,
+ 0x0424, 0x1c14, 0x2838, 0x3400, 0x1048,
+ 0x0524, 0x1b14, 0x2738, 0x3500, 0x1148,
+ 0x0528, 0x1a14, 0x2638, 0x3504, 0x114c,
+ 0x0428, 0x1914, 0x2538, 0x3404, 0x104c,
+ 0x0328, 0x1814, 0x2438, 0x3304, 0x0f4c,
+ 0x0228, 0x1818, 0x243c, 0x3204, 0x0e4c,
+ 0x0128, 0x1918, 0x253c, 0x3104, 0x0d4c,
+ 0x0028, 0x1a18, 0x263c, 0x3004, 0x0c4c,
+ 0x002c, 0x1b18, 0x273c, 0x3008, 0x0c50,
+ 0x012c, 0x1c18, 0x283c, 0x3108, 0x0d50,
+ 0x022c, 0x1d18, 0x293c, 0x3208, 0x0e50,
+ 0x032c, 0x1d1c, 0x2940, 0x3308, 0x0f50,
+ 0x042c, 0x1c1c, 0x2840, 0x3408, 0x1050,
+ 0x052c, 0x1b1c, 0x2740, 0x3508, 0x1150,
+ 0x0530, 0x1a1c, 0x2640, 0x350c, 0x1154,
+ 0x0430, 0x191c, 0x2540, 0x340c, 0x1054,
+ 0x0330, 0x181c, 0x2440, 0x330c, 0x0f54,
+ 0x0230, 0x1820, 0x2444, 0x320c, 0x0e54,
+ 0x0130, 0x1920, 0x2544, 0x310c, 0x0d54,
+ 0x0030, 0x1a20, 0x2644, 0x300c, 0x0c54,
+ 0x0034, 0x1b20, 0x2744, 0x3010, 0x0c58,
+ 0x0134, 0x1c20, 0x2844, 0x3110, 0x0e58,
+ 0x0234, 0x1d20, 0x2944, 0x3210, 0x1058,
+ 0x0624, 0x2110, 0x2d34, 0x3600, 0x1248,
+ 0x0724, 0x2210, 0x2e34, 0x3700, 0x1348,
+ 0x0824, 0x2310, 0x2f34, 0x3800, 0x1448,
+ 0x0924, 0x2314, 0x2f38, 0x3900, 0x1548,
+ 0x0a24, 0x2214, 0x2e38, 0x3a00, 0x1648,
+ 0x0b24, 0x2114, 0x2d38, 0x3b00, 0x1748,
+ 0x0b28, 0x2014, 0x2c38, 0x3b04, 0x174c,
+ 0x0a28, 0x1f14, 0x2b38, 0x3a04, 0x164c,
+ 0x0928, 0x1e14, 0x2a38, 0x3904, 0x154c,
+ 0x0828, 0x1e18, 0x2a3c, 0x3804, 0x144c,
+ 0x0728, 0x1f18, 0x2b3c, 0x3704, 0x134c,
+ 0x0628, 0x2018, 0x2c3c, 0x3604, 0x124c,
+ 0x062c, 0x2118, 0x2d3c, 0x3608, 0x1250,
+ 0x072c, 0x2218, 0x2e3c, 0x3708, 0x1350,
+ 0x082c, 0x2318, 0x2f3c, 0x3808, 0x1450,
+ 0x092c, 0x231c, 0x2f40, 0x3908, 0x1550,
+ 0x0a2c, 0x221c, 0x2e40, 0x3a08, 0x1650,
+ 0x0b2c, 0x211c, 0x2d40, 0x3b08, 0x1750,
+ 0x0b30, 0x201c, 0x2c40, 0x3b0c, 0x1754,
+ 0x0a30, 0x1f1c, 0x2b40, 0x3a0c, 0x1654,
+ 0x0930, 0x1e1c, 0x2a40, 0x390c, 0x1554,
+ 0x0830, 0x1e20, 0x2a44, 0x380c, 0x1454,
+ 0x0730, 0x1f20, 0x2b44, 0x370c, 0x1354,
+ 0x0630, 0x2020, 0x2c44, 0x360c, 0x1254,
+ 0x0634, 0x2120, 0x2d44, 0x3610, 0x1258,
+ 0x0734, 0x2220, 0x2e44, 0x3710, 0x1458,
+ 0x0834, 0x2320, 0x2f44, 0x3810, 0x1658,
+};
+
+/* 2 channels per frame, 10 DIF sequences per channel,
+   27 video segments per DIF sequence, 5 macroblocks per video segment */
+static const uint16_t dv_place_422_525[2*10*27*5] = {
+ 0x0c48, 0x2424, 0x306c, 0x0000, 0x1890,
+ 0x0d48, 0x2524, 0x316c, 0x0100, 0x1990,
+ 0x0e48, 0x2624, 0x326c, 0x0200, 0x1a90,
+ 0x0e4c, 0x2628, 0x3270, 0x0204, 0x1a94,
+ 0x0d4c, 0x2528, 0x3170, 0x0104, 0x1994,
+ 0x0c4c, 0x2428, 0x3070, 0x0004, 0x1894,
+ 0x0c50, 0x242c, 0x3074, 0x0008, 0x1898,
+ 0x0d50, 0x252c, 0x3174, 0x0108, 0x1998,
+ 0x0e50, 0x262c, 0x3274, 0x0208, 0x1a98,
+ 0x0e54, 0x2630, 0x3278, 0x020c, 0x1a9c,
+ 0x0d54, 0x2530, 0x3178, 0x010c, 0x199c,
+ 0x0c54, 0x2430, 0x3078, 0x000c, 0x189c,
+ 0x0c58, 0x2434, 0x307c, 0x0010, 0x18a0,
+ 0x0d58, 0x2534, 0x317c, 0x0110, 0x19a0,
+ 0x0e58, 0x2634, 0x327c, 0x0210, 0x1aa0,
+ 0x0e5c, 0x2638, 0x3280, 0x0214, 0x1aa4,
+ 0x0d5c, 0x2538, 0x3180, 0x0114, 0x19a4,
+ 0x0c5c, 0x2438, 0x3080, 0x0014, 0x18a4,
+ 0x0c60, 0x243c, 0x3084, 0x0018, 0x18a8,
+ 0x0d60, 0x253c, 0x3184, 0x0118, 0x19a8,
+ 0x0e60, 0x263c, 0x3284, 0x0218, 0x1aa8,
+ 0x0e64, 0x2640, 0x3288, 0x021c, 0x1aac,
+ 0x0d64, 0x2540, 0x3188, 0x011c, 0x19ac,
+ 0x0c64, 0x2440, 0x3088, 0x001c, 0x18ac,
+ 0x0c68, 0x2444, 0x308c, 0x0020, 0x18b0,
+ 0x0d68, 0x2544, 0x318c, 0x0120, 0x19b0,
+ 0x0e68, 0x2644, 0x328c, 0x0220, 0x1ab0,
+ 0x1248, 0x2a24, 0x366c, 0x0600, 0x1e90,
+ 0x1348, 0x2b24, 0x376c, 0x0700, 0x1f90,
+ 0x1448, 0x2c24, 0x386c, 0x0800, 0x2090,
+ 0x144c, 0x2c28, 0x3870, 0x0804, 0x2094,
+ 0x134c, 0x2b28, 0x3770, 0x0704, 0x1f94,
+ 0x124c, 0x2a28, 0x3670, 0x0604, 0x1e94,
+ 0x1250, 0x2a2c, 0x3674, 0x0608, 0x1e98,
+ 0x1350, 0x2b2c, 0x3774, 0x0708, 0x1f98,
+ 0x1450, 0x2c2c, 0x3874, 0x0808, 0x2098,
+ 0x1454, 0x2c30, 0x3878, 0x080c, 0x209c,
+ 0x1354, 0x2b30, 0x3778, 0x070c, 0x1f9c,
+ 0x1254, 0x2a30, 0x3678, 0x060c, 0x1e9c,
+ 0x1258, 0x2a34, 0x367c, 0x0610, 0x1ea0,
+ 0x1358, 0x2b34, 0x377c, 0x0710, 0x1fa0,
+ 0x1458, 0x2c34, 0x387c, 0x0810, 0x20a0,
+ 0x145c, 0x2c38, 0x3880, 0x0814, 0x20a4,
+ 0x135c, 0x2b38, 0x3780, 0x0714, 0x1fa4,
+ 0x125c, 0x2a38, 0x3680, 0x0614, 0x1ea4,
+ 0x1260, 0x2a3c, 0x3684, 0x0618, 0x1ea8,
+ 0x1360, 0x2b3c, 0x3784, 0x0718, 0x1fa8,
+ 0x1460, 0x2c3c, 0x3884, 0x0818, 0x20a8,
+ 0x1464, 0x2c40, 0x3888, 0x081c, 0x20ac,
+ 0x1364, 0x2b40, 0x3788, 0x071c, 0x1fac,
+ 0x1264, 0x2a40, 0x3688, 0x061c, 0x1eac,
+ 0x1268, 0x2a44, 0x368c, 0x0620, 0x1eb0,
+ 0x1368, 0x2b44, 0x378c, 0x0720, 0x1fb0,
+ 0x1468, 0x2c44, 0x388c, 0x0820, 0x20b0,
+ 0x1848, 0x3024, 0x006c, 0x0c00, 0x2490,
+ 0x1948, 0x3124, 0x016c, 0x0d00, 0x2590,
+ 0x1a48, 0x3224, 0x026c, 0x0e00, 0x2690,
+ 0x1a4c, 0x3228, 0x0270, 0x0e04, 0x2694,
+ 0x194c, 0x3128, 0x0170, 0x0d04, 0x2594,
+ 0x184c, 0x3028, 0x0070, 0x0c04, 0x2494,
+ 0x1850, 0x302c, 0x0074, 0x0c08, 0x2498,
+ 0x1950, 0x312c, 0x0174, 0x0d08, 0x2598,
+ 0x1a50, 0x322c, 0x0274, 0x0e08, 0x2698,
+ 0x1a54, 0x3230, 0x0278, 0x0e0c, 0x269c,
+ 0x1954, 0x3130, 0x0178, 0x0d0c, 0x259c,
+ 0x1854, 0x3030, 0x0078, 0x0c0c, 0x249c,
+ 0x1858, 0x3034, 0x007c, 0x0c10, 0x24a0,
+ 0x1958, 0x3134, 0x017c, 0x0d10, 0x25a0,
+ 0x1a58, 0x3234, 0x027c, 0x0e10, 0x26a0,
+ 0x1a5c, 0x3238, 0x0280, 0x0e14, 0x26a4,
+ 0x195c, 0x3138, 0x0180, 0x0d14, 0x25a4,
+ 0x185c, 0x3038, 0x0080, 0x0c14, 0x24a4,
+ 0x1860, 0x303c, 0x0084, 0x0c18, 0x24a8,
+ 0x1960, 0x313c, 0x0184, 0x0d18, 0x25a8,
+ 0x1a60, 0x323c, 0x0284, 0x0e18, 0x26a8,
+ 0x1a64, 0x3240, 0x0288, 0x0e1c, 0x26ac,
+ 0x1964, 0x3140, 0x0188, 0x0d1c, 0x25ac,
+ 0x1864, 0x3040, 0x0088, 0x0c1c, 0x24ac,
+ 0x1868, 0x3044, 0x008c, 0x0c20, 0x24b0,
+ 0x1968, 0x3144, 0x018c, 0x0d20, 0x25b0,
+ 0x1a68, 0x3244, 0x028c, 0x0e20, 0x26b0,
+ 0x1e48, 0x3624, 0x066c, 0x1200, 0x2a90,
+ 0x1f48, 0x3724, 0x076c, 0x1300, 0x2b90,
+ 0x2048, 0x3824, 0x086c, 0x1400, 0x2c90,
+ 0x204c, 0x3828, 0x0870, 0x1404, 0x2c94,
+ 0x1f4c, 0x3728, 0x0770, 0x1304, 0x2b94,
+ 0x1e4c, 0x3628, 0x0670, 0x1204, 0x2a94,
+ 0x1e50, 0x362c, 0x0674, 0x1208, 0x2a98,
+ 0x1f50, 0x372c, 0x0774, 0x1308, 0x2b98,
+ 0x2050, 0x382c, 0x0874, 0x1408, 0x2c98,
+ 0x2054, 0x3830, 0x0878, 0x140c, 0x2c9c,
+ 0x1f54, 0x3730, 0x0778, 0x130c, 0x2b9c,
+ 0x1e54, 0x3630, 0x0678, 0x120c, 0x2a9c,
+ 0x1e58, 0x3634, 0x067c, 0x1210, 0x2aa0,
+ 0x1f58, 0x3734, 0x077c, 0x1310, 0x2ba0,
+ 0x2058, 0x3834, 0x087c, 0x1410, 0x2ca0,
+ 0x205c, 0x3838, 0x0880, 0x1414, 0x2ca4,
+ 0x1f5c, 0x3738, 0x0780, 0x1314, 0x2ba4,
+ 0x1e5c, 0x3638, 0x0680, 0x1214, 0x2aa4,
+ 0x1e60, 0x363c, 0x0684, 0x1218, 0x2aa8,
+ 0x1f60, 0x373c, 0x0784, 0x1318, 0x2ba8,
+ 0x2060, 0x383c, 0x0884, 0x1418, 0x2ca8,
+ 0x2064, 0x3840, 0x0888, 0x141c, 0x2cac,
+ 0x1f64, 0x3740, 0x0788, 0x131c, 0x2bac,
+ 0x1e64, 0x3640, 0x0688, 0x121c, 0x2aac,
+ 0x1e68, 0x3644, 0x068c, 0x1220, 0x2ab0,
+ 0x1f68, 0x3744, 0x078c, 0x1320, 0x2bb0,
+ 0x2068, 0x3844, 0x088c, 0x1420, 0x2cb0,
+ 0x2448, 0x0024, 0x0c6c, 0x1800, 0x3090,
+ 0x2548, 0x0124, 0x0d6c, 0x1900, 0x3190,
+ 0x2648, 0x0224, 0x0e6c, 0x1a00, 0x3290,
+ 0x264c, 0x0228, 0x0e70, 0x1a04, 0x3294,
+ 0x254c, 0x0128, 0x0d70, 0x1904, 0x3194,
+ 0x244c, 0x0028, 0x0c70, 0x1804, 0x3094,
+ 0x2450, 0x002c, 0x0c74, 0x1808, 0x3098,
+ 0x2550, 0x012c, 0x0d74, 0x1908, 0x3198,
+ 0x2650, 0x022c, 0x0e74, 0x1a08, 0x3298,
+ 0x2654, 0x0230, 0x0e78, 0x1a0c, 0x329c,
+ 0x2554, 0x0130, 0x0d78, 0x190c, 0x319c,
+ 0x2454, 0x0030, 0x0c78, 0x180c, 0x309c,
+ 0x2458, 0x0034, 0x0c7c, 0x1810, 0x30a0,
+ 0x2558, 0x0134, 0x0d7c, 0x1910, 0x31a0,
+ 0x2658, 0x0234, 0x0e7c, 0x1a10, 0x32a0,
+ 0x265c, 0x0238, 0x0e80, 0x1a14, 0x32a4,
+ 0x255c, 0x0138, 0x0d80, 0x1914, 0x31a4,
+ 0x245c, 0x0038, 0x0c80, 0x1814, 0x30a4,
+ 0x2460, 0x003c, 0x0c84, 0x1818, 0x30a8,
+ 0x2560, 0x013c, 0x0d84, 0x1918, 0x31a8,
+ 0x2660, 0x023c, 0x0e84, 0x1a18, 0x32a8,
+ 0x2664, 0x0240, 0x0e88, 0x1a1c, 0x32ac,
+ 0x2564, 0x0140, 0x0d88, 0x191c, 0x31ac,
+ 0x2464, 0x0040, 0x0c88, 0x181c, 0x30ac,
+ 0x2468, 0x0044, 0x0c8c, 0x1820, 0x30b0,
+ 0x2568, 0x0144, 0x0d8c, 0x1920, 0x31b0,
+ 0x2668, 0x0244, 0x0e8c, 0x1a20, 0x32b0,
+ 0x2a48, 0x0624, 0x126c, 0x1e00, 0x3690,
+ 0x2b48, 0x0724, 0x136c, 0x1f00, 0x3790,
+ 0x2c48, 0x0824, 0x146c, 0x2000, 0x3890,
+ 0x2c4c, 0x0828, 0x1470, 0x2004, 0x3894,
+ 0x2b4c, 0x0728, 0x1370, 0x1f04, 0x3794,
+ 0x2a4c, 0x0628, 0x1270, 0x1e04, 0x3694,
+ 0x2a50, 0x062c, 0x1274, 0x1e08, 0x3698,
+ 0x2b50, 0x072c, 0x1374, 0x1f08, 0x3798,
+ 0x2c50, 0x082c, 0x1474, 0x2008, 0x3898,
+ 0x2c54, 0x0830, 0x1478, 0x200c, 0x389c,
+ 0x2b54, 0x0730, 0x1378, 0x1f0c, 0x379c,
+ 0x2a54, 0x0630, 0x1278, 0x1e0c, 0x369c,
+ 0x2a58, 0x0634, 0x127c, 0x1e10, 0x36a0,
+ 0x2b58, 0x0734, 0x137c, 0x1f10, 0x37a0,
+ 0x2c58, 0x0834, 0x147c, 0x2010, 0x38a0,
+ 0x2c5c, 0x0838, 0x1480, 0x2014, 0x38a4,
+ 0x2b5c, 0x0738, 0x1380, 0x1f14, 0x37a4,
+ 0x2a5c, 0x0638, 0x1280, 0x1e14, 0x36a4,
+ 0x2a60, 0x063c, 0x1284, 0x1e18, 0x36a8,
+ 0x2b60, 0x073c, 0x1384, 0x1f18, 0x37a8,
+ 0x2c60, 0x083c, 0x1484, 0x2018, 0x38a8,
+ 0x2c64, 0x0840, 0x1488, 0x201c, 0x38ac,
+ 0x2b64, 0x0740, 0x1388, 0x1f1c, 0x37ac,
+ 0x2a64, 0x0640, 0x1288, 0x1e1c, 0x36ac,
+ 0x2a68, 0x0644, 0x128c, 0x1e20, 0x36b0,
+ 0x2b68, 0x0744, 0x138c, 0x1f20, 0x37b0,
+ 0x2c68, 0x0844, 0x148c, 0x2020, 0x38b0,
+ 0x3048, 0x0c24, 0x186c, 0x2400, 0x0090,
+ 0x3148, 0x0d24, 0x196c, 0x2500, 0x0190,
+ 0x3248, 0x0e24, 0x1a6c, 0x2600, 0x0290,
+ 0x324c, 0x0e28, 0x1a70, 0x2604, 0x0294,
+ 0x314c, 0x0d28, 0x1970, 0x2504, 0x0194,
+ 0x304c, 0x0c28, 0x1870, 0x2404, 0x0094,
+ 0x3050, 0x0c2c, 0x1874, 0x2408, 0x0098,
+ 0x3150, 0x0d2c, 0x1974, 0x2508, 0x0198,
+ 0x3250, 0x0e2c, 0x1a74, 0x2608, 0x0298,
+ 0x3254, 0x0e30, 0x1a78, 0x260c, 0x029c,
+ 0x3154, 0x0d30, 0x1978, 0x250c, 0x019c,
+ 0x3054, 0x0c30, 0x1878, 0x240c, 0x009c,
+ 0x3058, 0x0c34, 0x187c, 0x2410, 0x00a0,
+ 0x3158, 0x0d34, 0x197c, 0x2510, 0x01a0,
+ 0x3258, 0x0e34, 0x1a7c, 0x2610, 0x02a0,
+ 0x325c, 0x0e38, 0x1a80, 0x2614, 0x02a4,
+ 0x315c, 0x0d38, 0x1980, 0x2514, 0x01a4,
+ 0x305c, 0x0c38, 0x1880, 0x2414, 0x00a4,
+ 0x3060, 0x0c3c, 0x1884, 0x2418, 0x00a8,
+ 0x3160, 0x0d3c, 0x1984, 0x2518, 0x01a8,
+ 0x3260, 0x0e3c, 0x1a84, 0x2618, 0x02a8,
+ 0x3264, 0x0e40, 0x1a88, 0x261c, 0x02ac,
+ 0x3164, 0x0d40, 0x1988, 0x251c, 0x01ac,
+ 0x3064, 0x0c40, 0x1888, 0x241c, 0x00ac,
+ 0x3068, 0x0c44, 0x188c, 0x2420, 0x00b0,
+ 0x3168, 0x0d44, 0x198c, 0x2520, 0x01b0,
+ 0x3268, 0x0e44, 0x1a8c, 0x2620, 0x02b0,
+ 0x3648, 0x1224, 0x1e6c, 0x2a00, 0x0690,
+ 0x3748, 0x1324, 0x1f6c, 0x2b00, 0x0790,
+ 0x3848, 0x1424, 0x206c, 0x2c00, 0x0890,
+ 0x384c, 0x1428, 0x2070, 0x2c04, 0x0894,
+ 0x374c, 0x1328, 0x1f70, 0x2b04, 0x0794,
+ 0x364c, 0x1228, 0x1e70, 0x2a04, 0x0694,
+ 0x3650, 0x122c, 0x1e74, 0x2a08, 0x0698,
+ 0x3750, 0x132c, 0x1f74, 0x2b08, 0x0798,
+ 0x3850, 0x142c, 0x2074, 0x2c08, 0x0898,
+ 0x3854, 0x1430, 0x2078, 0x2c0c, 0x089c,
+ 0x3754, 0x1330, 0x1f78, 0x2b0c, 0x079c,
+ 0x3654, 0x1230, 0x1e78, 0x2a0c, 0x069c,
+ 0x3658, 0x1234, 0x1e7c, 0x2a10, 0x06a0,
+ 0x3758, 0x1334, 0x1f7c, 0x2b10, 0x07a0,
+ 0x3858, 0x1434, 0x207c, 0x2c10, 0x08a0,
+ 0x385c, 0x1438, 0x2080, 0x2c14, 0x08a4,
+ 0x375c, 0x1338, 0x1f80, 0x2b14, 0x07a4,
+ 0x365c, 0x1238, 0x1e80, 0x2a14, 0x06a4,
+ 0x3660, 0x123c, 0x1e84, 0x2a18, 0x06a8,
+ 0x3760, 0x133c, 0x1f84, 0x2b18, 0x07a8,
+ 0x3860, 0x143c, 0x2084, 0x2c18, 0x08a8,
+ 0x3864, 0x1440, 0x2088, 0x2c1c, 0x08ac,
+ 0x3764, 0x1340, 0x1f88, 0x2b1c, 0x07ac,
+ 0x3664, 0x1240, 0x1e88, 0x2a1c, 0x06ac,
+ 0x3668, 0x1244, 0x1e8c, 0x2a20, 0x06b0,
+ 0x3768, 0x1344, 0x1f8c, 0x2b20, 0x07b0,
+ 0x3868, 0x1444, 0x208c, 0x2c20, 0x08b0,
+ 0x0048, 0x1824, 0x246c, 0x3000, 0x0c90,
+ 0x0148, 0x1924, 0x256c, 0x3100, 0x0d90,
+ 0x0248, 0x1a24, 0x266c, 0x3200, 0x0e90,
+ 0x024c, 0x1a28, 0x2670, 0x3204, 0x0e94,
+ 0x014c, 0x1928, 0x2570, 0x3104, 0x0d94,
+ 0x004c, 0x1828, 0x2470, 0x3004, 0x0c94,
+ 0x0050, 0x182c, 0x2474, 0x3008, 0x0c98,
+ 0x0150, 0x192c, 0x2574, 0x3108, 0x0d98,
+ 0x0250, 0x1a2c, 0x2674, 0x3208, 0x0e98,
+ 0x0254, 0x1a30, 0x2678, 0x320c, 0x0e9c,
+ 0x0154, 0x1930, 0x2578, 0x310c, 0x0d9c,
+ 0x0054, 0x1830, 0x2478, 0x300c, 0x0c9c,
+ 0x0058, 0x1834, 0x247c, 0x3010, 0x0ca0,
+ 0x0158, 0x1934, 0x257c, 0x3110, 0x0da0,
+ 0x0258, 0x1a34, 0x267c, 0x3210, 0x0ea0,
+ 0x025c, 0x1a38, 0x2680, 0x3214, 0x0ea4,
+ 0x015c, 0x1938, 0x2580, 0x3114, 0x0da4,
+ 0x005c, 0x1838, 0x2480, 0x3014, 0x0ca4,
+ 0x0060, 0x183c, 0x2484, 0x3018, 0x0ca8,
+ 0x0160, 0x193c, 0x2584, 0x3118, 0x0da8,
+ 0x0260, 0x1a3c, 0x2684, 0x3218, 0x0ea8,
+ 0x0264, 0x1a40, 0x2688, 0x321c, 0x0eac,
+ 0x0164, 0x1940, 0x2588, 0x311c, 0x0dac,
+ 0x0064, 0x1840, 0x2488, 0x301c, 0x0cac,
+ 0x0068, 0x1844, 0x248c, 0x3020, 0x0cb0,
+ 0x0168, 0x1944, 0x258c, 0x3120, 0x0db0,
+ 0x0268, 0x1a44, 0x268c, 0x3220, 0x0eb0,
+ 0x0648, 0x1e24, 0x2a6c, 0x3600, 0x1290,
+ 0x0748, 0x1f24, 0x2b6c, 0x3700, 0x1390,
+ 0x0848, 0x2024, 0x2c6c, 0x3800, 0x1490,
+ 0x084c, 0x2028, 0x2c70, 0x3804, 0x1494,
+ 0x074c, 0x1f28, 0x2b70, 0x3704, 0x1394,
+ 0x064c, 0x1e28, 0x2a70, 0x3604, 0x1294,
+ 0x0650, 0x1e2c, 0x2a74, 0x3608, 0x1298,
+ 0x0750, 0x1f2c, 0x2b74, 0x3708, 0x1398,
+ 0x0850, 0x202c, 0x2c74, 0x3808, 0x1498,
+ 0x0854, 0x2030, 0x2c78, 0x380c, 0x149c,
+ 0x0754, 0x1f30, 0x2b78, 0x370c, 0x139c,
+ 0x0654, 0x1e30, 0x2a78, 0x360c, 0x129c,
+ 0x0658, 0x1e34, 0x2a7c, 0x3610, 0x12a0,
+ 0x0758, 0x1f34, 0x2b7c, 0x3710, 0x13a0,
+ 0x0858, 0x2034, 0x2c7c, 0x3810, 0x14a0,
+ 0x085c, 0x2038, 0x2c80, 0x3814, 0x14a4,
+ 0x075c, 0x1f38, 0x2b80, 0x3714, 0x13a4,
+ 0x065c, 0x1e38, 0x2a80, 0x3614, 0x12a4,
+ 0x0660, 0x1e3c, 0x2a84, 0x3618, 0x12a8,
+ 0x0760, 0x1f3c, 0x2b84, 0x3718, 0x13a8,
+ 0x0860, 0x203c, 0x2c84, 0x3818, 0x14a8,
+ 0x0864, 0x2040, 0x2c88, 0x381c, 0x14ac,
+ 0x0764, 0x1f40, 0x2b88, 0x371c, 0x13ac,
+ 0x0664, 0x1e40, 0x2a88, 0x361c, 0x12ac,
+ 0x0668, 0x1e44, 0x2a8c, 0x3620, 0x12b0,
+ 0x0768, 0x1f44, 0x2b8c, 0x3720, 0x13b0,
+ 0x0868, 0x2044, 0x2c8c, 0x3820, 0x14b0,
+ 0x0f48, 0x2724, 0x336c, 0x0300, 0x1b90,
+ 0x1048, 0x2824, 0x346c, 0x0400, 0x1c90,
+ 0x1148, 0x2924, 0x356c, 0x0500, 0x1d90,
+ 0x114c, 0x2928, 0x3570, 0x0504, 0x1d94,
+ 0x104c, 0x2828, 0x3470, 0x0404, 0x1c94,
+ 0x0f4c, 0x2728, 0x3370, 0x0304, 0x1b94,
+ 0x0f50, 0x272c, 0x3374, 0x0308, 0x1b98,
+ 0x1050, 0x282c, 0x3474, 0x0408, 0x1c98,
+ 0x1150, 0x292c, 0x3574, 0x0508, 0x1d98,
+ 0x1154, 0x2930, 0x3578, 0x050c, 0x1d9c,
+ 0x1054, 0x2830, 0x3478, 0x040c, 0x1c9c,
+ 0x0f54, 0x2730, 0x3378, 0x030c, 0x1b9c,
+ 0x0f58, 0x2734, 0x337c, 0x0310, 0x1ba0,
+ 0x1058, 0x2834, 0x347c, 0x0410, 0x1ca0,
+ 0x1158, 0x2934, 0x357c, 0x0510, 0x1da0,
+ 0x115c, 0x2938, 0x3580, 0x0514, 0x1da4,
+ 0x105c, 0x2838, 0x3480, 0x0414, 0x1ca4,
+ 0x0f5c, 0x2738, 0x3380, 0x0314, 0x1ba4,
+ 0x0f60, 0x273c, 0x3384, 0x0318, 0x1ba8,
+ 0x1060, 0x283c, 0x3484, 0x0418, 0x1ca8,
+ 0x1160, 0x293c, 0x3584, 0x0518, 0x1da8,
+ 0x1164, 0x2940, 0x3588, 0x051c, 0x1dac,
+ 0x1064, 0x2840, 0x3488, 0x041c, 0x1cac,
+ 0x0f64, 0x2740, 0x3388, 0x031c, 0x1bac,
+ 0x0f68, 0x2744, 0x338c, 0x0320, 0x1bb0,
+ 0x1068, 0x2844, 0x348c, 0x0420, 0x1cb0,
+ 0x1168, 0x2944, 0x358c, 0x0520, 0x1db0,
+ 0x1548, 0x2d24, 0x396c, 0x0900, 0x2190,
+ 0x1648, 0x2e24, 0x3a6c, 0x0a00, 0x2290,
+ 0x1748, 0x2f24, 0x3b6c, 0x0b00, 0x2390,
+ 0x174c, 0x2f28, 0x3b70, 0x0b04, 0x2394,
+ 0x164c, 0x2e28, 0x3a70, 0x0a04, 0x2294,
+ 0x154c, 0x2d28, 0x3970, 0x0904, 0x2194,
+ 0x1550, 0x2d2c, 0x3974, 0x0908, 0x2198,
+ 0x1650, 0x2e2c, 0x3a74, 0x0a08, 0x2298,
+ 0x1750, 0x2f2c, 0x3b74, 0x0b08, 0x2398,
+ 0x1754, 0x2f30, 0x3b78, 0x0b0c, 0x239c,
+ 0x1654, 0x2e30, 0x3a78, 0x0a0c, 0x229c,
+ 0x1554, 0x2d30, 0x3978, 0x090c, 0x219c,
+ 0x1558, 0x2d34, 0x397c, 0x0910, 0x21a0,
+ 0x1658, 0x2e34, 0x3a7c, 0x0a10, 0x22a0,
+ 0x1758, 0x2f34, 0x3b7c, 0x0b10, 0x23a0,
+ 0x175c, 0x2f38, 0x3b80, 0x0b14, 0x23a4,
+ 0x165c, 0x2e38, 0x3a80, 0x0a14, 0x22a4,
+ 0x155c, 0x2d38, 0x3980, 0x0914, 0x21a4,
+ 0x1560, 0x2d3c, 0x3984, 0x0918, 0x21a8,
+ 0x1660, 0x2e3c, 0x3a84, 0x0a18, 0x22a8,
+ 0x1760, 0x2f3c, 0x3b84, 0x0b18, 0x23a8,
+ 0x1764, 0x2f40, 0x3b88, 0x0b1c, 0x23ac,
+ 0x1664, 0x2e40, 0x3a88, 0x0a1c, 0x22ac,
+ 0x1564, 0x2d40, 0x3988, 0x091c, 0x21ac,
+ 0x1568, 0x2d44, 0x398c, 0x0920, 0x21b0,
+ 0x1668, 0x2e44, 0x3a8c, 0x0a20, 0x22b0,
+ 0x1768, 0x2f44, 0x3b8c, 0x0b20, 0x23b0,
+ 0x1b48, 0x3324, 0x036c, 0x0f00, 0x2790,
+ 0x1c48, 0x3424, 0x046c, 0x1000, 0x2890,
+ 0x1d48, 0x3524, 0x056c, 0x1100, 0x2990,
+ 0x1d4c, 0x3528, 0x0570, 0x1104, 0x2994,
+ 0x1c4c, 0x3428, 0x0470, 0x1004, 0x2894,
+ 0x1b4c, 0x3328, 0x0370, 0x0f04, 0x2794,
+ 0x1b50, 0x332c, 0x0374, 0x0f08, 0x2798,
+ 0x1c50, 0x342c, 0x0474, 0x1008, 0x2898,
+ 0x1d50, 0x352c, 0x0574, 0x1108, 0x2998,
+ 0x1d54, 0x3530, 0x0578, 0x110c, 0x299c,
+ 0x1c54, 0x3430, 0x0478, 0x100c, 0x289c,
+ 0x1b54, 0x3330, 0x0378, 0x0f0c, 0x279c,
+ 0x1b58, 0x3334, 0x037c, 0x0f10, 0x27a0,
+ 0x1c58, 0x3434, 0x047c, 0x1010, 0x28a0,
+ 0x1d58, 0x3534, 0x057c, 0x1110, 0x29a0,
+ 0x1d5c, 0x3538, 0x0580, 0x1114, 0x29a4,
+ 0x1c5c, 0x3438, 0x0480, 0x1014, 0x28a4,
+ 0x1b5c, 0x3338, 0x0380, 0x0f14, 0x27a4,
+ 0x1b60, 0x333c, 0x0384, 0x0f18, 0x27a8,
+ 0x1c60, 0x343c, 0x0484, 0x1018, 0x28a8,
+ 0x1d60, 0x353c, 0x0584, 0x1118, 0x29a8,
+ 0x1d64, 0x3540, 0x0588, 0x111c, 0x29ac,
+ 0x1c64, 0x3440, 0x0488, 0x101c, 0x28ac,
+ 0x1b64, 0x3340, 0x0388, 0x0f1c, 0x27ac,
+ 0x1b68, 0x3344, 0x038c, 0x0f20, 0x27b0,
+ 0x1c68, 0x3444, 0x048c, 0x1020, 0x28b0,
+ 0x1d68, 0x3544, 0x058c, 0x1120, 0x29b0,
+ 0x2148, 0x3924, 0x096c, 0x1500, 0x2d90,
+ 0x2248, 0x3a24, 0x0a6c, 0x1600, 0x2e90,
+ 0x2348, 0x3b24, 0x0b6c, 0x1700, 0x2f90,
+ 0x234c, 0x3b28, 0x0b70, 0x1704, 0x2f94,
+ 0x224c, 0x3a28, 0x0a70, 0x1604, 0x2e94,
+ 0x214c, 0x3928, 0x0970, 0x1504, 0x2d94,
+ 0x2150, 0x392c, 0x0974, 0x1508, 0x2d98,
+ 0x2250, 0x3a2c, 0x0a74, 0x1608, 0x2e98,
+ 0x2350, 0x3b2c, 0x0b74, 0x1708, 0x2f98,
+ 0x2354, 0x3b30, 0x0b78, 0x170c, 0x2f9c,
+ 0x2254, 0x3a30, 0x0a78, 0x160c, 0x2e9c,
+ 0x2154, 0x3930, 0x0978, 0x150c, 0x2d9c,
+ 0x2158, 0x3934, 0x097c, 0x1510, 0x2da0,
+ 0x2258, 0x3a34, 0x0a7c, 0x1610, 0x2ea0,
+ 0x2358, 0x3b34, 0x0b7c, 0x1710, 0x2fa0,
+ 0x235c, 0x3b38, 0x0b80, 0x1714, 0x2fa4,
+ 0x225c, 0x3a38, 0x0a80, 0x1614, 0x2ea4,
+ 0x215c, 0x3938, 0x0980, 0x1514, 0x2da4,
+ 0x2160, 0x393c, 0x0984, 0x1518, 0x2da8,
+ 0x2260, 0x3a3c, 0x0a84, 0x1618, 0x2ea8,
+ 0x2360, 0x3b3c, 0x0b84, 0x1718, 0x2fa8,
+ 0x2364, 0x3b40, 0x0b88, 0x171c, 0x2fac,
+ 0x2264, 0x3a40, 0x0a88, 0x161c, 0x2eac,
+ 0x2164, 0x3940, 0x0988, 0x151c, 0x2dac,
+ 0x2168, 0x3944, 0x098c, 0x1520, 0x2db0,
+ 0x2268, 0x3a44, 0x0a8c, 0x1620, 0x2eb0,
+ 0x2368, 0x3b44, 0x0b8c, 0x1720, 0x2fb0,
+ 0x2748, 0x0324, 0x0f6c, 0x1b00, 0x3390,
+ 0x2848, 0x0424, 0x106c, 0x1c00, 0x3490,
+ 0x2948, 0x0524, 0x116c, 0x1d00, 0x3590,
+ 0x294c, 0x0528, 0x1170, 0x1d04, 0x3594,
+ 0x284c, 0x0428, 0x1070, 0x1c04, 0x3494,
+ 0x274c, 0x0328, 0x0f70, 0x1b04, 0x3394,
+ 0x2750, 0x032c, 0x0f74, 0x1b08, 0x3398,
+ 0x2850, 0x042c, 0x1074, 0x1c08, 0x3498,
+ 0x2950, 0x052c, 0x1174, 0x1d08, 0x3598,
+ 0x2954, 0x0530, 0x1178, 0x1d0c, 0x359c,
+ 0x2854, 0x0430, 0x1078, 0x1c0c, 0x349c,
+ 0x2754, 0x0330, 0x0f78, 0x1b0c, 0x339c,
+ 0x2758, 0x0334, 0x0f7c, 0x1b10, 0x33a0,
+ 0x2858, 0x0434, 0x107c, 0x1c10, 0x34a0,
+ 0x2958, 0x0534, 0x117c, 0x1d10, 0x35a0,
+ 0x295c, 0x0538, 0x1180, 0x1d14, 0x35a4,
+ 0x285c, 0x0438, 0x1080, 0x1c14, 0x34a4,
+ 0x275c, 0x0338, 0x0f80, 0x1b14, 0x33a4,
+ 0x2760, 0x033c, 0x0f84, 0x1b18, 0x33a8,
+ 0x2860, 0x043c, 0x1084, 0x1c18, 0x34a8,
+ 0x2960, 0x053c, 0x1184, 0x1d18, 0x35a8,
+ 0x2964, 0x0540, 0x1188, 0x1d1c, 0x35ac,
+ 0x2864, 0x0440, 0x1088, 0x1c1c, 0x34ac,
+ 0x2764, 0x0340, 0x0f88, 0x1b1c, 0x33ac,
+ 0x2768, 0x0344, 0x0f8c, 0x1b20, 0x33b0,
+ 0x2868, 0x0444, 0x108c, 0x1c20, 0x34b0,
+ 0x2968, 0x0544, 0x118c, 0x1d20, 0x35b0,
+ 0x2d48, 0x0924, 0x156c, 0x2100, 0x3990,
+ 0x2e48, 0x0a24, 0x166c, 0x2200, 0x3a90,
+ 0x2f48, 0x0b24, 0x176c, 0x2300, 0x3b90,
+ 0x2f4c, 0x0b28, 0x1770, 0x2304, 0x3b94,
+ 0x2e4c, 0x0a28, 0x1670, 0x2204, 0x3a94,
+ 0x2d4c, 0x0928, 0x1570, 0x2104, 0x3994,
+ 0x2d50, 0x092c, 0x1574, 0x2108, 0x3998,
+ 0x2e50, 0x0a2c, 0x1674, 0x2208, 0x3a98,
+ 0x2f50, 0x0b2c, 0x1774, 0x2308, 0x3b98,
+ 0x2f54, 0x0b30, 0x1778, 0x230c, 0x3b9c,
+ 0x2e54, 0x0a30, 0x1678, 0x220c, 0x3a9c,
+ 0x2d54, 0x0930, 0x1578, 0x210c, 0x399c,
+ 0x2d58, 0x0934, 0x157c, 0x2110, 0x39a0,
+ 0x2e58, 0x0a34, 0x167c, 0x2210, 0x3aa0,
+ 0x2f58, 0x0b34, 0x177c, 0x2310, 0x3ba0,
+ 0x2f5c, 0x0b38, 0x1780, 0x2314, 0x3ba4,
+ 0x2e5c, 0x0a38, 0x1680, 0x2214, 0x3aa4,
+ 0x2d5c, 0x0938, 0x1580, 0x2114, 0x39a4,
+ 0x2d60, 0x093c, 0x1584, 0x2118, 0x39a8,
+ 0x2e60, 0x0a3c, 0x1684, 0x2218, 0x3aa8,
+ 0x2f60, 0x0b3c, 0x1784, 0x2318, 0x3ba8,
+ 0x2f64, 0x0b40, 0x1788, 0x231c, 0x3bac,
+ 0x2e64, 0x0a40, 0x1688, 0x221c, 0x3aac,
+ 0x2d64, 0x0940, 0x1588, 0x211c, 0x39ac,
+ 0x2d68, 0x0944, 0x158c, 0x2120, 0x39b0,
+ 0x2e68, 0x0a44, 0x168c, 0x2220, 0x3ab0,
+ 0x2f68, 0x0b44, 0x178c, 0x2320, 0x3bb0,
+ 0x3348, 0x0f24, 0x1b6c, 0x2700, 0x0390,
+ 0x3448, 0x1024, 0x1c6c, 0x2800, 0x0490,
+ 0x3548, 0x1124, 0x1d6c, 0x2900, 0x0590,
+ 0x354c, 0x1128, 0x1d70, 0x2904, 0x0594,
+ 0x344c, 0x1028, 0x1c70, 0x2804, 0x0494,
+ 0x334c, 0x0f28, 0x1b70, 0x2704, 0x0394,
+ 0x3350, 0x0f2c, 0x1b74, 0x2708, 0x0398,
+ 0x3450, 0x102c, 0x1c74, 0x2808, 0x0498,
+ 0x3550, 0x112c, 0x1d74, 0x2908, 0x0598,
+ 0x3554, 0x1130, 0x1d78, 0x290c, 0x059c,
+ 0x3454, 0x1030, 0x1c78, 0x280c, 0x049c,
+ 0x3354, 0x0f30, 0x1b78, 0x270c, 0x039c,
+ 0x3358, 0x0f34, 0x1b7c, 0x2710, 0x03a0,
+ 0x3458, 0x1034, 0x1c7c, 0x2810, 0x04a0,
+ 0x3558, 0x1134, 0x1d7c, 0x2910, 0x05a0,
+ 0x355c, 0x1138, 0x1d80, 0x2914, 0x05a4,
+ 0x345c, 0x1038, 0x1c80, 0x2814, 0x04a4,
+ 0x335c, 0x0f38, 0x1b80, 0x2714, 0x03a4,
+ 0x3360, 0x0f3c, 0x1b84, 0x2718, 0x03a8,
+ 0x3460, 0x103c, 0x1c84, 0x2818, 0x04a8,
+ 0x3560, 0x113c, 0x1d84, 0x2918, 0x05a8,
+ 0x3564, 0x1140, 0x1d88, 0x291c, 0x05ac,
+ 0x3464, 0x1040, 0x1c88, 0x281c, 0x04ac,
+ 0x3364, 0x0f40, 0x1b88, 0x271c, 0x03ac,
+ 0x3368, 0x0f44, 0x1b8c, 0x2720, 0x03b0,
+ 0x3468, 0x1044, 0x1c8c, 0x2820, 0x04b0,
+ 0x3568, 0x1144, 0x1d8c, 0x2920, 0x05b0,
+ 0x3948, 0x1524, 0x216c, 0x2d00, 0x0990,
+ 0x3a48, 0x1624, 0x226c, 0x2e00, 0x0a90,
+ 0x3b48, 0x1724, 0x236c, 0x2f00, 0x0b90,
+ 0x3b4c, 0x1728, 0x2370, 0x2f04, 0x0b94,
+ 0x3a4c, 0x1628, 0x2270, 0x2e04, 0x0a94,
+ 0x394c, 0x1528, 0x2170, 0x2d04, 0x0994,
+ 0x3950, 0x152c, 0x2174, 0x2d08, 0x0998,
+ 0x3a50, 0x162c, 0x2274, 0x2e08, 0x0a98,
+ 0x3b50, 0x172c, 0x2374, 0x2f08, 0x0b98,
+ 0x3b54, 0x1730, 0x2378, 0x2f0c, 0x0b9c,
+ 0x3a54, 0x1630, 0x2278, 0x2e0c, 0x0a9c,
+ 0x3954, 0x1530, 0x2178, 0x2d0c, 0x099c,
+ 0x3958, 0x1534, 0x217c, 0x2d10, 0x09a0,
+ 0x3a58, 0x1634, 0x227c, 0x2e10, 0x0aa0,
+ 0x3b58, 0x1734, 0x237c, 0x2f10, 0x0ba0,
+ 0x3b5c, 0x1738, 0x2380, 0x2f14, 0x0ba4,
+ 0x3a5c, 0x1638, 0x2280, 0x2e14, 0x0aa4,
+ 0x395c, 0x1538, 0x2180, 0x2d14, 0x09a4,
+ 0x3960, 0x153c, 0x2184, 0x2d18, 0x09a8,
+ 0x3a60, 0x163c, 0x2284, 0x2e18, 0x0aa8,
+ 0x3b60, 0x173c, 0x2384, 0x2f18, 0x0ba8,
+ 0x3b64, 0x1740, 0x2388, 0x2f1c, 0x0bac,
+ 0x3a64, 0x1640, 0x2288, 0x2e1c, 0x0aac,
+ 0x3964, 0x1540, 0x2188, 0x2d1c, 0x09ac,
+ 0x3968, 0x1544, 0x218c, 0x2d20, 0x09b0,
+ 0x3a68, 0x1644, 0x228c, 0x2e20, 0x0ab0,
+ 0x3b68, 0x1744, 0x238c, 0x2f20, 0x0bb0,
+ 0x0348, 0x1b24, 0x276c, 0x3300, 0x0f90,
+ 0x0448, 0x1c24, 0x286c, 0x3400, 0x1090,
+ 0x0548, 0x1d24, 0x296c, 0x3500, 0x1190,
+ 0x054c, 0x1d28, 0x2970, 0x3504, 0x1194,
+ 0x044c, 0x1c28, 0x2870, 0x3404, 0x1094,
+ 0x034c, 0x1b28, 0x2770, 0x3304, 0x0f94,
+ 0x0350, 0x1b2c, 0x2774, 0x3308, 0x0f98,
+ 0x0450, 0x1c2c, 0x2874, 0x3408, 0x1098,
+ 0x0550, 0x1d2c, 0x2974, 0x3508, 0x1198,
+ 0x0554, 0x1d30, 0x2978, 0x350c, 0x119c,
+ 0x0454, 0x1c30, 0x2878, 0x340c, 0x109c,
+ 0x0354, 0x1b30, 0x2778, 0x330c, 0x0f9c,
+ 0x0358, 0x1b34, 0x277c, 0x3310, 0x0fa0,
+ 0x0458, 0x1c34, 0x287c, 0x3410, 0x10a0,
+ 0x0558, 0x1d34, 0x297c, 0x3510, 0x11a0,
+ 0x055c, 0x1d38, 0x2980, 0x3514, 0x11a4,
+ 0x045c, 0x1c38, 0x2880, 0x3414, 0x10a4,
+ 0x035c, 0x1b38, 0x2780, 0x3314, 0x0fa4,
+ 0x0360, 0x1b3c, 0x2784, 0x3318, 0x0fa8,
+ 0x0460, 0x1c3c, 0x2884, 0x3418, 0x10a8,
+ 0x0560, 0x1d3c, 0x2984, 0x3518, 0x11a8,
+ 0x0564, 0x1d40, 0x2988, 0x351c, 0x11ac,
+ 0x0464, 0x1c40, 0x2888, 0x341c, 0x10ac,
+ 0x0364, 0x1b40, 0x2788, 0x331c, 0x0fac,
+ 0x0368, 0x1b44, 0x278c, 0x3320, 0x0fb0,
+ 0x0468, 0x1c44, 0x288c, 0x3420, 0x10b0,
+ 0x0568, 0x1d44, 0x298c, 0x3520, 0x11b0,
+ 0x0948, 0x2124, 0x2d6c, 0x3900, 0x1590,
+ 0x0a48, 0x2224, 0x2e6c, 0x3a00, 0x1690,
+ 0x0b48, 0x2324, 0x2f6c, 0x3b00, 0x1790,
+ 0x0b4c, 0x2328, 0x2f70, 0x3b04, 0x1794,
+ 0x0a4c, 0x2228, 0x2e70, 0x3a04, 0x1694,
+ 0x094c, 0x2128, 0x2d70, 0x3904, 0x1594,
+ 0x0950, 0x212c, 0x2d74, 0x3908, 0x1598,
+ 0x0a50, 0x222c, 0x2e74, 0x3a08, 0x1698,
+ 0x0b50, 0x232c, 0x2f74, 0x3b08, 0x1798,
+ 0x0b54, 0x2330, 0x2f78, 0x3b0c, 0x179c,
+ 0x0a54, 0x2230, 0x2e78, 0x3a0c, 0x169c,
+ 0x0954, 0x2130, 0x2d78, 0x390c, 0x159c,
+ 0x0958, 0x2134, 0x2d7c, 0x3910, 0x15a0,
+ 0x0a58, 0x2234, 0x2e7c, 0x3a10, 0x16a0,
+ 0x0b58, 0x2334, 0x2f7c, 0x3b10, 0x17a0,
+ 0x0b5c, 0x2338, 0x2f80, 0x3b14, 0x17a4,
+ 0x0a5c, 0x2238, 0x2e80, 0x3a14, 0x16a4,
+ 0x095c, 0x2138, 0x2d80, 0x3914, 0x15a4,
+ 0x0960, 0x213c, 0x2d84, 0x3918, 0x15a8,
+ 0x0a60, 0x223c, 0x2e84, 0x3a18, 0x16a8,
+ 0x0b60, 0x233c, 0x2f84, 0x3b18, 0x17a8,
+ 0x0b64, 0x2340, 0x2f88, 0x3b1c, 0x17ac,
+ 0x0a64, 0x2240, 0x2e88, 0x3a1c, 0x16ac,
+ 0x0964, 0x2140, 0x2d88, 0x391c, 0x15ac,
+ 0x0968, 0x2144, 0x2d8c, 0x3920, 0x15b0,
+ 0x0a68, 0x2244, 0x2e8c, 0x3a20, 0x16b0,
+ 0x0b68, 0x2344, 0x2f8c, 0x3b20, 0x17b0,
+};
+
+/* 2 channels per frame, 12 DIF sequences per channel,
+   27 video segments per DIF sequence, 5 macroblocks per video segment */
+static const uint16_t dv_place_422_625[2*12*27*5] = {
+ 0x0c48, 0x2424, 0x306c, 0x0000, 0x1890,
+ 0x0d48, 0x2524, 0x316c, 0x0100, 0x1990,
+ 0x0e48, 0x2624, 0x326c, 0x0200, 0x1a90,
+ 0x0e4c, 0x2628, 0x3270, 0x0204, 0x1a94,
+ 0x0d4c, 0x2528, 0x3170, 0x0104, 0x1994,
+ 0x0c4c, 0x2428, 0x3070, 0x0004, 0x1894,
+ 0x0c50, 0x242c, 0x3074, 0x0008, 0x1898,
+ 0x0d50, 0x252c, 0x3174, 0x0108, 0x1998,
+ 0x0e50, 0x262c, 0x3274, 0x0208, 0x1a98,
+ 0x0e54, 0x2630, 0x3278, 0x020c, 0x1a9c,
+ 0x0d54, 0x2530, 0x3178, 0x010c, 0x199c,
+ 0x0c54, 0x2430, 0x3078, 0x000c, 0x189c,
+ 0x0c58, 0x2434, 0x307c, 0x0010, 0x18a0,
+ 0x0d58, 0x2534, 0x317c, 0x0110, 0x19a0,
+ 0x0e58, 0x2634, 0x327c, 0x0210, 0x1aa0,
+ 0x0e5c, 0x2638, 0x3280, 0x0214, 0x1aa4,
+ 0x0d5c, 0x2538, 0x3180, 0x0114, 0x19a4,
+ 0x0c5c, 0x2438, 0x3080, 0x0014, 0x18a4,
+ 0x0c60, 0x243c, 0x3084, 0x0018, 0x18a8,
+ 0x0d60, 0x253c, 0x3184, 0x0118, 0x19a8,
+ 0x0e60, 0x263c, 0x3284, 0x0218, 0x1aa8,
+ 0x0e64, 0x2640, 0x3288, 0x021c, 0x1aac,
+ 0x0d64, 0x2540, 0x3188, 0x011c, 0x19ac,
+ 0x0c64, 0x2440, 0x3088, 0x001c, 0x18ac,
+ 0x0c68, 0x2444, 0x308c, 0x0020, 0x18b0,
+ 0x0d68, 0x2544, 0x318c, 0x0120, 0x19b0,
+ 0x0e68, 0x2644, 0x328c, 0x0220, 0x1ab0,
+ 0x1248, 0x2a24, 0x366c, 0x0600, 0x1e90,
+ 0x1348, 0x2b24, 0x376c, 0x0700, 0x1f90,
+ 0x1448, 0x2c24, 0x386c, 0x0800, 0x2090,
+ 0x144c, 0x2c28, 0x3870, 0x0804, 0x2094,
+ 0x134c, 0x2b28, 0x3770, 0x0704, 0x1f94,
+ 0x124c, 0x2a28, 0x3670, 0x0604, 0x1e94,
+ 0x1250, 0x2a2c, 0x3674, 0x0608, 0x1e98,
+ 0x1350, 0x2b2c, 0x3774, 0x0708, 0x1f98,
+ 0x1450, 0x2c2c, 0x3874, 0x0808, 0x2098,
+ 0x1454, 0x2c30, 0x3878, 0x080c, 0x209c,
+ 0x1354, 0x2b30, 0x3778, 0x070c, 0x1f9c,
+ 0x1254, 0x2a30, 0x3678, 0x060c, 0x1e9c,
+ 0x1258, 0x2a34, 0x367c, 0x0610, 0x1ea0,
+ 0x1358, 0x2b34, 0x377c, 0x0710, 0x1fa0,
+ 0x1458, 0x2c34, 0x387c, 0x0810, 0x20a0,
+ 0x145c, 0x2c38, 0x3880, 0x0814, 0x20a4,
+ 0x135c, 0x2b38, 0x3780, 0x0714, 0x1fa4,
+ 0x125c, 0x2a38, 0x3680, 0x0614, 0x1ea4,
+ 0x1260, 0x2a3c, 0x3684, 0x0618, 0x1ea8,
+ 0x1360, 0x2b3c, 0x3784, 0x0718, 0x1fa8,
+ 0x1460, 0x2c3c, 0x3884, 0x0818, 0x20a8,
+ 0x1464, 0x2c40, 0x3888, 0x081c, 0x20ac,
+ 0x1364, 0x2b40, 0x3788, 0x071c, 0x1fac,
+ 0x1264, 0x2a40, 0x3688, 0x061c, 0x1eac,
+ 0x1268, 0x2a44, 0x368c, 0x0620, 0x1eb0,
+ 0x1368, 0x2b44, 0x378c, 0x0720, 0x1fb0,
+ 0x1468, 0x2c44, 0x388c, 0x0820, 0x20b0,
+ 0x1848, 0x3024, 0x3c6c, 0x0c00, 0x2490,
+ 0x1948, 0x3124, 0x3d6c, 0x0d00, 0x2590,
+ 0x1a48, 0x3224, 0x3e6c, 0x0e00, 0x2690,
+ 0x1a4c, 0x3228, 0x3e70, 0x0e04, 0x2694,
+ 0x194c, 0x3128, 0x3d70, 0x0d04, 0x2594,
+ 0x184c, 0x3028, 0x3c70, 0x0c04, 0x2494,
+ 0x1850, 0x302c, 0x3c74, 0x0c08, 0x2498,
+ 0x1950, 0x312c, 0x3d74, 0x0d08, 0x2598,
+ 0x1a50, 0x322c, 0x3e74, 0x0e08, 0x2698,
+ 0x1a54, 0x3230, 0x3e78, 0x0e0c, 0x269c,
+ 0x1954, 0x3130, 0x3d78, 0x0d0c, 0x259c,
+ 0x1854, 0x3030, 0x3c78, 0x0c0c, 0x249c,
+ 0x1858, 0x3034, 0x3c7c, 0x0c10, 0x24a0,
+ 0x1958, 0x3134, 0x3d7c, 0x0d10, 0x25a0,
+ 0x1a58, 0x3234, 0x3e7c, 0x0e10, 0x26a0,
+ 0x1a5c, 0x3238, 0x3e80, 0x0e14, 0x26a4,
+ 0x195c, 0x3138, 0x3d80, 0x0d14, 0x25a4,
+ 0x185c, 0x3038, 0x3c80, 0x0c14, 0x24a4,
+ 0x1860, 0x303c, 0x3c84, 0x0c18, 0x24a8,
+ 0x1960, 0x313c, 0x3d84, 0x0d18, 0x25a8,
+ 0x1a60, 0x323c, 0x3e84, 0x0e18, 0x26a8,
+ 0x1a64, 0x3240, 0x3e88, 0x0e1c, 0x26ac,
+ 0x1964, 0x3140, 0x3d88, 0x0d1c, 0x25ac,
+ 0x1864, 0x3040, 0x3c88, 0x0c1c, 0x24ac,
+ 0x1868, 0x3044, 0x3c8c, 0x0c20, 0x24b0,
+ 0x1968, 0x3144, 0x3d8c, 0x0d20, 0x25b0,
+ 0x1a68, 0x3244, 0x3e8c, 0x0e20, 0x26b0,
+ 0x1e48, 0x3624, 0x426c, 0x1200, 0x2a90,
+ 0x1f48, 0x3724, 0x436c, 0x1300, 0x2b90,
+ 0x2048, 0x3824, 0x446c, 0x1400, 0x2c90,
+ 0x204c, 0x3828, 0x4470, 0x1404, 0x2c94,
+ 0x1f4c, 0x3728, 0x4370, 0x1304, 0x2b94,
+ 0x1e4c, 0x3628, 0x4270, 0x1204, 0x2a94,
+ 0x1e50, 0x362c, 0x4274, 0x1208, 0x2a98,
+ 0x1f50, 0x372c, 0x4374, 0x1308, 0x2b98,
+ 0x2050, 0x382c, 0x4474, 0x1408, 0x2c98,
+ 0x2054, 0x3830, 0x4478, 0x140c, 0x2c9c,
+ 0x1f54, 0x3730, 0x4378, 0x130c, 0x2b9c,
+ 0x1e54, 0x3630, 0x4278, 0x120c, 0x2a9c,
+ 0x1e58, 0x3634, 0x427c, 0x1210, 0x2aa0,
+ 0x1f58, 0x3734, 0x437c, 0x1310, 0x2ba0,
+ 0x2058, 0x3834, 0x447c, 0x1410, 0x2ca0,
+ 0x205c, 0x3838, 0x4480, 0x1414, 0x2ca4,
+ 0x1f5c, 0x3738, 0x4380, 0x1314, 0x2ba4,
+ 0x1e5c, 0x3638, 0x4280, 0x1214, 0x2aa4,
+ 0x1e60, 0x363c, 0x4284, 0x1218, 0x2aa8,
+ 0x1f60, 0x373c, 0x4384, 0x1318, 0x2ba8,
+ 0x2060, 0x383c, 0x4484, 0x1418, 0x2ca8,
+ 0x2064, 0x3840, 0x4488, 0x141c, 0x2cac,
+ 0x1f64, 0x3740, 0x4388, 0x131c, 0x2bac,
+ 0x1e64, 0x3640, 0x4288, 0x121c, 0x2aac,
+ 0x1e68, 0x3644, 0x428c, 0x1220, 0x2ab0,
+ 0x1f68, 0x3744, 0x438c, 0x1320, 0x2bb0,
+ 0x2068, 0x3844, 0x448c, 0x1420, 0x2cb0,
+ 0x2448, 0x3c24, 0x006c, 0x1800, 0x3090,
+ 0x2548, 0x3d24, 0x016c, 0x1900, 0x3190,
+ 0x2648, 0x3e24, 0x026c, 0x1a00, 0x3290,
+ 0x264c, 0x3e28, 0x0270, 0x1a04, 0x3294,
+ 0x254c, 0x3d28, 0x0170, 0x1904, 0x3194,
+ 0x244c, 0x3c28, 0x0070, 0x1804, 0x3094,
+ 0x2450, 0x3c2c, 0x0074, 0x1808, 0x3098,
+ 0x2550, 0x3d2c, 0x0174, 0x1908, 0x3198,
+ 0x2650, 0x3e2c, 0x0274, 0x1a08, 0x3298,
+ 0x2654, 0x3e30, 0x0278, 0x1a0c, 0x329c,
+ 0x2554, 0x3d30, 0x0178, 0x190c, 0x319c,
+ 0x2454, 0x3c30, 0x0078, 0x180c, 0x309c,
+ 0x2458, 0x3c34, 0x007c, 0x1810, 0x30a0,
+ 0x2558, 0x3d34, 0x017c, 0x1910, 0x31a0,
+ 0x2658, 0x3e34, 0x027c, 0x1a10, 0x32a0,
+ 0x265c, 0x3e38, 0x0280, 0x1a14, 0x32a4,
+ 0x255c, 0x3d38, 0x0180, 0x1914, 0x31a4,
+ 0x245c, 0x3c38, 0x0080, 0x1814, 0x30a4,
+ 0x2460, 0x3c3c, 0x0084, 0x1818, 0x30a8,
+ 0x2560, 0x3d3c, 0x0184, 0x1918, 0x31a8,
+ 0x2660, 0x3e3c, 0x0284, 0x1a18, 0x32a8,
+ 0x2664, 0x3e40, 0x0288, 0x1a1c, 0x32ac,
+ 0x2564, 0x3d40, 0x0188, 0x191c, 0x31ac,
+ 0x2464, 0x3c40, 0x0088, 0x181c, 0x30ac,
+ 0x2468, 0x3c44, 0x008c, 0x1820, 0x30b0,
+ 0x2568, 0x3d44, 0x018c, 0x1920, 0x31b0,
+ 0x2668, 0x3e44, 0x028c, 0x1a20, 0x32b0,
+ 0x2a48, 0x4224, 0x066c, 0x1e00, 0x3690,
+ 0x2b48, 0x4324, 0x076c, 0x1f00, 0x3790,
+ 0x2c48, 0x4424, 0x086c, 0x2000, 0x3890,
+ 0x2c4c, 0x4428, 0x0870, 0x2004, 0x3894,
+ 0x2b4c, 0x4328, 0x0770, 0x1f04, 0x3794,
+ 0x2a4c, 0x4228, 0x0670, 0x1e04, 0x3694,
+ 0x2a50, 0x422c, 0x0674, 0x1e08, 0x3698,
+ 0x2b50, 0x432c, 0x0774, 0x1f08, 0x3798,
+ 0x2c50, 0x442c, 0x0874, 0x2008, 0x3898,
+ 0x2c54, 0x4430, 0x0878, 0x200c, 0x389c,
+ 0x2b54, 0x4330, 0x0778, 0x1f0c, 0x379c,
+ 0x2a54, 0x4230, 0x0678, 0x1e0c, 0x369c,
+ 0x2a58, 0x4234, 0x067c, 0x1e10, 0x36a0,
+ 0x2b58, 0x4334, 0x077c, 0x1f10, 0x37a0,
+ 0x2c58, 0x4434, 0x087c, 0x2010, 0x38a0,
+ 0x2c5c, 0x4438, 0x0880, 0x2014, 0x38a4,
+ 0x2b5c, 0x4338, 0x0780, 0x1f14, 0x37a4,
+ 0x2a5c, 0x4238, 0x0680, 0x1e14, 0x36a4,
+ 0x2a60, 0x423c, 0x0684, 0x1e18, 0x36a8,
+ 0x2b60, 0x433c, 0x0784, 0x1f18, 0x37a8,
+ 0x2c60, 0x443c, 0x0884, 0x2018, 0x38a8,
+ 0x2c64, 0x4440, 0x0888, 0x201c, 0x38ac,
+ 0x2b64, 0x4340, 0x0788, 0x1f1c, 0x37ac,
+ 0x2a64, 0x4240, 0x0688, 0x1e1c, 0x36ac,
+ 0x2a68, 0x4244, 0x068c, 0x1e20, 0x36b0,
+ 0x2b68, 0x4344, 0x078c, 0x1f20, 0x37b0,
+ 0x2c68, 0x4444, 0x088c, 0x2020, 0x38b0,
+ 0x3048, 0x0024, 0x0c6c, 0x2400, 0x3c90,
+ 0x3148, 0x0124, 0x0d6c, 0x2500, 0x3d90,
+ 0x3248, 0x0224, 0x0e6c, 0x2600, 0x3e90,
+ 0x324c, 0x0228, 0x0e70, 0x2604, 0x3e94,
+ 0x314c, 0x0128, 0x0d70, 0x2504, 0x3d94,
+ 0x304c, 0x0028, 0x0c70, 0x2404, 0x3c94,
+ 0x3050, 0x002c, 0x0c74, 0x2408, 0x3c98,
+ 0x3150, 0x012c, 0x0d74, 0x2508, 0x3d98,
+ 0x3250, 0x022c, 0x0e74, 0x2608, 0x3e98,
+ 0x3254, 0x0230, 0x0e78, 0x260c, 0x3e9c,
+ 0x3154, 0x0130, 0x0d78, 0x250c, 0x3d9c,
+ 0x3054, 0x0030, 0x0c78, 0x240c, 0x3c9c,
+ 0x3058, 0x0034, 0x0c7c, 0x2410, 0x3ca0,
+ 0x3158, 0x0134, 0x0d7c, 0x2510, 0x3da0,
+ 0x3258, 0x0234, 0x0e7c, 0x2610, 0x3ea0,
+ 0x325c, 0x0238, 0x0e80, 0x2614, 0x3ea4,
+ 0x315c, 0x0138, 0x0d80, 0x2514, 0x3da4,
+ 0x305c, 0x0038, 0x0c80, 0x2414, 0x3ca4,
+ 0x3060, 0x003c, 0x0c84, 0x2418, 0x3ca8,
+ 0x3160, 0x013c, 0x0d84, 0x2518, 0x3da8,
+ 0x3260, 0x023c, 0x0e84, 0x2618, 0x3ea8,
+ 0x3264, 0x0240, 0x0e88, 0x261c, 0x3eac,
+ 0x3164, 0x0140, 0x0d88, 0x251c, 0x3dac,
+ 0x3064, 0x0040, 0x0c88, 0x241c, 0x3cac,
+ 0x3068, 0x0044, 0x0c8c, 0x2420, 0x3cb0,
+ 0x3168, 0x0144, 0x0d8c, 0x2520, 0x3db0,
+ 0x3268, 0x0244, 0x0e8c, 0x2620, 0x3eb0,
+ 0x3648, 0x0624, 0x126c, 0x2a00, 0x4290,
+ 0x3748, 0x0724, 0x136c, 0x2b00, 0x4390,
+ 0x3848, 0x0824, 0x146c, 0x2c00, 0x4490,
+ 0x384c, 0x0828, 0x1470, 0x2c04, 0x4494,
+ 0x374c, 0x0728, 0x1370, 0x2b04, 0x4394,
+ 0x364c, 0x0628, 0x1270, 0x2a04, 0x4294,
+ 0x3650, 0x062c, 0x1274, 0x2a08, 0x4298,
+ 0x3750, 0x072c, 0x1374, 0x2b08, 0x4398,
+ 0x3850, 0x082c, 0x1474, 0x2c08, 0x4498,
+ 0x3854, 0x0830, 0x1478, 0x2c0c, 0x449c,
+ 0x3754, 0x0730, 0x1378, 0x2b0c, 0x439c,
+ 0x3654, 0x0630, 0x1278, 0x2a0c, 0x429c,
+ 0x3658, 0x0634, 0x127c, 0x2a10, 0x42a0,
+ 0x3758, 0x0734, 0x137c, 0x2b10, 0x43a0,
+ 0x3858, 0x0834, 0x147c, 0x2c10, 0x44a0,
+ 0x385c, 0x0838, 0x1480, 0x2c14, 0x44a4,
+ 0x375c, 0x0738, 0x1380, 0x2b14, 0x43a4,
+ 0x365c, 0x0638, 0x1280, 0x2a14, 0x42a4,
+ 0x3660, 0x063c, 0x1284, 0x2a18, 0x42a8,
+ 0x3760, 0x073c, 0x1384, 0x2b18, 0x43a8,
+ 0x3860, 0x083c, 0x1484, 0x2c18, 0x44a8,
+ 0x3864, 0x0840, 0x1488, 0x2c1c, 0x44ac,
+ 0x3764, 0x0740, 0x1388, 0x2b1c, 0x43ac,
+ 0x3664, 0x0640, 0x1288, 0x2a1c, 0x42ac,
+ 0x3668, 0x0644, 0x128c, 0x2a20, 0x42b0,
+ 0x3768, 0x0744, 0x138c, 0x2b20, 0x43b0,
+ 0x3868, 0x0844, 0x148c, 0x2c20, 0x44b0,
+ 0x3c48, 0x0c24, 0x186c, 0x3000, 0x0090,
+ 0x3d48, 0x0d24, 0x196c, 0x3100, 0x0190,
+ 0x3e48, 0x0e24, 0x1a6c, 0x3200, 0x0290,
+ 0x3e4c, 0x0e28, 0x1a70, 0x3204, 0x0294,
+ 0x3d4c, 0x0d28, 0x1970, 0x3104, 0x0194,
+ 0x3c4c, 0x0c28, 0x1870, 0x3004, 0x0094,
+ 0x3c50, 0x0c2c, 0x1874, 0x3008, 0x0098,
+ 0x3d50, 0x0d2c, 0x1974, 0x3108, 0x0198,
+ 0x3e50, 0x0e2c, 0x1a74, 0x3208, 0x0298,
+ 0x3e54, 0x0e30, 0x1a78, 0x320c, 0x029c,
+ 0x3d54, 0x0d30, 0x1978, 0x310c, 0x019c,
+ 0x3c54, 0x0c30, 0x1878, 0x300c, 0x009c,
+ 0x3c58, 0x0c34, 0x187c, 0x3010, 0x00a0,
+ 0x3d58, 0x0d34, 0x197c, 0x3110, 0x01a0,
+ 0x3e58, 0x0e34, 0x1a7c, 0x3210, 0x02a0,
+ 0x3e5c, 0x0e38, 0x1a80, 0x3214, 0x02a4,
+ 0x3d5c, 0x0d38, 0x1980, 0x3114, 0x01a4,
+ 0x3c5c, 0x0c38, 0x1880, 0x3014, 0x00a4,
+ 0x3c60, 0x0c3c, 0x1884, 0x3018, 0x00a8,
+ 0x3d60, 0x0d3c, 0x1984, 0x3118, 0x01a8,
+ 0x3e60, 0x0e3c, 0x1a84, 0x3218, 0x02a8,
+ 0x3e64, 0x0e40, 0x1a88, 0x321c, 0x02ac,
+ 0x3d64, 0x0d40, 0x1988, 0x311c, 0x01ac,
+ 0x3c64, 0x0c40, 0x1888, 0x301c, 0x00ac,
+ 0x3c68, 0x0c44, 0x188c, 0x3020, 0x00b0,
+ 0x3d68, 0x0d44, 0x198c, 0x3120, 0x01b0,
+ 0x3e68, 0x0e44, 0x1a8c, 0x3220, 0x02b0,
+ 0x4248, 0x1224, 0x1e6c, 0x3600, 0x0690,
+ 0x4348, 0x1324, 0x1f6c, 0x3700, 0x0790,
+ 0x4448, 0x1424, 0x206c, 0x3800, 0x0890,
+ 0x444c, 0x1428, 0x2070, 0x3804, 0x0894,
+ 0x434c, 0x1328, 0x1f70, 0x3704, 0x0794,
+ 0x424c, 0x1228, 0x1e70, 0x3604, 0x0694,
+ 0x4250, 0x122c, 0x1e74, 0x3608, 0x0698,
+ 0x4350, 0x132c, 0x1f74, 0x3708, 0x0798,
+ 0x4450, 0x142c, 0x2074, 0x3808, 0x0898,
+ 0x4454, 0x1430, 0x2078, 0x380c, 0x089c,
+ 0x4354, 0x1330, 0x1f78, 0x370c, 0x079c,
+ 0x4254, 0x1230, 0x1e78, 0x360c, 0x069c,
+ 0x4258, 0x1234, 0x1e7c, 0x3610, 0x06a0,
+ 0x4358, 0x1334, 0x1f7c, 0x3710, 0x07a0,
+ 0x4458, 0x1434, 0x207c, 0x3810, 0x08a0,
+ 0x445c, 0x1438, 0x2080, 0x3814, 0x08a4,
+ 0x435c, 0x1338, 0x1f80, 0x3714, 0x07a4,
+ 0x425c, 0x1238, 0x1e80, 0x3614, 0x06a4,
+ 0x4260, 0x123c, 0x1e84, 0x3618, 0x06a8,
+ 0x4360, 0x133c, 0x1f84, 0x3718, 0x07a8,
+ 0x4460, 0x143c, 0x2084, 0x3818, 0x08a8,
+ 0x4464, 0x1440, 0x2088, 0x381c, 0x08ac,
+ 0x4364, 0x1340, 0x1f88, 0x371c, 0x07ac,
+ 0x4264, 0x1240, 0x1e88, 0x361c, 0x06ac,
+ 0x4268, 0x1244, 0x1e8c, 0x3620, 0x06b0,
+ 0x4368, 0x1344, 0x1f8c, 0x3720, 0x07b0,
+ 0x4468, 0x1444, 0x208c, 0x3820, 0x08b0,
+ 0x0048, 0x1824, 0x246c, 0x3c00, 0x0c90,
+ 0x0148, 0x1924, 0x256c, 0x3d00, 0x0d90,
+ 0x0248, 0x1a24, 0x266c, 0x3e00, 0x0e90,
+ 0x024c, 0x1a28, 0x2670, 0x3e04, 0x0e94,
+ 0x014c, 0x1928, 0x2570, 0x3d04, 0x0d94,
+ 0x004c, 0x1828, 0x2470, 0x3c04, 0x0c94,
+ 0x0050, 0x182c, 0x2474, 0x3c08, 0x0c98,
+ 0x0150, 0x192c, 0x2574, 0x3d08, 0x0d98,
+ 0x0250, 0x1a2c, 0x2674, 0x3e08, 0x0e98,
+ 0x0254, 0x1a30, 0x2678, 0x3e0c, 0x0e9c,
+ 0x0154, 0x1930, 0x2578, 0x3d0c, 0x0d9c,
+ 0x0054, 0x1830, 0x2478, 0x3c0c, 0x0c9c,
+ 0x0058, 0x1834, 0x247c, 0x3c10, 0x0ca0,
+ 0x0158, 0x1934, 0x257c, 0x3d10, 0x0da0,
+ 0x0258, 0x1a34, 0x267c, 0x3e10, 0x0ea0,
+ 0x025c, 0x1a38, 0x2680, 0x3e14, 0x0ea4,
+ 0x015c, 0x1938, 0x2580, 0x3d14, 0x0da4,
+ 0x005c, 0x1838, 0x2480, 0x3c14, 0x0ca4,
+ 0x0060, 0x183c, 0x2484, 0x3c18, 0x0ca8,
+ 0x0160, 0x193c, 0x2584, 0x3d18, 0x0da8,
+ 0x0260, 0x1a3c, 0x2684, 0x3e18, 0x0ea8,
+ 0x0264, 0x1a40, 0x2688, 0x3e1c, 0x0eac,
+ 0x0164, 0x1940, 0x2588, 0x3d1c, 0x0dac,
+ 0x0064, 0x1840, 0x2488, 0x3c1c, 0x0cac,
+ 0x0068, 0x1844, 0x248c, 0x3c20, 0x0cb0,
+ 0x0168, 0x1944, 0x258c, 0x3d20, 0x0db0,
+ 0x0268, 0x1a44, 0x268c, 0x3e20, 0x0eb0,
+ 0x0648, 0x1e24, 0x2a6c, 0x4200, 0x1290,
+ 0x0748, 0x1f24, 0x2b6c, 0x4300, 0x1390,
+ 0x0848, 0x2024, 0x2c6c, 0x4400, 0x1490,
+ 0x084c, 0x2028, 0x2c70, 0x4404, 0x1494,
+ 0x074c, 0x1f28, 0x2b70, 0x4304, 0x1394,
+ 0x064c, 0x1e28, 0x2a70, 0x4204, 0x1294,
+ 0x0650, 0x1e2c, 0x2a74, 0x4208, 0x1298,
+ 0x0750, 0x1f2c, 0x2b74, 0x4308, 0x1398,
+ 0x0850, 0x202c, 0x2c74, 0x4408, 0x1498,
+ 0x0854, 0x2030, 0x2c78, 0x440c, 0x149c,
+ 0x0754, 0x1f30, 0x2b78, 0x430c, 0x139c,
+ 0x0654, 0x1e30, 0x2a78, 0x420c, 0x129c,
+ 0x0658, 0x1e34, 0x2a7c, 0x4210, 0x12a0,
+ 0x0758, 0x1f34, 0x2b7c, 0x4310, 0x13a0,
+ 0x0858, 0x2034, 0x2c7c, 0x4410, 0x14a0,
+ 0x085c, 0x2038, 0x2c80, 0x4414, 0x14a4,
+ 0x075c, 0x1f38, 0x2b80, 0x4314, 0x13a4,
+ 0x065c, 0x1e38, 0x2a80, 0x4214, 0x12a4,
+ 0x0660, 0x1e3c, 0x2a84, 0x4218, 0x12a8,
+ 0x0760, 0x1f3c, 0x2b84, 0x4318, 0x13a8,
+ 0x0860, 0x203c, 0x2c84, 0x4418, 0x14a8,
+ 0x0864, 0x2040, 0x2c88, 0x441c, 0x14ac,
+ 0x0764, 0x1f40, 0x2b88, 0x431c, 0x13ac,
+ 0x0664, 0x1e40, 0x2a88, 0x421c, 0x12ac,
+ 0x0668, 0x1e44, 0x2a8c, 0x4220, 0x12b0,
+ 0x0768, 0x1f44, 0x2b8c, 0x4320, 0x13b0,
+ 0x0868, 0x2044, 0x2c8c, 0x4420, 0x14b0,
+ 0x0f48, 0x2724, 0x336c, 0x0300, 0x1b90,
+ 0x1048, 0x2824, 0x346c, 0x0400, 0x1c90,
+ 0x1148, 0x2924, 0x356c, 0x0500, 0x1d90,
+ 0x114c, 0x2928, 0x3570, 0x0504, 0x1d94,
+ 0x104c, 0x2828, 0x3470, 0x0404, 0x1c94,
+ 0x0f4c, 0x2728, 0x3370, 0x0304, 0x1b94,
+ 0x0f50, 0x272c, 0x3374, 0x0308, 0x1b98,
+ 0x1050, 0x282c, 0x3474, 0x0408, 0x1c98,
+ 0x1150, 0x292c, 0x3574, 0x0508, 0x1d98,
+ 0x1154, 0x2930, 0x3578, 0x050c, 0x1d9c,
+ 0x1054, 0x2830, 0x3478, 0x040c, 0x1c9c,
+ 0x0f54, 0x2730, 0x3378, 0x030c, 0x1b9c,
+ 0x0f58, 0x2734, 0x337c, 0x0310, 0x1ba0,
+ 0x1058, 0x2834, 0x347c, 0x0410, 0x1ca0,
+ 0x1158, 0x2934, 0x357c, 0x0510, 0x1da0,
+ 0x115c, 0x2938, 0x3580, 0x0514, 0x1da4,
+ 0x105c, 0x2838, 0x3480, 0x0414, 0x1ca4,
+ 0x0f5c, 0x2738, 0x3380, 0x0314, 0x1ba4,
+ 0x0f60, 0x273c, 0x3384, 0x0318, 0x1ba8,
+ 0x1060, 0x283c, 0x3484, 0x0418, 0x1ca8,
+ 0x1160, 0x293c, 0x3584, 0x0518, 0x1da8,
+ 0x1164, 0x2940, 0x3588, 0x051c, 0x1dac,
+ 0x1064, 0x2840, 0x3488, 0x041c, 0x1cac,
+ 0x0f64, 0x2740, 0x3388, 0x031c, 0x1bac,
+ 0x0f68, 0x2744, 0x338c, 0x0320, 0x1bb0,
+ 0x1068, 0x2844, 0x348c, 0x0420, 0x1cb0,
+ 0x1168, 0x2944, 0x358c, 0x0520, 0x1db0,
+ 0x1548, 0x2d24, 0x396c, 0x0900, 0x2190,
+ 0x1648, 0x2e24, 0x3a6c, 0x0a00, 0x2290,
+ 0x1748, 0x2f24, 0x3b6c, 0x0b00, 0x2390,
+ 0x174c, 0x2f28, 0x3b70, 0x0b04, 0x2394,
+ 0x164c, 0x2e28, 0x3a70, 0x0a04, 0x2294,
+ 0x154c, 0x2d28, 0x3970, 0x0904, 0x2194,
+ 0x1550, 0x2d2c, 0x3974, 0x0908, 0x2198,
+ 0x1650, 0x2e2c, 0x3a74, 0x0a08, 0x2298,
+ 0x1750, 0x2f2c, 0x3b74, 0x0b08, 0x2398,
+ 0x1754, 0x2f30, 0x3b78, 0x0b0c, 0x239c,
+ 0x1654, 0x2e30, 0x3a78, 0x0a0c, 0x229c,
+ 0x1554, 0x2d30, 0x3978, 0x090c, 0x219c,
+ 0x1558, 0x2d34, 0x397c, 0x0910, 0x21a0,
+ 0x1658, 0x2e34, 0x3a7c, 0x0a10, 0x22a0,
+ 0x1758, 0x2f34, 0x3b7c, 0x0b10, 0x23a0,
+ 0x175c, 0x2f38, 0x3b80, 0x0b14, 0x23a4,
+ 0x165c, 0x2e38, 0x3a80, 0x0a14, 0x22a4,
+ 0x155c, 0x2d38, 0x3980, 0x0914, 0x21a4,
+ 0x1560, 0x2d3c, 0x3984, 0x0918, 0x21a8,
+ 0x1660, 0x2e3c, 0x3a84, 0x0a18, 0x22a8,
+ 0x1760, 0x2f3c, 0x3b84, 0x0b18, 0x23a8,
+ 0x1764, 0x2f40, 0x3b88, 0x0b1c, 0x23ac,
+ 0x1664, 0x2e40, 0x3a88, 0x0a1c, 0x22ac,
+ 0x1564, 0x2d40, 0x3988, 0x091c, 0x21ac,
+ 0x1568, 0x2d44, 0x398c, 0x0920, 0x21b0,
+ 0x1668, 0x2e44, 0x3a8c, 0x0a20, 0x22b0,
+ 0x1768, 0x2f44, 0x3b8c, 0x0b20, 0x23b0,
+ 0x1b48, 0x3324, 0x3f6c, 0x0f00, 0x2790,
+ 0x1c48, 0x3424, 0x406c, 0x1000, 0x2890,
+ 0x1d48, 0x3524, 0x416c, 0x1100, 0x2990,
+ 0x1d4c, 0x3528, 0x4170, 0x1104, 0x2994,
+ 0x1c4c, 0x3428, 0x4070, 0x1004, 0x2894,
+ 0x1b4c, 0x3328, 0x3f70, 0x0f04, 0x2794,
+ 0x1b50, 0x332c, 0x3f74, 0x0f08, 0x2798,
+ 0x1c50, 0x342c, 0x4074, 0x1008, 0x2898,
+ 0x1d50, 0x352c, 0x4174, 0x1108, 0x2998,
+ 0x1d54, 0x3530, 0x4178, 0x110c, 0x299c,
+ 0x1c54, 0x3430, 0x4078, 0x100c, 0x289c,
+ 0x1b54, 0x3330, 0x3f78, 0x0f0c, 0x279c,
+ 0x1b58, 0x3334, 0x3f7c, 0x0f10, 0x27a0,
+ 0x1c58, 0x3434, 0x407c, 0x1010, 0x28a0,
+ 0x1d58, 0x3534, 0x417c, 0x1110, 0x29a0,
+ 0x1d5c, 0x3538, 0x4180, 0x1114, 0x29a4,
+ 0x1c5c, 0x3438, 0x4080, 0x1014, 0x28a4,
+ 0x1b5c, 0x3338, 0x3f80, 0x0f14, 0x27a4,
+ 0x1b60, 0x333c, 0x3f84, 0x0f18, 0x27a8,
+ 0x1c60, 0x343c, 0x4084, 0x1018, 0x28a8,
+ 0x1d60, 0x353c, 0x4184, 0x1118, 0x29a8,
+ 0x1d64, 0x3540, 0x4188, 0x111c, 0x29ac,
+ 0x1c64, 0x3440, 0x4088, 0x101c, 0x28ac,
+ 0x1b64, 0x3340, 0x3f88, 0x0f1c, 0x27ac,
+ 0x1b68, 0x3344, 0x3f8c, 0x0f20, 0x27b0,
+ 0x1c68, 0x3444, 0x408c, 0x1020, 0x28b0,
+ 0x1d68, 0x3544, 0x418c, 0x1120, 0x29b0,
+ 0x2148, 0x3924, 0x456c, 0x1500, 0x2d90,
+ 0x2248, 0x3a24, 0x466c, 0x1600, 0x2e90,
+ 0x2348, 0x3b24, 0x476c, 0x1700, 0x2f90,
+ 0x234c, 0x3b28, 0x4770, 0x1704, 0x2f94,
+ 0x224c, 0x3a28, 0x4670, 0x1604, 0x2e94,
+ 0x214c, 0x3928, 0x4570, 0x1504, 0x2d94,
+ 0x2150, 0x392c, 0x4574, 0x1508, 0x2d98,
+ 0x2250, 0x3a2c, 0x4674, 0x1608, 0x2e98,
+ 0x2350, 0x3b2c, 0x4774, 0x1708, 0x2f98,
+ 0x2354, 0x3b30, 0x4778, 0x170c, 0x2f9c,
+ 0x2254, 0x3a30, 0x4678, 0x160c, 0x2e9c,
+ 0x2154, 0x3930, 0x4578, 0x150c, 0x2d9c,
+ 0x2158, 0x3934, 0x457c, 0x1510, 0x2da0,
+ 0x2258, 0x3a34, 0x467c, 0x1610, 0x2ea0,
+ 0x2358, 0x3b34, 0x477c, 0x1710, 0x2fa0,
+ 0x235c, 0x3b38, 0x4780, 0x1714, 0x2fa4,
+ 0x225c, 0x3a38, 0x4680, 0x1614, 0x2ea4,
+ 0x215c, 0x3938, 0x4580, 0x1514, 0x2da4,
+ 0x2160, 0x393c, 0x4584, 0x1518, 0x2da8,
+ 0x2260, 0x3a3c, 0x4684, 0x1618, 0x2ea8,
+ 0x2360, 0x3b3c, 0x4784, 0x1718, 0x2fa8,
+ 0x2364, 0x3b40, 0x4788, 0x171c, 0x2fac,
+ 0x2264, 0x3a40, 0x4688, 0x161c, 0x2eac,
+ 0x2164, 0x3940, 0x4588, 0x151c, 0x2dac,
+ 0x2168, 0x3944, 0x458c, 0x1520, 0x2db0,
+ 0x2268, 0x3a44, 0x468c, 0x1620, 0x2eb0,
+ 0x2368, 0x3b44, 0x478c, 0x1720, 0x2fb0,
+ 0x2748, 0x3f24, 0x036c, 0x1b00, 0x3390,
+ 0x2848, 0x4024, 0x046c, 0x1c00, 0x3490,
+ 0x2948, 0x4124, 0x056c, 0x1d00, 0x3590,
+ 0x294c, 0x4128, 0x0570, 0x1d04, 0x3594,
+ 0x284c, 0x4028, 0x0470, 0x1c04, 0x3494,
+ 0x274c, 0x3f28, 0x0370, 0x1b04, 0x3394,
+ 0x2750, 0x3f2c, 0x0374, 0x1b08, 0x3398,
+ 0x2850, 0x402c, 0x0474, 0x1c08, 0x3498,
+ 0x2950, 0x412c, 0x0574, 0x1d08, 0x3598,
+ 0x2954, 0x4130, 0x0578, 0x1d0c, 0x359c,
+ 0x2854, 0x4030, 0x0478, 0x1c0c, 0x349c,
+ 0x2754, 0x3f30, 0x0378, 0x1b0c, 0x339c,
+ 0x2758, 0x3f34, 0x037c, 0x1b10, 0x33a0,
+ 0x2858, 0x4034, 0x047c, 0x1c10, 0x34a0,
+ 0x2958, 0x4134, 0x057c, 0x1d10, 0x35a0,
+ 0x295c, 0x4138, 0x0580, 0x1d14, 0x35a4,
+ 0x285c, 0x4038, 0x0480, 0x1c14, 0x34a4,
+ 0x275c, 0x3f38, 0x0380, 0x1b14, 0x33a4,
+ 0x2760, 0x3f3c, 0x0384, 0x1b18, 0x33a8,
+ 0x2860, 0x403c, 0x0484, 0x1c18, 0x34a8,
+ 0x2960, 0x413c, 0x0584, 0x1d18, 0x35a8,
+ 0x2964, 0x4140, 0x0588, 0x1d1c, 0x35ac,
+ 0x2864, 0x4040, 0x0488, 0x1c1c, 0x34ac,
+ 0x2764, 0x3f40, 0x0388, 0x1b1c, 0x33ac,
+ 0x2768, 0x3f44, 0x038c, 0x1b20, 0x33b0,
+ 0x2868, 0x4044, 0x048c, 0x1c20, 0x34b0,
+ 0x2968, 0x4144, 0x058c, 0x1d20, 0x35b0,
+ 0x2d48, 0x4524, 0x096c, 0x2100, 0x3990,
+ 0x2e48, 0x4624, 0x0a6c, 0x2200, 0x3a90,
+ 0x2f48, 0x4724, 0x0b6c, 0x2300, 0x3b90,
+ 0x2f4c, 0x4728, 0x0b70, 0x2304, 0x3b94,
+ 0x2e4c, 0x4628, 0x0a70, 0x2204, 0x3a94,
+ 0x2d4c, 0x4528, 0x0970, 0x2104, 0x3994,
+ 0x2d50, 0x452c, 0x0974, 0x2108, 0x3998,
+ 0x2e50, 0x462c, 0x0a74, 0x2208, 0x3a98,
+ 0x2f50, 0x472c, 0x0b74, 0x2308, 0x3b98,
+ 0x2f54, 0x4730, 0x0b78, 0x230c, 0x3b9c,
+ 0x2e54, 0x4630, 0x0a78, 0x220c, 0x3a9c,
+ 0x2d54, 0x4530, 0x0978, 0x210c, 0x399c,
+ 0x2d58, 0x4534, 0x097c, 0x2110, 0x39a0,
+ 0x2e58, 0x4634, 0x0a7c, 0x2210, 0x3aa0,
+ 0x2f58, 0x4734, 0x0b7c, 0x2310, 0x3ba0,
+ 0x2f5c, 0x4738, 0x0b80, 0x2314, 0x3ba4,
+ 0x2e5c, 0x4638, 0x0a80, 0x2214, 0x3aa4,
+ 0x2d5c, 0x4538, 0x0980, 0x2114, 0x39a4,
+ 0x2d60, 0x453c, 0x0984, 0x2118, 0x39a8,
+ 0x2e60, 0x463c, 0x0a84, 0x2218, 0x3aa8,
+ 0x2f60, 0x473c, 0x0b84, 0x2318, 0x3ba8,
+ 0x2f64, 0x4740, 0x0b88, 0x231c, 0x3bac,
+ 0x2e64, 0x4640, 0x0a88, 0x221c, 0x3aac,
+ 0x2d64, 0x4540, 0x0988, 0x211c, 0x39ac,
+ 0x2d68, 0x4544, 0x098c, 0x2120, 0x39b0,
+ 0x2e68, 0x4644, 0x0a8c, 0x2220, 0x3ab0,
+ 0x2f68, 0x4744, 0x0b8c, 0x2320, 0x3bb0,
+ 0x3348, 0x0324, 0x0f6c, 0x2700, 0x3f90,
+ 0x3448, 0x0424, 0x106c, 0x2800, 0x4090,
+ 0x3548, 0x0524, 0x116c, 0x2900, 0x4190,
+ 0x354c, 0x0528, 0x1170, 0x2904, 0x4194,
+ 0x344c, 0x0428, 0x1070, 0x2804, 0x4094,
+ 0x334c, 0x0328, 0x0f70, 0x2704, 0x3f94,
+ 0x3350, 0x032c, 0x0f74, 0x2708, 0x3f98,
+ 0x3450, 0x042c, 0x1074, 0x2808, 0x4098,
+ 0x3550, 0x052c, 0x1174, 0x2908, 0x4198,
+ 0x3554, 0x0530, 0x1178, 0x290c, 0x419c,
+ 0x3454, 0x0430, 0x1078, 0x280c, 0x409c,
+ 0x3354, 0x0330, 0x0f78, 0x270c, 0x3f9c,
+ 0x3358, 0x0334, 0x0f7c, 0x2710, 0x3fa0,
+ 0x3458, 0x0434, 0x107c, 0x2810, 0x40a0,
+ 0x3558, 0x0534, 0x117c, 0x2910, 0x41a0,
+ 0x355c, 0x0538, 0x1180, 0x2914, 0x41a4,
+ 0x345c, 0x0438, 0x1080, 0x2814, 0x40a4,
+ 0x335c, 0x0338, 0x0f80, 0x2714, 0x3fa4,
+ 0x3360, 0x033c, 0x0f84, 0x2718, 0x3fa8,
+ 0x3460, 0x043c, 0x1084, 0x2818, 0x40a8,
+ 0x3560, 0x053c, 0x1184, 0x2918, 0x41a8,
+ 0x3564, 0x0540, 0x1188, 0x291c, 0x41ac,
+ 0x3464, 0x0440, 0x1088, 0x281c, 0x40ac,
+ 0x3364, 0x0340, 0x0f88, 0x271c, 0x3fac,
+ 0x3368, 0x0344, 0x0f8c, 0x2720, 0x3fb0,
+ 0x3468, 0x0444, 0x108c, 0x2820, 0x40b0,
+ 0x3568, 0x0544, 0x118c, 0x2920, 0x41b0,
+ 0x3948, 0x0924, 0x156c, 0x2d00, 0x4590,
+ 0x3a48, 0x0a24, 0x166c, 0x2e00, 0x4690,
+ 0x3b48, 0x0b24, 0x176c, 0x2f00, 0x4790,
+ 0x3b4c, 0x0b28, 0x1770, 0x2f04, 0x4794,
+ 0x3a4c, 0x0a28, 0x1670, 0x2e04, 0x4694,
+ 0x394c, 0x0928, 0x1570, 0x2d04, 0x4594,
+ 0x3950, 0x092c, 0x1574, 0x2d08, 0x4598,
+ 0x3a50, 0x0a2c, 0x1674, 0x2e08, 0x4698,
+ 0x3b50, 0x0b2c, 0x1774, 0x2f08, 0x4798,
+ 0x3b54, 0x0b30, 0x1778, 0x2f0c, 0x479c,
+ 0x3a54, 0x0a30, 0x1678, 0x2e0c, 0x469c,
+ 0x3954, 0x0930, 0x1578, 0x2d0c, 0x459c,
+ 0x3958, 0x0934, 0x157c, 0x2d10, 0x45a0,
+ 0x3a58, 0x0a34, 0x167c, 0x2e10, 0x46a0,
+ 0x3b58, 0x0b34, 0x177c, 0x2f10, 0x47a0,
+ 0x3b5c, 0x0b38, 0x1780, 0x2f14, 0x47a4,
+ 0x3a5c, 0x0a38, 0x1680, 0x2e14, 0x46a4,
+ 0x395c, 0x0938, 0x1580, 0x2d14, 0x45a4,
+ 0x3960, 0x093c, 0x1584, 0x2d18, 0x45a8,
+ 0x3a60, 0x0a3c, 0x1684, 0x2e18, 0x46a8,
+ 0x3b60, 0x0b3c, 0x1784, 0x2f18, 0x47a8,
+ 0x3b64, 0x0b40, 0x1788, 0x2f1c, 0x47ac,
+ 0x3a64, 0x0a40, 0x1688, 0x2e1c, 0x46ac,
+ 0x3964, 0x0940, 0x1588, 0x2d1c, 0x45ac,
+ 0x3968, 0x0944, 0x158c, 0x2d20, 0x45b0,
+ 0x3a68, 0x0a44, 0x168c, 0x2e20, 0x46b0,
+ 0x3b68, 0x0b44, 0x178c, 0x2f20, 0x47b0,
+ 0x3f48, 0x0f24, 0x1b6c, 0x3300, 0x0390,
+ 0x4048, 0x1024, 0x1c6c, 0x3400, 0x0490,
+ 0x4148, 0x1124, 0x1d6c, 0x3500, 0x0590,
+ 0x414c, 0x1128, 0x1d70, 0x3504, 0x0594,
+ 0x404c, 0x1028, 0x1c70, 0x3404, 0x0494,
+ 0x3f4c, 0x0f28, 0x1b70, 0x3304, 0x0394,
+ 0x3f50, 0x0f2c, 0x1b74, 0x3308, 0x0398,
+ 0x4050, 0x102c, 0x1c74, 0x3408, 0x0498,
+ 0x4150, 0x112c, 0x1d74, 0x3508, 0x0598,
+ 0x4154, 0x1130, 0x1d78, 0x350c, 0x059c,
+ 0x4054, 0x1030, 0x1c78, 0x340c, 0x049c,
+ 0x3f54, 0x0f30, 0x1b78, 0x330c, 0x039c,
+ 0x3f58, 0x0f34, 0x1b7c, 0x3310, 0x03a0,
+ 0x4058, 0x1034, 0x1c7c, 0x3410, 0x04a0,
+ 0x4158, 0x1134, 0x1d7c, 0x3510, 0x05a0,
+ 0x415c, 0x1138, 0x1d80, 0x3514, 0x05a4,
+ 0x405c, 0x1038, 0x1c80, 0x3414, 0x04a4,
+ 0x3f5c, 0x0f38, 0x1b80, 0x3314, 0x03a4,
+ 0x3f60, 0x0f3c, 0x1b84, 0x3318, 0x03a8,
+ 0x4060, 0x103c, 0x1c84, 0x3418, 0x04a8,
+ 0x4160, 0x113c, 0x1d84, 0x3518, 0x05a8,
+ 0x4164, 0x1140, 0x1d88, 0x351c, 0x05ac,
+ 0x4064, 0x1040, 0x1c88, 0x341c, 0x04ac,
+ 0x3f64, 0x0f40, 0x1b88, 0x331c, 0x03ac,
+ 0x3f68, 0x0f44, 0x1b8c, 0x3320, 0x03b0,
+ 0x4068, 0x1044, 0x1c8c, 0x3420, 0x04b0,
+ 0x4168, 0x1144, 0x1d8c, 0x3520, 0x05b0,
+ 0x4548, 0x1524, 0x216c, 0x3900, 0x0990,
+ 0x4648, 0x1624, 0x226c, 0x3a00, 0x0a90,
+ 0x4748, 0x1724, 0x236c, 0x3b00, 0x0b90,
+ 0x474c, 0x1728, 0x2370, 0x3b04, 0x0b94,
+ 0x464c, 0x1628, 0x2270, 0x3a04, 0x0a94,
+ 0x454c, 0x1528, 0x2170, 0x3904, 0x0994,
+ 0x4550, 0x152c, 0x2174, 0x3908, 0x0998,
+ 0x4650, 0x162c, 0x2274, 0x3a08, 0x0a98,
+ 0x4750, 0x172c, 0x2374, 0x3b08, 0x0b98,
+ 0x4754, 0x1730, 0x2378, 0x3b0c, 0x0b9c,
+ 0x4654, 0x1630, 0x2278, 0x3a0c, 0x0a9c,
+ 0x4554, 0x1530, 0x2178, 0x390c, 0x099c,
+ 0x4558, 0x1534, 0x217c, 0x3910, 0x09a0,
+ 0x4658, 0x1634, 0x227c, 0x3a10, 0x0aa0,
+ 0x4758, 0x1734, 0x237c, 0x3b10, 0x0ba0,
+ 0x475c, 0x1738, 0x2380, 0x3b14, 0x0ba4,
+ 0x465c, 0x1638, 0x2280, 0x3a14, 0x0aa4,
+ 0x455c, 0x1538, 0x2180, 0x3914, 0x09a4,
+ 0x4560, 0x153c, 0x2184, 0x3918, 0x09a8,
+ 0x4660, 0x163c, 0x2284, 0x3a18, 0x0aa8,
+ 0x4760, 0x173c, 0x2384, 0x3b18, 0x0ba8,
+ 0x4764, 0x1740, 0x2388, 0x3b1c, 0x0bac,
+ 0x4664, 0x1640, 0x2288, 0x3a1c, 0x0aac,
+ 0x4564, 0x1540, 0x2188, 0x391c, 0x09ac,
+ 0x4568, 0x1544, 0x218c, 0x3920, 0x09b0,
+ 0x4668, 0x1644, 0x228c, 0x3a20, 0x0ab0,
+ 0x4768, 0x1744, 0x238c, 0x3b20, 0x0bb0,
+ 0x0348, 0x1b24, 0x276c, 0x3f00, 0x0f90,
+ 0x0448, 0x1c24, 0x286c, 0x4000, 0x1090,
+ 0x0548, 0x1d24, 0x296c, 0x4100, 0x1190,
+ 0x054c, 0x1d28, 0x2970, 0x4104, 0x1194,
+ 0x044c, 0x1c28, 0x2870, 0x4004, 0x1094,
+ 0x034c, 0x1b28, 0x2770, 0x3f04, 0x0f94,
+ 0x0350, 0x1b2c, 0x2774, 0x3f08, 0x0f98,
+ 0x0450, 0x1c2c, 0x2874, 0x4008, 0x1098,
+ 0x0550, 0x1d2c, 0x2974, 0x4108, 0x1198,
+ 0x0554, 0x1d30, 0x2978, 0x410c, 0x119c,
+ 0x0454, 0x1c30, 0x2878, 0x400c, 0x109c,
+ 0x0354, 0x1b30, 0x2778, 0x3f0c, 0x0f9c,
+ 0x0358, 0x1b34, 0x277c, 0x3f10, 0x0fa0,
+ 0x0458, 0x1c34, 0x287c, 0x4010, 0x10a0,
+ 0x0558, 0x1d34, 0x297c, 0x4110, 0x11a0,
+ 0x055c, 0x1d38, 0x2980, 0x4114, 0x11a4,
+ 0x045c, 0x1c38, 0x2880, 0x4014, 0x10a4,
+ 0x035c, 0x1b38, 0x2780, 0x3f14, 0x0fa4,
+ 0x0360, 0x1b3c, 0x2784, 0x3f18, 0x0fa8,
+ 0x0460, 0x1c3c, 0x2884, 0x4018, 0x10a8,
+ 0x0560, 0x1d3c, 0x2984, 0x4118, 0x11a8,
+ 0x0564, 0x1d40, 0x2988, 0x411c, 0x11ac,
+ 0x0464, 0x1c40, 0x2888, 0x401c, 0x10ac,
+ 0x0364, 0x1b40, 0x2788, 0x3f1c, 0x0fac,
+ 0x0368, 0x1b44, 0x278c, 0x3f20, 0x0fb0,
+ 0x0468, 0x1c44, 0x288c, 0x4020, 0x10b0,
+ 0x0568, 0x1d44, 0x298c, 0x4120, 0x11b0,
+ 0x0948, 0x2124, 0x2d6c, 0x4500, 0x1590,
+ 0x0a48, 0x2224, 0x2e6c, 0x4600, 0x1690,
+ 0x0b48, 0x2324, 0x2f6c, 0x4700, 0x1790,
+ 0x0b4c, 0x2328, 0x2f70, 0x4704, 0x1794,
+ 0x0a4c, 0x2228, 0x2e70, 0x4604, 0x1694,
+ 0x094c, 0x2128, 0x2d70, 0x4504, 0x1594,
+ 0x0950, 0x212c, 0x2d74, 0x4508, 0x1598,
+ 0x0a50, 0x222c, 0x2e74, 0x4608, 0x1698,
+ 0x0b50, 0x232c, 0x2f74, 0x4708, 0x1798,
+ 0x0b54, 0x2330, 0x2f78, 0x470c, 0x179c,
+ 0x0a54, 0x2230, 0x2e78, 0x460c, 0x169c,
+ 0x0954, 0x2130, 0x2d78, 0x450c, 0x159c,
+ 0x0958, 0x2134, 0x2d7c, 0x4510, 0x15a0,
+ 0x0a58, 0x2234, 0x2e7c, 0x4610, 0x16a0,
+ 0x0b58, 0x2334, 0x2f7c, 0x4710, 0x17a0,
+ 0x0b5c, 0x2338, 0x2f80, 0x4714, 0x17a4,
+ 0x0a5c, 0x2238, 0x2e80, 0x4614, 0x16a4,
+ 0x095c, 0x2138, 0x2d80, 0x4514, 0x15a4,
+ 0x0960, 0x213c, 0x2d84, 0x4518, 0x15a8,
+ 0x0a60, 0x223c, 0x2e84, 0x4618, 0x16a8,
+ 0x0b60, 0x233c, 0x2f84, 0x4718, 0x17a8,
+ 0x0b64, 0x2340, 0x2f88, 0x471c, 0x17ac,
+ 0x0a64, 0x2240, 0x2e88, 0x461c, 0x16ac,
+ 0x0964, 0x2140, 0x2d88, 0x451c, 0x15ac,
+ 0x0968, 0x2144, 0x2d8c, 0x4520, 0x15b0,
+ 0x0a68, 0x2244, 0x2e8c, 0x4620, 0x16b0,
+ 0x0b68, 0x2344, 0x2f8c, 0x4720, 0x17b0,
 };
 
 /* DV25/50 DCT coefficient weights and inverse weights */
@@ -373,50 +2624,93 @@
  22017, 25191, 24457, 27962, 22733, 24600, 25971, 29642,
 };
 
-/**
- * The "inverse" DV100 weights are actually just the spec weights (zig-zagged).
- */
+/* DV100 weights are pre-zigzagged, inverted and multiplied by 2^(dv100_weight_shift)
+   (in DV100 the AC components are divided by the spec weights) */
+static const int dv100_weight_shift = 16;
+static const int dv_weight_1080_y[64] = {
+    8192, 65536, 65536, 61681, 61681, 61681, 58254, 58254,
+    58254, 58254, 58254, 58254, 55188, 58254, 58254, 55188,
+    55188, 55188, 55188, 55188, 55188, 24966, 27594, 26214,
+    26214, 26214, 27594, 24966, 23831, 24385, 25575, 25575,
+    25575, 25575, 24385, 23831, 23302, 23302, 24966, 24966,
+    24966, 23302, 23302, 21845, 22795, 24385, 24385, 22795,
+    21845, 21400, 21845, 23831, 21845, 21400, 10382, 10700,
+    10700, 10382, 10082, 9620, 10082, 9039, 9039, 8525,
+};
+static const int dv_weight_1080_c[64] = {
+    8192, 65536, 65536, 61681, 61681, 61681, 41943, 41943,
+    41943, 41943, 40330, 41943, 40330, 41943, 40330, 40330,
+    40330, 38836, 38836, 40330, 40330, 24966, 27594, 26214,
+    26214, 26214, 27594, 24966, 23831, 24385, 25575, 25575,
+    25575, 25575, 24385, 23831, 11523, 11523, 12483, 12483,
+    12483, 11523, 11523, 10923, 11275, 12193, 12193, 11275,
+    10923, 5323, 5490, 5924, 5490, 5323, 5165, 5323,
+    5323, 5165, 5017, 4788, 5017, 4520, 4520, 4263,
+};
+static const int dv_weight_720_y[64] = {
+    8192, 65536, 65536, 61681, 61681, 61681, 58254, 58254,
+    58254, 58254, 58254, 58254, 55188, 58254, 58254, 55188,
+    55188, 55188, 55188, 55188, 55188, 24966, 27594, 26214,
+    26214, 26214, 27594, 24966, 23831, 24385, 25575, 25575,
+    25575, 25575, 24385, 23831, 15420, 15420, 16644, 16644,
+    16644, 15420, 15420, 10923, 11398, 12193, 12193, 11398,
+    10923, 10700, 10923, 11916, 10923, 10700, 5191, 5350,
+    5350, 5191, 5041, 4810, 5041, 4520, 4520, 4263,
+};
+static const int dv_weight_720_c[64] = {
+    8192, 43691, 43691, 40330, 40330, 40330, 29127, 29127,
+    29127, 29127, 29127, 29127, 27594, 29127, 29127, 27594,
+    27594, 27594, 27594, 27594, 27594, 12483, 13797, 13107,
+    13107, 13107, 13797, 12483, 11916, 12193, 12788, 12788,
+    12788, 12788, 12193, 11916, 5761, 5761, 6242, 6242,
+    6242, 5761, 5761, 5461, 5638, 5461, 6096, 5638,
+    5461, 2661, 2745, 2962, 2745, 2661, 2583, 2661,
+    2661, 2583, 2509, 2394, 2509, 2260, 2260, 2131,
+};
+
+/* the "inverse" DV100 weights are actually just the spec weights (zig-zagged) */
 static const int dv_iweight_1080_y[64] = {
-    128,  16,  16,  17,  17,  17,  18,  18,
-     18,  18,  18,  18,  19,  18,  18,  19,
-     19,  19,  19,  19,  19,  42,  38,  40,
-     40,  40,  38,  42,  44,  43,  41,  41,
-     41,  41,  43,  44,  45,  45,  42,  42,
-     42,  45,  45,  48,  46,  43,  43,  46,
-     48,  49,  48,  44,  48,  49, 101,  98,
-     98, 101, 104, 109, 104, 116, 116, 123,
+    128, 16, 16, 17, 17, 17, 18, 18,
+    18, 18, 18, 18, 19, 18, 18, 19,
+    19, 19, 19, 19, 19, 42, 38, 40,
+    40, 40, 38, 42, 44, 43, 41, 41,
+    41, 41, 43, 44, 45, 45, 42, 42,
+    42, 45, 45, 48, 46, 43, 43, 46,
+    48, 49, 48, 44, 48, 49, 101, 98,
+    98, 101, 104, 109, 104, 116, 116, 123,
 };
 static const int dv_iweight_1080_c[64] = {
-    128,  16,  16,  17,  17,  17,  25,  25,
-     25,  25,  26,  25,  26,  25,  26,  26,
-     26,  27,  27,  26,  26,  42,  38,  40,
-     40,  40,  38,  42,  44,  43,  41,  41,
-     41,  41,  43,  44,  91,  91,  84,  84,
-     84,  91,  91,  96,  93,  86,  86,  93,
-     96, 197, 191, 177, 191, 197, 203, 197,
+    128, 16, 16, 17, 17, 17, 25, 25,
+    25, 25, 26, 25, 26, 25, 26, 26,
+    26, 27, 27, 26, 26, 42, 38, 40,
+    40, 40, 38, 42, 44, 43, 41, 41,
+    41, 41, 43, 44, 91, 91, 84, 84,
+    84, 91, 91, 96, 93, 86, 86, 93,
+    96, 197, 191, 177, 191, 197, 203, 197,
     197, 203, 209, 219, 209, 232, 232, 246,
 };
 static const int dv_iweight_720_y[64] = {
-    128,  16,  16,  17,  17,  17,  18,  18,
-     18,  18,  18,  18,  19,  18,  18,  19,
-     19,  19,  19,  19,  19,  42,  38,  40,
-     40,  40,  38,  42,  44,  43,  41,  41,
-     41,  41,  43,  44,  68,  68,  63,  63,
-     63,  68,  68,  96,  92,  86,  86,  92,
-     96,  98,  96,  88,  96,  98, 202, 196,
+    128, 16, 16, 17, 17, 17, 18, 18,
+    18, 18, 18, 18, 19, 18, 18, 19,
+    19, 19, 19, 19, 19, 42, 38, 40,
+    40, 40, 38, 42, 44, 43, 41, 41,
+    41, 41, 43, 44, 68, 68, 63, 63,
+    63, 68, 68, 96, 92, 86, 86, 92,
+    96, 98, 96, 88, 96, 98, 202, 196,
     196, 202, 208, 218, 208, 232, 232, 246,
 };
 static const int dv_iweight_720_c[64] = {
-    128,  24,  24,  26,  26,  26,  36,  36,
-     36,  36,  36,  36,  38,  36,  36,  38,
-     38,  38,  38,  38,  38,  84,  76,  80,
-     80,  80,  76,  84,  88,  86,  82,  82,
-     82,  82,  86,  88, 182, 182, 168, 168,
+    128, 24, 24, 26, 26, 26, 36, 36,
+    36, 36, 36, 36, 38, 36, 36, 38,
+    38, 38, 38, 38, 38, 84, 76, 80,
+    80, 80, 76, 84, 88, 86, 82, 82,
+    82, 82, 86, 88, 182, 182, 168, 168,
     168, 182, 182, 192, 186, 192, 172, 186,
     192, 394, 382, 354, 382, 394, 406, 394,
     394, 406, 418, 438, 418, 464, 464, 492,
 };
 
+
 static const uint8_t dv_audio_shuffle525[10][9] = {
   {  0, 30, 60, 20, 50, 80, 10, 40, 70 }, /* 1st channel */
   {  6, 36, 66, 26, 56, 86, 16, 46, 76 },
@@ -451,7 +2745,6 @@
     48000, 44100, 32000,
 };
 
-/* macroblock bit budgets */
 static const uint8_t block_sizes_dv2550[8] = {
     112, 112, 112, 112, 80, 80, 0, 0,
 };
@@ -460,19 +2753,12 @@
     80, 80, 80, 80, 80, 80, 64, 64,
 };
 
-static DVwork_chunk work_chunks_dv25pal   [1*12*27];
-static DVwork_chunk work_chunks_dv25pal411[1*12*27];
-static DVwork_chunk work_chunks_dv25ntsc  [1*10*27];
-static DVwork_chunk work_chunks_dv50pal   [2*12*27];
-static DVwork_chunk work_chunks_dv50ntsc  [2*10*27];
-static DVwork_chunk work_chunks_dv100palp [2*12*27];
-static DVwork_chunk work_chunks_dv100ntscp[2*10*27];
-static DVwork_chunk work_chunks_dv100pali [4*12*27];
-static DVwork_chunk work_chunks_dv100ntsci[4*10*27];
-
-static uint32_t dv_idct_factor_sd    [2*2*22*64];
-static uint32_t dv_idct_factor_hd1080[2*4*16*64];
-static uint32_t dv_idct_factor_hd720 [2*4*16*64];
+void find_macroblock_dv25_411(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10]);
+void find_macroblock_dv25_420(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10]);
+void find_macroblock_dv50(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10]);
+void find_macroblock_dv100_1080i60(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10]);
+void find_macroblock_dv100_1080i50(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10]);
+void find_macroblock_dv100_720p60(const struct DVprofile *sys, int channel, int seq, int av, int seg, int mbloc[10]);
 
 static const DVprofile dv_profiles[] = {
     { .dsf = 0,
@@ -480,18 +2766,20 @@
       .frame_size = 120000,        /* IEC 61834, SMPTE-314M - 525/60 (NTSC) */
       .difseg_size = 10,
       .n_difchan = 1,
-      .time_base = { 1001, 30000 },
+      .frame_rate = 30000,
       .ltc_divisor = 30,
+      .frame_rate_base = 1001,
       .height = 480,
       .width = 720,
       .sar = {{10, 11}, {40, 33}},
-      .work_chunks = &work_chunks_dv25ntsc[0],
-      .idct_factor = &dv_idct_factor_sd[0],
+      .video_place = dv_place_411,
+      .find_macroblock = find_macroblock_dv25_411,
       .pix_fmt = PIX_FMT_YUV411P,
       .bpm = 6,
       .block_sizes = block_sizes_dv2550,
+      .vs_total_ac_bits = (100 * 4 + 68*2) * 5,
       .audio_stride = 90,
-      .audio_min_samples  = { 1580, 1452, 1053 }, /* for 48, 44.1 and 32kHz */
+      .audio_min_samples = { 1580, 1452, 1053 }, /* for 48, 44.1 and 32Khz */
       .audio_samples_dist = { 1600, 1602, 1602, 1602, 1602 }, /* per SMPTE-314M */
       .audio_shuffle = dv_audio_shuffle525,
     },
@@ -500,18 +2788,20 @@
       .frame_size = 144000,        /* IEC 61834 - 625/50 (PAL) */
       .difseg_size = 12,
       .n_difchan = 1,
-      .time_base = { 1, 25 },
+      .frame_rate = 25,
+      .frame_rate_base = 1,
       .ltc_divisor = 25,
       .height = 576,
       .width = 720,
       .sar = {{59, 54}, {118, 81}},
-      .work_chunks = &work_chunks_dv25pal[0],
-      .idct_factor = &dv_idct_factor_sd[0],
+      .video_place = dv_place_420,
+      .find_macroblock = find_macroblock_dv25_420,
       .pix_fmt = PIX_FMT_YUV420P,
       .bpm = 6,
       .block_sizes = block_sizes_dv2550,
+      .vs_total_ac_bits = (100 * 4 + 68*2) * 5,
       .audio_stride = 108,
-      .audio_min_samples  = { 1896, 1742, 1264 }, /* for 48, 44.1 and 32kHz */
+      .audio_min_samples = { 1896, 1742, 1264 }, /* for 48, 44.1 and 32Khz */
       .audio_samples_dist = { 1920, 1920, 1920, 1920, 1920 },
       .audio_shuffle = dv_audio_shuffle625,
     },
@@ -520,18 +2810,20 @@
       .frame_size = 144000,        /* SMPTE-314M - 625/50 (PAL) */
       .difseg_size = 12,
       .n_difchan = 1,
-      .time_base = { 1, 25 },
+      .frame_rate = 25,
+      .frame_rate_base = 1,
       .ltc_divisor = 25,
       .height = 576,
       .width = 720,
       .sar = {{59, 54}, {118, 81}},
-      .work_chunks = &work_chunks_dv25pal411[0],
-      .idct_factor = &dv_idct_factor_sd[0],
+      .video_place = dv_place_411P,
+      .find_macroblock = find_macroblock_dv25_411,
       .pix_fmt = PIX_FMT_YUV411P,
       .bpm = 6,
       .block_sizes = block_sizes_dv2550,
+      .vs_total_ac_bits = (100 * 4 + 68*2) * 5,
       .audio_stride = 108,
-      .audio_min_samples  = { 1896, 1742, 1264 }, /* for 48, 44.1 and 32kHz */
+      .audio_min_samples = { 1896, 1742, 1264 }, /* for 48, 44.1 and 32Khz */
       .audio_samples_dist = { 1920, 1920, 1920, 1920, 1920 },
       .audio_shuffle = dv_audio_shuffle625,
     },
@@ -540,18 +2832,20 @@
       .frame_size = 240000,        /* SMPTE-314M - 525/60 (NTSC) 50 Mbps */
       .difseg_size = 10,           /* also known as "DVCPRO50" */
       .n_difchan = 2,
-      .time_base = { 1001, 30000 },
+      .frame_rate = 30000,
       .ltc_divisor = 30,
+      .frame_rate_base = 1001,
       .height = 480,
       .width = 720,
       .sar = {{10, 11}, {40, 33}},
-      .work_chunks = &work_chunks_dv50ntsc[0],
-      .idct_factor = &dv_idct_factor_sd[0],
+      .video_place = dv_place_422_525,
+      .find_macroblock = find_macroblock_dv50,
       .pix_fmt = PIX_FMT_YUV422P,
       .bpm = 6,
       .block_sizes = block_sizes_dv2550,
+      .vs_total_ac_bits = (100 * 4 + 68*2) * 5,
       .audio_stride = 90,
-      .audio_min_samples  = { 1580, 1452, 1053 }, /* for 48, 44.1 and 32kHz */
+      .audio_min_samples = { 1580, 1452, 1053 }, /* for 48, 44.1 and 32Khz */
       .audio_samples_dist = { 1600, 1602, 1602, 1602, 1602 }, /* per SMPTE-314M */
       .audio_shuffle = dv_audio_shuffle525,
     },
@@ -560,18 +2854,20 @@
       .frame_size = 288000,        /* SMPTE-314M - 625/50 (PAL) 50 Mbps */
       .difseg_size = 12,           /* also known as "DVCPRO50" */
       .n_difchan = 2,
-      .time_base = { 1, 25 },
+      .frame_rate = 25,
+      .frame_rate_base = 1,
       .ltc_divisor = 25,
       .height = 576,
       .width = 720,
       .sar = {{59, 54}, {118, 81}},
-      .work_chunks = &work_chunks_dv50pal[0],
-      .idct_factor = &dv_idct_factor_sd[0],
+      .video_place = dv_place_422_625,
+      .find_macroblock = find_macroblock_dv50,
       .pix_fmt = PIX_FMT_YUV422P,
       .bpm = 6,
       .block_sizes = block_sizes_dv2550,
+      .vs_total_ac_bits = (100 * 4 + 68*2) * 5,
       .audio_stride = 108,
-      .audio_min_samples  = { 1896, 1742, 1264 }, /* for 48, 44.1 and 32kHz */
+      .audio_min_samples = { 1896, 1742, 1264 }, /* for 48, 44.1 and 32Khz */
       .audio_samples_dist = { 1920, 1920, 1920, 1920, 1920 },
       .audio_shuffle = dv_audio_shuffle625,
     },
@@ -580,18 +2876,20 @@
       .frame_size = 480000,        /* SMPTE-370M - 1080i60 100 Mbps */
       .difseg_size = 10,           /* also known as "DVCPRO HD" */
       .n_difchan = 4,
-      .time_base = { 1001, 30000 },
+      .frame_rate = 30000,
       .ltc_divisor = 30,
+      .frame_rate_base = 1001,
       .height = 1080,
       .width = 1280,
       .sar = {{1, 1}, {1, 1}},
-      .work_chunks = &work_chunks_dv100ntsci[0],
-      .idct_factor = &dv_idct_factor_hd1080[0],
+      .video_place = 0,
+      .find_macroblock = find_macroblock_dv100_1080i60,
       .pix_fmt = PIX_FMT_YUV422P,
       .bpm = 8,
       .block_sizes = block_sizes_dv100,
+      .vs_total_ac_bits = (68*6 + 52*2) * 5,
       .audio_stride = 90,
-      .audio_min_samples  = { 1580, 1452, 1053 }, /* for 48, 44.1 and 32kHz */
+      .audio_min_samples = { 1580, 1452, 1053 }, /* for 48, 44.1 and 32Khz */
       .audio_samples_dist = { 1600, 1602, 1602, 1602, 1602 }, /* per SMPTE-314M */
       .audio_shuffle = dv_audio_shuffle525,
     },
@@ -600,61 +2898,45 @@
       .frame_size = 576000,        /* SMPTE-370M - 1080i50 100 Mbps */
       .difseg_size = 12,           /* also known as "DVCPRO HD" */
       .n_difchan = 4,
-      .time_base = { 1, 25 },
+      .frame_rate = 25,
+      .frame_rate_base = 1,
       .ltc_divisor = 25,
       .height = 1080,
       .width = 1440,
       .sar = {{1, 1}, {1, 1}},
-      .work_chunks = &work_chunks_dv100pali[0],
-      .idct_factor = &dv_idct_factor_hd1080[0],
+      .video_place = 0,
+      .find_macroblock = find_macroblock_dv100_1080i50,
       .pix_fmt = PIX_FMT_YUV422P,
       .bpm = 8,
       .block_sizes = block_sizes_dv100,
+      .vs_total_ac_bits = (68*6 + 52*2) * 5,
       .audio_stride = 108,
-      .audio_min_samples  = { 1896, 1742, 1264 }, /* for 48, 44.1 and 32kHz */
+      .audio_min_samples = { 1896, 1742, 1264 }, /* for 48, 44.1 and 32Khz */
       .audio_samples_dist = { 1920, 1920, 1920, 1920, 1920 },
       .audio_shuffle = dv_audio_shuffle625,
     },
     { .dsf = 0,
       .video_stype = 0x18,
-      .frame_size = 240000,        /* SMPTE-370M - 720p60 100 Mbps */
+      .frame_size = 480000,        /* SMPTE-370M - 720p60 100 Mbps */
       .difseg_size = 10,           /* also known as "DVCPRO HD" */
-      .n_difchan = 2,
-      .time_base = { 1001, 60000 },
-      .ltc_divisor = 60,
-      .height = 720,
+      .n_difchan = 4,
+      .frame_rate = 30000,
+      .ltc_divisor = 30,
+      .frame_rate_base = 1001,
+      .height = 1440,
       .width = 960,
       .sar = {{1, 1}, {1, 1}},
-      .work_chunks = &work_chunks_dv100ntscp[0],
-      .idct_factor = &dv_idct_factor_hd720[0],
+      .video_place = 0,
+      .find_macroblock = find_macroblock_dv100_720p60,
       .pix_fmt = PIX_FMT_YUV422P,
       .bpm = 8,
       .block_sizes = block_sizes_dv100,
+      .vs_total_ac_bits = (68*6 + 52*2) * 5,
       .audio_stride = 90,
-      .audio_min_samples  = { 1580, 1452, 1053 }, /* for 48, 44.1 and 32kHz */
+      .audio_min_samples = { 1580, 1452, 1053 }, /* for 48, 44.1 and 32Khz */
       .audio_samples_dist = { 1600, 1602, 1602, 1602, 1602 }, /* per SMPTE-314M */
       .audio_shuffle = dv_audio_shuffle525,
     },
-    { .dsf = 1,
-      .video_stype = 0x18,
-      .frame_size = 288000,        /* SMPTE-370M - 720p50 100 Mbps */
-      .difseg_size = 12,           /* also known as "DVCPRO HD" */
-      .n_difchan = 2,
-      .time_base = { 1, 50 },
-      .ltc_divisor = 50,
-      .height = 720,
-      .width = 960,
-      .sar = {{1, 1}, {1, 1}},
-      .work_chunks = &work_chunks_dv100palp[0],
-      .idct_factor = &dv_idct_factor_hd720[0],
-      .pix_fmt = PIX_FMT_YUV422P,
-      .bpm = 8,
-      .block_sizes = block_sizes_dv100,
-      .audio_stride = 90,
-      .audio_min_samples  = { 1896, 1742, 1264 }, /* for 48, 44.1 and 32kHz */
-      .audio_samples_dist = { 1920, 1920, 1920, 1920, 1920 },
-      .audio_shuffle = dv_audio_shuffle625,
-    }
 };
 
 enum dv_section_type {
@@ -667,7 +2949,7 @@
 
 enum dv_pack_type {
      dv_header525     = 0x3f, /* see dv_write_pack for important details on */
-     dv_header625     = 0xbf, /* these two packs */
+     dv_header625     = 0xbf, /* these three packs */
      dv_timecode      = 0x13,
      dv_audio_source  = 0x50,
      dv_audio_control = 0x51,
@@ -682,83 +2964,78 @@
 
 #define DV_PROFILE_IS_HD(p) ((p)->video_stype & 0x10)
 #define DV_PROFILE_IS_1080i50(p) (((p)->video_stype == 0x14) && ((p)->dsf == 1))
-#define DV_PROFILE_IS_720p50(p)  (((p)->video_stype == 0x18) && ((p)->dsf == 1))
+#define DV_PROFILE_IS_1080i60(p) (((p)->video_stype == 0x14) && ((p)->dsf == 0))
 
-/* minimum number of bytes to read from a DV stream in order to
-   determine the profile */
+/* minimum number of bytes to read from a DV stream in order to determine the profile */
 #define DV_PROFILE_BYTES (6*80) /* 6 DIF blocks */
 
-/**
- * largest possible DV frame, in bytes (1080i50)
- */
+/* largest possible DV frame, in bytes (1080i50) */
 #define DV_MAX_FRAME_SIZE 576000
 
-/**
- * maximum number of blocks per macroblock in any DV format
- */
-#define DV_MAX_BPM 8
-
 static inline const DVprofile* dv_frame_profile(const uint8_t* frame)
 {
-   int i;
+    int i;
 
-   int dsf = (frame[3] & 0x80) >> 7;
+    /* DSF flag */
+    int dsf = (frame[3] & 0x80) >> 7;
 
-   int stype = frame[80*5 + 48 + 3] & 0x1f;
+    /* VAUX stype */
+    int stype = frame[80*5 + 48 + 3] & 0x1f;
 
-   /* 576i50 25Mbps 4:1:1 is a special case */
-   if (dsf == 1 && stype == 0 && frame[5] & 0x07) {
-       return &dv_profiles[2];
-   }
+    /* 576i50 25Mbps 4:1:1 is a special case */
+    if (dsf == 1 && stype == 0 && ((frame[5] & 0x07) != 0)) {
+	return &dv_profiles[2];
+    }
 
-   for (i=0; i<FF_ARRAY_ELEMS(dv_profiles); i++)
-       if (dsf == dv_profiles[i].dsf && stype == dv_profiles[i].video_stype)
-           return &dv_profiles[i];
+    for (i=0; i<sizeof(dv_profiles)/sizeof(DVprofile); i++)
+	if (dsf == dv_profiles[i].dsf && stype == dv_profiles[i].video_stype)
+	    return &dv_profiles[i];
 
-   return NULL;
+    return NULL;
 }
 
-static const DVprofile* dv_codec_profile(AVCodecContext* codec)
+static inline const DVprofile* dv_codec_profile(AVCodecContext* codec)
 {
     int i;
 
-    for (i=0; i<FF_ARRAY_ELEMS(dv_profiles); i++)
-       if (codec->height  == dv_profiles[i].height  &&
-           codec->pix_fmt == dv_profiles[i].pix_fmt &&
-           codec->width   == dv_profiles[i].width)
-               return &dv_profiles[i];
+    for (i=0; i<sizeof(dv_profiles)/sizeof(DVprofile); i++)
+       if (codec->height == dv_profiles[i].height && codec->pix_fmt == dv_profiles[i].pix_fmt &&
+	   codec->width == dv_profiles[i].width)
+           return &dv_profiles[i];
 
     return NULL;
 }
 
-static inline int dv_write_dif_id(enum dv_section_type t, uint8_t chan_num,
-                                  uint8_t seq_num, uint8_t dif_num,
-                                  uint8_t* buf)
+static inline int dv_write_dif_id(enum dv_section_type t, uint8_t chan_num, uint8_t seq_num,
+                                  uint8_t dif_num, uint8_t* buf)
 {
-    buf[0] = (uint8_t)t;       /* Section type */
-    buf[1] = (seq_num  << 4) | /* DIF seq number 0-9 for 525/60; 0-11 for 625/50 */
-             (chan_num << 3) | /* FSC: for 50Mb/s 0 - first channel; 1 - second */
-             7;                /* reserved -- always 1 */
-    buf[2] = dif_num;          /* DIF block number Video: 0-134, Audio: 0-8 */
+    int fsc = chan_num & 1;
+    int fsp = 1 - (chan_num >> 1);
+
+    buf[0] = (uint8_t)t;    /* Section type */
+    buf[1] = (seq_num<<4) | /* DIF seq number 0-9 for 525/60; 0-11 for 625/50 */
+             (fsc << 3) |   /* FSC: for 50 and 100Mb/s 0 - first channel; 1 - second */
+	     (fsp << 2) |   /* FSP: for 100Mb/s 0 - channels 0-1; 1 - channels 2-3 */
+             3;             /* reserved -- always 1 */
+    buf[2] = dif_num;       /* DIF block number Video: 0-134, Audio: 0-8 */
     return 3;
 }
 
-
 static inline int dv_write_ssyb_id(uint8_t syb_num, uint8_t fr, uint8_t* buf)
 {
     if (syb_num == 0 || syb_num == 6) {
-        buf[0] = (fr << 7) | /* FR ID 1 - first half of each channel; 0 - second */
-                 (0  << 4) | /* AP3 (Subcode application ID) */
-                 0x0f;       /* reserved -- always 1 */
+        buf[0] = (fr<<7) | /* FR ID 1 - first half of each channel; 0 - second */
+                 (0<<4)  | /* AP3 (Subcode application ID) */
+                 0x0f;     /* reserved -- always 1 */
     }
     else if (syb_num == 11) {
-        buf[0] = (fr << 7) | /* FR ID 1 - first half of each channel; 0 - second */
-                 0x7f;       /* reserved -- always 1 */
+        buf[0] = (fr<<7) | /* FR ID 1 - first half of each channel; 0 - second */
+                 0x7f;     /* reserved -- always 1 */
     }
     else {
-        buf[0] = (fr << 7) | /* FR ID 1 - first half of each channel; 0 - second */
-                 (0  << 4) | /* APT (Track application ID) */
-                 0x0f;       /* reserved -- always 1 */
+        buf[0] = (fr<<7) | /* FR ID 1 - first half of each channel; 0 - second */
+                 (0<<4)  | /* APT (Track application ID) */
+                 0x0f;     /* reserved -- always 1 */
     }
     buf[1] = 0xf0 |            /* reserved -- always 1 */
              (syb_num & 0x0f); /* SSYB number 0 - 11   */
--- libavformat/dvenc.c	2009-01-20 02:46:40.000000000 +1100
+++ ../ffmpeg-0.5-DVCPROHD/libavformat/dvenc.c	2009-03-16 12:11:28.083444869 +1100
@@ -34,17 +34,9 @@
 #include "dv.h"
 #include "libavutil/fifo.h"
 
-struct DVMuxContext {
-    const DVprofile*  sys;           /* current DV profile, e.g.: 525/60, 625/50 */
-    int               n_ast;         /* number of stereo audio streams (up to 2) */
-    AVStream         *ast[2];        /* stereo audio streams */
-    AVFifoBuffer      audio_data[2]; /* FIFO for storing excessive amounts of PCM */
-    int               frames;        /* current frame number */
-    time_t            start_time;    /* recording start time */
-    int               has_audio;     /* frame under contruction has audio */
-    int               has_video;     /* frame under contruction has video */
-    uint8_t           frame_buf[DV_MAX_FRAME_SIZE]; /* frame under contruction */
-};
+/* DJM - DVMuxContext moved to dv.h for use by fastencode */
+/* DJM - for fastencode */
+const DVprofile* dv_get_codec_profile(AVCodecContext *codec) { return dv_codec_profile(codec); }
 
 static const int dv_aaux_packs_dist[12][9] = {
     { 0xff, 0xff, 0xff, 0x50, 0x51, 0x52, 0x53, 0xff, 0xff },
@@ -63,63 +55,69 @@
 
 static int dv_audio_frame_size(const DVprofile* sys, int frame)
 {
-    return sys->audio_samples_dist[frame % (sizeof(sys->audio_samples_dist) /
+    return sys->audio_samples_dist[frame % (sizeof(sys->audio_samples_dist)/
                                             sizeof(sys->audio_samples_dist[0]))];
 }
 
-static int dv_write_pack(enum dv_pack_type pack_id, DVMuxContext *c, uint8_t* buf, ...)
+static int dv_write_pack(enum dv_pack_type pack_id, DVMuxContext *c, uint8_t* buf, int seq)
 {
     struct tm tc;
     time_t ct;
     int ltc_frame;
-    va_list ap;
+
+    /* Its hard to tell what SMPTE requires w.r.t. APT, but Quicktime needs it.
+     * We set it based on pix_fmt value but it really should be per DV profile */
+    int apt;
+    if (DV_PROFILE_IS_HD(c->sys)) {
+        apt = 0;
+    } else {
+        apt = (c->sys->pix_fmt == PIX_FMT_YUV422P ? 1 : 0);
+    }
 
     buf[0] = (uint8_t)pack_id;
     switch (pack_id) {
     case dv_timecode:
-        ct = (time_t)av_rescale_rnd(c->frames, c->sys->time_base.num,
-                                    c->sys->time_base.den, AV_ROUND_DOWN);
+        ct = (time_t)(c->frames / ((float)c->sys->frame_rate /
+                                   (float)c->sys->frame_rate_base));
         brktimegm(ct, &tc);
         /*
          * LTC drop-frame frame counter drops two frames (0 and 1) every
          * minute, unless it is exactly divisible by 10
          */
-        ltc_frame = (c->frames + 2 * ct / 60 - 2 * ct / 600) % c->sys->ltc_divisor;
-        buf[1] = (0                 << 7) | /* color frame: 0 - unsync; 1 - sync mode */
-                 (1                 << 6) | /* drop frame timecode: 0 - nondrop; 1 - drop */
-                 ((ltc_frame / 10)  << 4) | /* tens of frames */
-                 (ltc_frame % 10);          /* units of frames */
-        buf[2] = (1                 << 7) | /* biphase mark polarity correction: 0 - even; 1 - odd */
-                 ((tc.tm_sec / 10)  << 4) | /* tens of seconds */
-                 (tc.tm_sec % 10);          /* units of seconds */
-        buf[3] = (1                 << 7) | /* binary group flag BGF0 */
-                 ((tc.tm_min / 10)  << 4) | /* tens of minutes */
-                 (tc.tm_min % 10);          /* units of minutes */
-        buf[4] = (1                 << 7) | /* binary group flag BGF2 */
-                 (1                 << 6) | /* binary group flag BGF1 */
-                 ((tc.tm_hour / 10) << 4) | /* tens of hours */
-                 (tc.tm_hour % 10);         /* units of hours */
+        ltc_frame = (c->frames + 2*ct/60 - 2*ct/600) % c->sys->ltc_divisor;
+        buf[1] = (0 << 7) | /* Color fame: 0 - unsync; 1 - sync mode */
+                 (1 << 6) | /* Drop frame timecode: 0 - nondrop; 1 - drop */
+                 ((ltc_frame / 10) << 4) | /* Tens of frames */
+                 (ltc_frame % 10);         /* Units of frames */
+        buf[2] = (1 << 7) | /* Biphase mark polarity correction: 0 - even; 1 - odd */
+                 ((tc.tm_sec / 10) << 4) | /* Tens of seconds */
+                 (tc.tm_sec % 10);         /* Units of seconds */
+        buf[3] = (1 << 7) | /* Binary group flag BGF0 */
+                 ((tc.tm_min / 10) << 4) | /* Tens of minutes */
+                 (tc.tm_min % 10);         /* Units of minutes */
+        buf[4] = (1 << 7) | /* Binary group flag BGF2 */
+                 (1 << 6) | /* Binary group flag BGF1 */
+                 ((tc.tm_hour / 10) << 4) | /* Tens of hours */
+                 (tc.tm_hour % 10);         /* Units of hours */
         break;
     case dv_audio_source:  /* AAUX source pack */
-        va_start(ap, buf);
-        buf[1] = (1 << 7) | /* locked mode -- SMPTE only supports locked mode */
+        buf[1] = (0 << 7) | /* locked mode       */
                  (1 << 6) | /* reserved -- always 1 */
                  (dv_audio_frame_size(c->sys, c->frames) -
                   c->sys->audio_min_samples[0]);
                             /* # of samples      */
         buf[2] = (0 << 7) | /* multi-stereo      */
                  (0 << 5) | /* #of audio channels per block: 0 -- 1 channel */
-                 (0 << 4) | /* pair bit: 0 -- one pair of channels */
-                 !!va_arg(ap, int); /* audio mode        */
+                 (1 << 4) | /* reserved */
+                 ((seq >= c->sys->difseg_size/2) ? 1 : 0); /* audio mode (1st or 2nd channel) */
         buf[3] = (1 << 7) | /* res               */
                  (1 << 6) | /* multi-language flag */
                  (c->sys->dsf << 5) | /*  system: 60fields/50fields */
-                 (c->sys->n_difchan & 2); /* definition: 0 -- 25Mbps, 2 -- 50Mbps */
+                 (DV_PROFILE_IS_HD(c->sys) ? 0x3 : (apt<<1)); /* stype */
         buf[4] = (1 << 7) | /* emphasis: 1 -- off */
                  (0 << 6) | /* emphasis time constant: 0 -- reserved */
-                 (0 << 3) | /* frequency: 0 -- 48kHz, 1 -- 44,1kHz, 2 -- 32kHz */
+                 (0 << 3) | /* frequency: 0 -- 48Khz, 1 -- 44,1Khz, 2 -- 32Khz */
                   0;        /* quantization: 0 -- 16bit linear, 1 -- 12bit nonlinear */
-        va_end(ap);
         break;
     case dv_audio_control:
         buf[1] = (0 << 6) | /* copy protection: 0 -- unrestricted */
@@ -132,14 +130,14 @@
                   7;
         buf[3] = (1 << 7) | /* direction: 1 -- forward */
                  (c->sys->pix_fmt == PIX_FMT_YUV420P ? 0x20 : /* speed */
-                                                       c->sys->ltc_divisor * 4);
+                                                       c->sys->ltc_divisor*4);
         buf[4] = (1 << 7) | /* reserved -- always 1 */
                   0x7f;     /* genre category */
         break;
     case dv_audio_recdate:
     case dv_video_recdate:  /* VAUX recording date */
-        ct = c->start_time + av_rescale_rnd(c->frames, c->sys->time_base.num,
-                                            c->sys->time_base.den, AV_ROUND_DOWN);
+        ct = c->start_time + (time_t)(c->frames /
+             ((float)c->sys->frame_rate / (float)c->sys->frame_rate_base));
         brktimegm(ct, &tc);
         buf[1] = 0xff; /* ds, tm, tens of time zone, units of time zone */
                        /* 0xff is very likely to be "unknown" */
@@ -154,8 +152,8 @@
         break;
     case dv_audio_rectime:  /* AAUX recording time */
     case dv_video_rectime:  /* VAUX recording time */
-        ct = c->start_time + av_rescale_rnd(c->frames, c->sys->time_base.num,
-                                                       c->sys->time_base.den, AV_ROUND_DOWN);
+        ct = c->start_time + (time_t)(c->frames /
+             ((float)c->sys->frame_rate / (float)c->sys->frame_rate_base));
         brktimegm(ct, &tc);
         buf[1] = (3 << 6) | /* reserved -- always 1 */
                  0x3f; /* tens of frame, units of frame: 0x3f - "unknown" ? */
@@ -183,45 +181,69 @@
     for (i = 0; i < c->sys->difseg_size; i++) {
         frame_ptr += 6 * 80; /* skip DIF segment header */
         for (j = 0; j < 9; j++) {
-            dv_write_pack(dv_aaux_packs_dist[i][j], c, &frame_ptr[3], i >= c->sys->difseg_size/2);
+            dv_write_pack(dv_aaux_packs_dist[i][j], c, &frame_ptr[3], i);
             for (d = 8; d < 80; d+=2) {
                 of = c->sys->audio_shuffle[i][j] + (d - 8)/2 * c->sys->audio_stride;
                 if (of*2 >= size)
                     continue;
 
-                frame_ptr[d]   = av_fifo_peek(&c->audio_data[channel], of*2+1); // FIXME: maybe we have to admit
-                frame_ptr[d+1] = av_fifo_peek(&c->audio_data[channel], of*2);   //        that DV is a big-endian PCM
+                frame_ptr[d] = av_fifo_peek(&c->audio_data[channel], of*2+1); // FIXME: may be we have to admit
+                frame_ptr[d+1] = av_fifo_peek(&c->audio_data[channel], of*2); //        that DV is a big endian PCM
             }
             frame_ptr += 16 * 80; /* 15 Video DIFs + 1 Audio DIF */
         }
     }
 }
 
-static void dv_inject_metadata(DVMuxContext *c, uint8_t* frame)
+/* DJM - exported for fastencode */
+void dv_inject_audio_raw(DVMuxContext *c, int channel, uint8_t* frame_ptr, uint8_t *data)
+{
+    int i, j, d, of, size;
+    size = 4 * dv_audio_frame_size(c->sys, c->frames);
+    frame_ptr += channel * c->sys->difseg_size * 150 * 80;
+    for (i = 0; i < c->sys->difseg_size; i++) {
+       frame_ptr += 6 * 80; /* skip DIF segment header */
+       for (j = 0; j < 9; j++) {
+          dv_write_pack(dv_aaux_packs_dist[i][j], c, &frame_ptr[3], i);
+          for (d = 8; d < 80; d+=2) {
+             of = c->sys->audio_shuffle[i][j] + (d - 8)/2 * c->sys->audio_stride;
+             if (of*2 >= size)
+                 continue;
+
+             frame_ptr[d] = data[of*2+1];
+             frame_ptr[d+1] = data[of*2];
+          }
+          frame_ptr += 16 * 80; /* 15 Video DIFs + 1 Audio DIF */
+       }
+    }
+}
+
+void dv_inject_metadata(DVMuxContext *c, uint8_t* frame)
 {
     int j, k;
     uint8_t* buf;
+    int seq = 0;
 
-    for (buf = frame; buf < frame + c->sys->frame_size; buf += 150 * 80) {
+    for (buf = frame; buf < frame + c->sys->frame_size; buf += 150 * 80, seq++) {
         /* DV subcode: 2nd and 3d DIFs */
         for (j = 80; j < 80 * 3; j += 80) {
             for (k = 6; k < 6 * 8; k += 8)
-                dv_write_pack(dv_timecode, c, &buf[j+k]);
+                dv_write_pack(dv_timecode, c, &buf[j+k], seq);
 
             if (((long)(buf-frame)/(c->sys->frame_size/(c->sys->difseg_size*c->sys->n_difchan))%c->sys->difseg_size) > 5) { /* FIXME: is this really needed ? */
-                dv_write_pack(dv_video_recdate, c, &buf[j+14]);
-                dv_write_pack(dv_video_rectime, c, &buf[j+22]);
-                dv_write_pack(dv_video_recdate, c, &buf[j+38]);
-                dv_write_pack(dv_video_rectime, c, &buf[j+46]);
+                dv_write_pack(dv_video_recdate, c, &buf[j+14], seq);
+                dv_write_pack(dv_video_rectime, c, &buf[j+22], seq);
+                dv_write_pack(dv_video_recdate, c, &buf[j+38], seq);
+                dv_write_pack(dv_video_rectime, c, &buf[j+46], seq);
             }
         }
 
         /* DV VAUX: 4th, 5th and 6th 3DIFs */
         for (j = 80*3 + 3; j < 80*6; j += 80) {
-            dv_write_pack(dv_video_recdate, c, &buf[j+5*2]);
-            dv_write_pack(dv_video_rectime, c, &buf[j+5*3]);
-            dv_write_pack(dv_video_recdate, c, &buf[j+5*11]);
-            dv_write_pack(dv_video_rectime, c, &buf[j+5*12]);
+            dv_write_pack(dv_video_recdate, c, &buf[j+5*2], seq);
+            dv_write_pack(dv_video_rectime, c, &buf[j+5*3], seq);
+            dv_write_pack(dv_video_recdate, c, &buf[j+5*11], seq);
+            dv_write_pack(dv_video_rectime, c, &buf[j+5*12], seq);
         }
     }
 }
@@ -231,7 +253,7 @@
  */
 
 int dv_assemble_frame(DVMuxContext *c, AVStream* st,
-                      uint8_t* data, int data_size, uint8_t** frame)
+                      const uint8_t* data, int data_size, uint8_t** frame)
 {
     int i, reqasize;
 
@@ -264,10 +286,10 @@
     }
 
     /* Let us see if we have enough data to construct one DV frame. */
-    if (c->has_video == 1 && c->has_audio + 1 == 1 << c->n_ast) {
+    if (c->has_video == 1 && c->has_audio + 1 == 1<<c->n_ast) {
         dv_inject_metadata(c, *frame);
         c->has_audio = 0;
-        for (i=0; i < c->n_ast; i++) {
+        for (i=0; i<c->n_ast; i++) {
             dv_inject_audio(c, i, *frame);
             av_fifo_drain(&c->audio_data[i], reqasize);
             c->has_audio |= ((reqasize <= av_fifo_size(&c->audio_data[i])) << i);
@@ -289,12 +311,12 @@
     AVStream *vst = NULL;
     int i;
 
-    /* we support at most 1 video and 2 audio streams */
-    if (s->nb_streams > 3)
+    /* we support at most 1 video and 4 audio streams */
+    if (s->nb_streams > 5)
         return NULL;
 
-    c->n_ast  = 0;
-    c->ast[0] = c->ast[1] = NULL;
+    c->n_ast = 0;
+    c->ast[0] = c->ast[1] = c->ast[2] = c->ast[3] = NULL;
 
     /* We have to sort out where audio and where video stream is */
     for (i=0; i<s->nb_streams; i++) {
@@ -316,29 +338,31 @@
     if (!vst || vst->codec->codec_id != CODEC_ID_DVVIDEO)
         goto bail_out;
     for (i=0; i<c->n_ast; i++) {
-        if (c->ast[i] && (c->ast[i]->codec->codec_id    != CODEC_ID_PCM_S16LE ||
+        if (c->ast[i] && (c->ast[i]->codec->codec_id != CODEC_ID_PCM_S16LE ||
                           c->ast[i]->codec->sample_rate != 48000 ||
-                          c->ast[i]->codec->channels    != 2))
+                          c->ast[i]->codec->channels != 2))
             goto bail_out;
     }
     c->sys = dv_codec_profile(vst->codec);
     if (!c->sys)
         goto bail_out;
 
-    if ((c->n_ast > 1) && (c->sys->n_difchan < 2)) {
+    if(((c->n_ast > 1) && (c->sys->n_difchan < 2)) ||
+       ((c->n_ast > 2) && (c->sys->n_difchan < 4))) {
         /* only 1 stereo pair is allowed in 25Mbps mode */
+        /* only 2 stereo pairs allowed in 50Mbps mode */
         goto bail_out;
     }
 
     /* Ok, everything seems to be in working order */
-    c->frames     = 0;
-    c->has_audio  = 0;
-    c->has_video  = 0;
+    c->frames = 0;
+    c->has_audio = 0;
+    c->has_video = 0;
     c->start_time = (time_t)s->timestamp;
 
-    for (i=0; i < c->n_ast; i++) {
+    for (i=0; i<c->n_ast; i++) {
         if (c->ast[i] && av_fifo_init(&c->audio_data[i], 100*AVCODEC_MAX_AUDIO_FRAME_SIZE) < 0) {
-            while (i > 0) {
+            while (i>0) {
                 i--;
                 av_fifo_free(&c->audio_data[i]);
             }
--- libavformat/dv.c	2009-02-26 19:45:59.000000000 +1100
+++ ../ffmpeg-0.5-DVCPROHD/libavformat/dv.c	2009-03-16 12:11:28.083444869 +1100
@@ -36,14 +36,14 @@
 
 struct DVDemuxContext {
     const DVprofile*  sys;    /* Current DV profile. E.g.: 525/60, 625/50 */
-    AVFormatContext*  fctx;
-    AVStream*         vst;
-    AVStream*         ast[4];
-    AVPacket          audio_pkt[4];
-    uint8_t           audio_buf[4][8192];
-    int               ach;
-    int               frames;
-    uint64_t          abytes;
+    AVFormatContext* fctx;
+    AVStream*        vst;
+    AVStream*        ast[4];
+    AVPacket         audio_pkt[4];
+    uint8_t          audio_buf[4][8192];
+    int              ach;
+    int              frames;
+    uint64_t         abytes;
 };
 
 static inline uint16_t dv_audio_12to16(uint16_t sample)
@@ -51,7 +51,7 @@
     uint16_t shift, result;
 
     sample = (sample < 0x800) ? sample : sample | 0xf000;
-    shift  = (sample & 0xf00) >> 8;
+    shift = (sample & 0xf00) >> 8;
 
     if (shift < 0x2 || shift > 0xd) {
         result = sample;
@@ -77,16 +77,16 @@
 
     switch (t) {
     case dv_audio_source:
-        offs = (80*6 + 80*16*3 + 3);
-        break;
+          offs = (80*6 + 80*16*3 + 3);
+          break;
     case dv_audio_control:
-        offs = (80*6 + 80*16*4 + 3);
-        break;
+          offs = (80*6 + 80*16*4 + 3);
+          break;
     case dv_video_control:
-        offs = (80*5 + 48 + 5);
-        break;
+          offs = (80*5 + 48 + 5);
+          break;
     default:
-        return NULL;
+          return NULL;
     }
 
     return frame[offs] == t ? &frame[offs] : NULL;
@@ -100,7 +100,7 @@
  * 3. Audio is always returned as 16bit linear samples: 12bit nonlinear samples
  *    are converted into 16bit linear ones.
  */
-static int dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4],
+static int dv_extract_audio(uint8_t* frame, uint8_t *ppcm[4],
                             const DVprofile *sys)
 {
     int size, chan, i, j, d, of, smpls, freq, quant, half_ch;
@@ -112,20 +112,18 @@
     if (!as_pack)    /* No audio ? */
         return 0;
 
-    smpls =  as_pack[1] & 0x3f;       /* samples in this frame - min. samples */
-    freq  = (as_pack[4] >> 3) & 0x07; /* 0 - 48kHz, 1 - 44,1kHz, 2 - 32kHz */
-    quant =  as_pack[4] & 0x07;       /* 0 - 16bit linear, 1 - 12bit nonlinear */
+    smpls = as_pack[1] & 0x3f; /* samples in this frame - min. samples */
+    freq = (as_pack[4] >> 3) & 0x07; /* 0 - 48KHz, 1 - 44,1kHz, 2 - 32 kHz */
+    quant = as_pack[4] & 0x07; /* 0 - 16bit linear, 1 - 12bit nonlinear */
 
     if (quant > 1)
-        return -1; /* unsupported quantization */
+        return -1; /* Unsupported quantization */
 
     size = (sys->audio_min_samples[freq] + smpls) * 4; /* 2ch, 2bytes */
-    half_ch = sys->difseg_size / 2;
+    half_ch = sys->difseg_size/2;
 
-    /* We work with 720p frames split in half, thus even frames have
-     * channels 0,1 and odd 2,3. */
-    ipcm = (sys->height == 720 && !(frame[1] & 0x0C)) ? 2 : 0;
-    pcm  = ppcm[ipcm++];
+    ipcm = 0;
+    pcm = ppcm[ipcm++];
 
     /* for each DIF channel */
     for (chan = 0; chan < sys->n_difchan; chan++) {
@@ -134,41 +132,42 @@
             frame += 6 * 80; /* skip DIF segment header */
             if (quant == 1 && i == half_ch) {
                 /* next stereo channel (12bit mode only) */
-                pcm = ppcm[ipcm++];
-                if (!pcm)
-                    break;
+		assert(ipcm == 1);
+		pcm = ppcm[ipcm++];
+		if (!pcm)
+		    break;
             }
 
             /* for each AV sequence */
             for (j = 0; j < 9; j++) {
                 for (d = 8; d < 80; d += 2) {
                     if (quant == 0) {  /* 16bit quantization */
-                        of = sys->audio_shuffle[i][j] + (d - 8) / 2 * sys->audio_stride;
+                        of = sys->audio_shuffle[i][j] + (d - 8)/2 * sys->audio_stride;
                         if (of*2 >= size)
                             continue;
 
-                        pcm[of*2]   = frame[d+1]; // FIXME: maybe we have to admit
-                        pcm[of*2+1] = frame[d];   //        that DV is a big-endian PCM
+                        pcm[of*2] = frame[d+1]; // FIXME: may be we have to admit
+                        pcm[of*2+1] = frame[d]; //        that DV is a big endian PCM
                         if (pcm[of*2+1] == 0x80 && pcm[of*2] == 0x00)
                             pcm[of*2+1] = 0;
                     } else {           /* 12bit quantization */
-                        lc = ((uint16_t)frame[d]   << 4) |
+                        lc = ((uint16_t)frame[d] << 4) |
                              ((uint16_t)frame[d+2] >> 4);
                         rc = ((uint16_t)frame[d+1] << 4) |
                              ((uint16_t)frame[d+2] & 0x0f);
                         lc = (lc == 0x800 ? 0 : dv_audio_12to16(lc));
                         rc = (rc == 0x800 ? 0 : dv_audio_12to16(rc));
 
-                        of = sys->audio_shuffle[i%half_ch][j] + (d - 8) / 3 * sys->audio_stride;
+                        of = sys->audio_shuffle[i%half_ch][j] + (d - 8)/3 * sys->audio_stride;
                         if (of*2 >= size)
                             continue;
 
-                        pcm[of*2]   = lc & 0xff; // FIXME: maybe we have to admit
-                        pcm[of*2+1] = lc >> 8;   //        that DV is a big-endian PCM
+                        pcm[of*2] = lc & 0xff; // FIXME: may be we have to admit
+                        pcm[of*2+1] = lc >> 8; //        that DV is a big endian PCM
                         of = sys->audio_shuffle[i%half_ch+half_ch][j] +
-                            (d - 8) / 3 * sys->audio_stride;
-                        pcm[of*2]   = rc & 0xff; // FIXME: maybe we have to admit
-                        pcm[of*2+1] = rc >> 8;   //        that DV is a big-endian PCM
+                            (d - 8)/3 * sys->audio_stride;
+                        pcm[of*2] = rc & 0xff; // FIXME: may be we have to admit
+                        pcm[of*2+1] = rc >> 8; //        that DV is a big endian PCM
                         ++d;
                     }
                 }
@@ -177,10 +176,10 @@
             }
         }
 
-        /* next stereo channel (50Mbps and 100Mbps only) */
-        pcm = ppcm[ipcm++];
-        if (!pcm)
-            break;
+        /* next stereo channel (50Mbps/100Mbps only) */
+	pcm = ppcm[ipcm++];
+	if (!pcm)
+	    break;
     }
 
     return size;
@@ -197,36 +196,40 @@
         return 0;
     }
 
-    smpls =  as_pack[1] & 0x3f;       /* samples in this frame - min. samples */
-    freq  = (as_pack[4] >> 3) & 0x07; /* 0 - 48kHz, 1 - 44,1kHz, 2 - 32kHz */
-    stype = (as_pack[3] & 0x1f);      /* 0 - 2CH, 2 - 4CH, 3 - 8CH */
-    quant =  as_pack[4] & 0x07;       /* 0 - 16bit linear, 1 - 12bit nonlinear */
+    smpls = as_pack[1] & 0x3f; /* samples in this frame - min. samples */
+    freq = (as_pack[4] >> 3) & 0x07; /* 0 - 48KHz, 1 - 44,1kHz, 2 - 32 kHz */
+    stype = (as_pack[3] & 0x1f); /* 0 - 2CH, 2 - 4CH, 3 - 8CH */
+    quant = as_pack[4] & 0x07; /* 0 - 16bit linear, 1 - 12bit nonlinear */
 
     /* note: ach counts PAIRS of channels (i.e. stereo channels) */
-    ach = ((int[4]){  1,  0,  2,  4})[stype];
-    if (ach == 1 && quant && freq == 2)
-        ach = 2;
+    if (stype == 3) {
+	ach = 4;
+    } else if (stype == 2 || (quant && (freq == 2))) {
+	ach = 2;
+    } else {
+	ach = 1;
+    }
 
     /* Dynamic handling of the audio streams in DV */
-    for (i = 0; i < ach; i++) {
+    for (i=0; i<ach; i++) {
        if (!c->ast[i]) {
            c->ast[i] = av_new_stream(c->fctx, 0);
            if (!c->ast[i])
                break;
            av_set_pts_info(c->ast[i], 64, 1, 30000);
            c->ast[i]->codec->codec_type = CODEC_TYPE_AUDIO;
-           c->ast[i]->codec->codec_id   = CODEC_ID_PCM_S16LE;
+           c->ast[i]->codec->codec_id = CODEC_ID_PCM_S16LE;
 
            av_init_packet(&c->audio_pkt[i]);
-           c->audio_pkt[i].size         = 0;
-           c->audio_pkt[i].data         = c->audio_buf[i];
+           c->audio_pkt[i].size     = 0;
+           c->audio_pkt[i].data     = c->audio_buf[i];
            c->audio_pkt[i].stream_index = c->ast[i]->index;
-           c->audio_pkt[i].flags       |= PKT_FLAG_KEY;
+           c->audio_pkt[i].flags |= PKT_FLAG_KEY;
        }
        c->ast[i]->codec->sample_rate = dv_audio_frequency[freq];
-       c->ast[i]->codec->channels    = 2;
-       c->ast[i]->codec->bit_rate    = 2 * dv_audio_frequency[freq] * 16;
-       c->ast[i]->start_time         = 0;
+       c->ast[i]->codec->channels = 2;
+       c->ast[i]->codec->bit_rate = 2 * dv_audio_frequency[freq] * 16;
+       c->ast[i]->start_time = 0;
     }
     c->ach = i;
 
@@ -243,10 +246,9 @@
     if (c->sys) {
         avctx = c->vst->codec;
 
-        av_set_pts_info(c->vst, 64, c->sys->time_base.num,
-                        c->sys->time_base.den);
-        avctx->time_base= c->sys->time_base;
-        if (!avctx->width){
+        av_set_pts_info(c->vst, 64, c->sys->frame_rate_base, c->sys->frame_rate);
+        avctx->time_base= (AVRational){c->sys->frame_rate_base, c->sys->frame_rate};
+        if(!avctx->width){
             avctx->width = c->sys->width;
             avctx->height = c->sys->height;
         }
@@ -254,12 +256,13 @@
 
         /* finding out SAR is a little bit messy */
         vsc_pack = dv_extract_pack(frame, dv_video_control);
-        apt      = frame[4] & 0x07;
-        is16_9   = (vsc_pack && ((vsc_pack[2] & 0x07) == 0x02 ||
-                                (!apt && (vsc_pack[2] & 0x07) == 0x07)));
-        c->vst->sample_aspect_ratio = c->sys->sar[is16_9];
-        avctx->bit_rate = av_rescale_q(c->sys->frame_size, (AVRational){8,1},
-                                       c->sys->time_base);
+        apt = frame[4] & 0x07;
+        is16_9 = (vsc_pack && ((vsc_pack[2] & 0x07) == 0x02 ||
+                               (!apt && (vsc_pack[2] & 0x07) == 0x07)));
+        avctx->sample_aspect_ratio = c->sys->sar[is16_9];
+        avctx->bit_rate = av_rescale(c->sys->frame_size * 8,
+                                     c->sys->frame_rate,
+                                     c->sys->frame_rate_base);
         size = c->sys->frame_size;
     }
     return size;
@@ -283,17 +286,17 @@
         return NULL;
     }
 
-    c->sys  = NULL;
+    c->sys = NULL;
     c->fctx = s;
-    memset(c->ast, 0, sizeof(c->ast));
-    c->ach    = 0;
+    c->ast[0] = c->ast[1] = c->ast[2] = c->ast[3] = NULL;
+    c->ach = 0;
     c->frames = 0;
     c->abytes = 0;
 
     c->vst->codec->codec_type = CODEC_TYPE_VIDEO;
-    c->vst->codec->codec_id   = CODEC_ID_DVVIDEO;
-    c->vst->codec->bit_rate   = 25000000;
-    c->vst->start_time        = 0;
+    c->vst->codec->codec_id = CODEC_ID_DVVIDEO;
+    c->vst->codec->bit_rate = 25000000;
+    c->vst->start_time = 0;
 
     return c;
 }
@@ -303,7 +306,7 @@
     int size = -1;
     int i;
 
-    for (i = 0; i < c->ach; i++) {
+    for (i=0; i<c->ach; i++) {
        if (c->ast[i] && c->audio_pkt[i].size) {
            *pkt = c->audio_pkt[i];
            c->audio_pkt[i].size = 0;
@@ -319,7 +322,7 @@
                       uint8_t* buf, int buf_size)
 {
     int size, i;
-    uint8_t *ppcm[4] = {0};
+    uint8_t *ppcm[4];
 
     if (buf_size < DV_PROFILE_BYTES ||
         !(c->sys = dv_frame_profile(buf)) ||
@@ -330,7 +333,8 @@
     /* Queueing audio packet */
     /* FIXME: in case of no audio/bad audio we have to do something */
     size = dv_extract_audio_info(c, buf);
-    for (i = 0; i < c->ach; i++) {
+    ppcm[0] = ppcm[1] = ppcm[2] = ppcm[3] = NULL;
+    for (i=0; i<c->ach; i++) {
        c->audio_pkt[i].size = size;
        c->audio_pkt[i].pts  = c->abytes * 30000*8 / c->ast[i]->codec->bit_rate;
        ppcm[i] = c->audio_buf[i];
@@ -338,23 +342,14 @@
     dv_extract_audio(buf, ppcm, c->sys);
     c->abytes += size;
 
-    /* We work with 720p frames split in half, thus even frames have
-     * channels 0,1 and odd 2,3. */
-    if (c->sys->height == 720) {
-        if (buf[1] & 0x0C)
-            c->audio_pkt[2].size = c->audio_pkt[3].size = 0;
-        else
-            c->audio_pkt[0].size = c->audio_pkt[1].size = 0;
-    }
-
     /* Now it's time to return video packet */
     size = dv_extract_video_info(c, buf);
     av_init_packet(pkt);
-    pkt->data         = buf;
-    pkt->size         = size;
-    pkt->flags       |= PKT_FLAG_KEY;
+    pkt->data     = buf;
+    pkt->size     = size;
+    pkt->flags   |= PKT_FLAG_KEY;
     pkt->stream_index = c->vst->id;
-    pkt->pts          = c->frames;
+    pkt->pts      = c->frames;
 
     c->frames++;
 
@@ -382,8 +377,9 @@
 {
     c->frames= frame_offset;
     if (c->ach)
-        c->abytes= av_rescale_q(c->frames, c->sys->time_base,
-                                (AVRational){8, c->ast[0]->codec->bit_rate});
+        c->abytes= av_rescale(c->frames,
+                              c->ast[0]->codec->bit_rate * (int64_t)c->sys->frame_rate_base,
+                              8*c->sys->frame_rate);
     c->audio_pkt[0].size = c->audio_pkt[1].size = 0;
     c->audio_pkt[2].size = c->audio_pkt[3].size = 0;
 }
@@ -400,35 +396,25 @@
 static int dv_read_header(AVFormatContext *s,
                           AVFormatParameters *ap)
 {
-    unsigned state;
     RawDVContext *c = s->priv_data;
 
     c->dv_demux = dv_init_demux(s);
     if (!c->dv_demux)
         return -1;
 
-    state = get_be32(s->pb);
-    while ((state & 0xffffff7f) != 0x1f07003f) {
-        if (url_feof(s->pb)) {
-            av_log(s, AV_LOG_ERROR, "Cannot find DV header.\n");
-            return -1;
-        }
-        state = (state << 8) | get_byte(s->pb);
-    }
-    AV_WB32(c->buf, state);
-
-    if (get_buffer(s->pb, c->buf + 4, DV_PROFILE_BYTES - 4) <= 0 ||
+    if (get_buffer(s->pb, c->buf, DV_PROFILE_BYTES) <= 0 ||
         url_fseek(s->pb, -DV_PROFILE_BYTES, SEEK_CUR) < 0)
         return AVERROR(EIO);
 
     c->dv_demux->sys = dv_frame_profile(c->buf);
-    if (!c->dv_demux->sys) {
-        av_log(s, AV_LOG_ERROR, "Can't determine profile of DV input stream.\n");
-        return -1;
+    if(!c->dv_demux->sys) {
+	av_log(s, AV_LOG_ERROR, "Can't determine profile of DV input stream.\n");
+	return -1;
     }
 
-    s->bit_rate = av_rescale_q(c->dv_demux->sys->frame_size, (AVRational){8,1},
-                               c->dv_demux->sys->time_base);
+    s->bit_rate = av_rescale(c->dv_demux->sys->frame_size * 8,
+                             c->dv_demux->sys->frame_rate,
+                             c->dv_demux->sys->frame_rate_base);
 
     return 0;
 }
@@ -442,8 +428,6 @@
     size = dv_get_packet(c->dv_demux, pkt);
 
     if (size < 0) {
-        if (!c->dv_demux->sys)
-            return AVERROR(EIO);
         size = c->dv_demux->sys->frame_size;
         if (get_buffer(s->pb, c->buf, size) <= 0)
             return AVERROR(EIO);
@@ -457,14 +441,14 @@
 static int dv_read_seek(AVFormatContext *s, int stream_index,
                        int64_t timestamp, int flags)
 {
-    RawDVContext *r   = s->priv_data;
+    RawDVContext *r = s->priv_data;
     DVDemuxContext *c = r->dv_demux;
-    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);
+    int64_t offset= dv_frame_offset(s, c, timestamp, flags);
 
     dv_offset_reset(c, offset / c->sys->frame_size);
 
     offset = url_fseek(s->pb, offset, SEEK_SET);
-    return (offset < 0) ? offset : 0;
+    return (offset < 0)?offset:0;
 }
 
 static int dv_read_close(AVFormatContext *s)
--- libavformat/dv.h	2009-01-20 02:46:40.000000000 +1100
+++ ../ffmpeg-0.5-DVCPROHD/libavformat/dv.h	2009-03-16 12:11:28.083444869 +1100
@@ -29,6 +29,7 @@
 #define AVFORMAT_DV_H
 
 #include "avformat.h"
+#include "libavutil/fifo.h"
 
 typedef struct DVDemuxContext DVDemuxContext;
 DVDemuxContext* dv_init_demux(AVFormatContext* s);
@@ -38,7 +39,32 @@
 
 typedef struct DVMuxContext DVMuxContext;
 DVMuxContext* dv_init_mux(AVFormatContext* s);
-int dv_assemble_frame(DVMuxContext *c, AVStream*, uint8_t*, int, uint8_t**);
+int dv_assemble_frame(DVMuxContext *c, AVStream*, const uint8_t*, int, uint8_t**);
 void dv_delete_mux(DVMuxContext*);
 
+/* DJM - additional public exports for use by fastencode */
+
+struct DVprofile;
+const struct DVprofile* dv_get_codec_profile(AVCodecContext*);
+
+#ifndef DV_MAX_FRAME_SIZE
+#define DV_MAX_FRAME_SIZE 576000
+#endif
+
+struct DVMuxContext {
+    const struct DVprofile* sys; /* Current DV profile. E.g.: 525/60, 625/50 */
+    int         n_ast;        /* Number of stereo audio streams (up to 4) */
+    AVStream   *ast[4];       /* Stereo audio streams */
+    AVFifoBuffer  audio_data[4]; /* Fifo for storing excessive amounts of PCM */
+
+    int         frames;       /* Number of a current frame */
+    time_t      start_time;   /* Start time of recording */
+    int         has_audio;    /* frame under contruction has audio */
+    int         has_video;    /* frame under contruction has video */
+    uint8_t     frame_buf[DV_MAX_FRAME_SIZE]; /* frame under contruction */
+};
+
+void dv_inject_metadata(DVMuxContext *c, uint8_t* frame);
+void dv_inject_audio_raw(DVMuxContext *c, int channel, uint8_t* frame_ptr, uint8_t *data);
+
 #endif /* AVFORMAT_DV_H */
